import { ASRContext, ASREvent, ASRInit, ASRPonyfillInput, Hypothesis, AzureLanguageCredentials } from "./types";
export declare const asrMachine: import("xstate").StateMachine<ASRContext, ASREvent, {
    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
        query: string;
        locale: string;
    }, import("xstate").EventObject>>;
}, import("xstate").Values<{
    maybe_ponyfill: {
        src: "maybe_ponyfill";
        logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
        id: string;
    };
    nluPromise: {
        src: "nluPromise";
        logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
            query: string;
            locale: string;
        }, import("xstate").EventObject>;
        id: string;
    };
}>, import("xstate").Values<{
    raise_noinput_after_timeout: {
        type: "raise_noinput_after_timeout";
        params: {};
    };
    cancel_noinput_timeout: {
        type: "cancel_noinput_timeout";
        params: {};
    };
}>, {
    type: "nlu_is_activated";
    params: unknown;
}, "noinputTimeout", "Ready" | "Fail" | {
    Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
        Pausing: "Paused" | "WaitToPause" | "Continue";
    };
}, string, ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
    readonly id: "asr";
    readonly context: ({ input }: {
        spawn: {
            <TSrc extends "maybe_ponyfill" | "nluPromise">(logic: TSrc, ...[options]: ({
                src: "maybe_ponyfill";
                logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                id: string;
            } extends infer T ? T extends {
                src: "maybe_ponyfill";
                logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                id: string;
            } ? T extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T["logic"]>;
                syncSnapshot?: boolean;
            } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                src: "nluPromise";
                logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                    query: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            } extends infer T_1 ? T_1 extends {
                src: "nluPromise";
                logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                    query: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            } ? T_1 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_1["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_1["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                maybe_ponyfill: {
                    src: "maybe_ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                    id: string;
                };
                nluPromise: {
                    src: "nluPromise";
                    logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                        query: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                };
            }>, "src", TSrc>["logic"]>;
            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                id?: never;
                systemId?: string;
                input?: import("xstate").InputFrom<TLogic>;
                syncSnapshot?: boolean;
            }): import("xstate").ActorRefFromLogic<TLogic>;
        };
        input: ASRInit;
        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<ASRContext, ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, ASREvent, import("xstate").AnyEventObject>;
    }) => {
        azureAuthorizationToken: string;
        asrDefaultCompleteTimeout: number;
        asrDefaultNoInputTimeout: number;
        locale: string;
        audioContext: AudioContext;
        azureRegion: string;
        azureLanguageCredentials: AzureLanguageCredentials;
        speechRecognitionEndpointId: string;
    };
    readonly initial: "Ready";
    readonly on: {
        readonly NEW_TOKEN: {
            readonly actions: import("xstate").ActionFunction<ASRContext, {
                type: "NEW_TOKEN";
                value: string;
            }, ASREvent, undefined, import("xstate").Values<{
                maybe_ponyfill: {
                    src: "maybe_ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                    id: string;
                };
                nluPromise: {
                    src: "nluPromise";
                    logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                        query: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                };
            }>, never, never, never, never>;
        };
    };
    readonly states: {
        readonly Fail: {};
        readonly Ready: {
            readonly entry: import("xstate").ActionFunction<ASRContext, ASREvent, ASREvent, undefined, never, never, never, "noinputTimeout", never>;
            readonly on: {
                readonly START: {
                    readonly target: "Recognising";
                    readonly actions: import("xstate").ActionFunction<ASRContext, {
                        type: "START";
                        value?: import("./types").RecogniseParameters;
                    }, ASREvent, undefined, import("xstate").Values<{
                        maybe_ponyfill: {
                            src: "maybe_ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                                query: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>;
                };
            };
        };
        readonly Recognising: {
            readonly onDone: "Ready";
            readonly invoke: {
                readonly id: "asr";
                readonly src: "maybe_ponyfill";
                readonly input: ({ context }: {
                    context: ASRContext;
                    event: ASREvent;
                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<ASRContext, ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, ASREvent, import("xstate").AnyEventObject>;
                }) => {
                    azureRegion: string;
                    audioContext: AudioContext;
                    azureAuthorizationToken: string;
                    locale: string;
                    speechRecognitionEndpointId: string;
                    completeTimeout: number;
                    hints: string[];
                };
            };
            readonly on: {
                readonly FINAL_RESULT: readonly [{
                    readonly target: ".NLURequest";
                    readonly guard: {
                        readonly type: "nlu_is_activated";
                    };
                }, {
                    readonly target: ".WaitToStop";
                    readonly actions: import("xstate").ActionFunction<ASRContext, {
                        type: "FINAL_RESULT";
                    }, ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                }];
                readonly RESULT: {
                    readonly actions: readonly [import("xstate").ActionFunction<ASRContext, {
                        type: "RESULT";
                        value: Hypothesis[];
                    }, ASREvent, undefined, import("xstate").Values<{
                        maybe_ponyfill: {
                            src: "maybe_ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                                query: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>, import("xstate").CancelAction<ASRContext, {
                        type: "RESULT";
                        value: Hypothesis[];
                    }, undefined, ASREvent>];
                    readonly target: ".InterimResult";
                };
                readonly STOP: {
                    readonly target: ".WaitToStop";
                };
                readonly CONTROL: {
                    readonly target: ".Pausing";
                };
                readonly NOINPUT: {
                    readonly actions: import("xstate").ActionFunction<ASRContext, {
                        type: "NOINPUT";
                    }, ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                    readonly target: ".WaitToStop";
                };
            };
            readonly initial: "WaitForRecogniser";
            readonly states: {
                readonly WaitForRecogniser: {
                    readonly on: {
                        readonly STARTED: {
                            readonly target: "NoInput";
                            readonly actions: readonly [() => void, import("xstate").ActionFunction<ASRContext, {
                                type: "STARTED";
                                value: {
                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                };
                            }, ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                        };
                    };
                };
                readonly NoInput: {
                    readonly entry: {
                        readonly type: "raise_noinput_after_timeout";
                    };
                    readonly on: {
                        readonly STARTSPEECH: {
                            readonly target: "InProgress";
                            readonly actions: import("xstate").CancelAction<ASRContext, {
                                type: "STARTSPEECH";
                            }, undefined, ASREvent>;
                        };
                    };
                    readonly exit: {
                        readonly type: "cancel_noinput_timeout";
                    };
                };
                readonly InProgress: {
                    readonly entry: () => void;
                };
                readonly InterimResult: {
                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<ASRContext, ASREvent, ASREvent>) => void, import("xstate").ActionFunction<ASRContext, ASREvent, ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                };
                readonly WaitToStop: {
                    readonly entry: import("xstate").ActionFunction<ASRContext, ASREvent, ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                    readonly on: {
                        readonly LISTEN_COMPLETE: {
                            readonly actions: import("xstate").ActionFunction<ASRContext, {
                                type: "LISTEN_COMPLETE";
                            }, ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                            readonly target: "Stopped";
                        };
                    };
                };
                readonly Pausing: {
                    readonly onDone: "#asr.Recognising";
                    readonly initial: "WaitToPause";
                    readonly states: {
                        readonly WaitToPause: {
                            readonly entry: import("xstate").ActionFunction<ASRContext, ASREvent, ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                            readonly on: {
                                readonly LISTEN_COMPLETE: {
                                    readonly target: "Paused";
                                };
                            };
                        };
                        readonly Paused: {
                            readonly entry: import("xstate").ActionFunction<ASRContext, ASREvent, ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                            readonly on: {
                                readonly CONTROL: {
                                    readonly target: "Continue";
                                };
                            };
                        };
                        readonly Continue: {
                            readonly type: "final";
                        };
                    };
                };
                readonly NLURequest: {
                    readonly invoke: {
                        readonly src: "nluPromise";
                        readonly input: ({ context }: {
                            context: ASRContext;
                            event: ASREvent;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<ASRContext, ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, ASREvent, import("xstate").AnyEventObject>;
                        }) => {
                            endpoint: string;
                            key: string;
                            projectName: string;
                            deploymentName: string;
                            query: string;
                            locale: string;
                        };
                        readonly onDone: readonly [{
                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<ASRContext, import("xstate").DoneActorEvent<any, string>, ASREvent>) => void, import("xstate").ActionFunction<ASRContext, import("xstate").DoneActorEvent<any, string>, ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                            readonly target: "WaitToStop";
                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                        }, {
                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<ASRContext, import("xstate").DoneActorEvent<any, string>, ASREvent>) => void, import("xstate").ActionFunction<ASRContext, import("xstate").DoneActorEvent<any, string>, ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                            readonly target: "WaitToStop";
                        }];
                        readonly onError: {
                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<ASRContext, import("xstate").ErrorActorEvent<unknown, string>, ASREvent>) => void, import("xstate").ActionFunction<ASRContext, import("xstate").ErrorActorEvent<unknown, string>, ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                            readonly target: "WaitToStop";
                        };
                    };
                };
                readonly Stopped: {
                    readonly type: "final";
                };
            };
        };
    };
}>;
//# sourceMappingURL=asr.d.ts.map