import { Agenda, TTSInit, TTSEvent, TTSContext, TTSPonyfillInput } from "./types";
export declare const ttsMachine: import("xstate").StateMachine<TTSContext, TTSEvent, {
    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
        cacheURL: string;
        utterance: string;
        voice: string;
        locale: string;
    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
        audioContext: AudioContext;
        cacheURL: string;
        utterance: string;
        voice: string;
        locale: string;
    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
        audioContext: AudioContext;
        audioURL: string;
    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
        audioContext: AudioContext;
        audioBuffer: AudioBuffer;
    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
        utterance: string;
        voice: string;
        ttsLexicon: string;
        locale: string;
        wsaUtt: {
            prototype: SpeechSynthesisUtterance;
            new (text?: string): SpeechSynthesisUtterance;
        };
        wsaTTS: SpeechSynthesis;
        visemes?: boolean;
    }, import("xstate").EventObject>>;
}, import("xstate").Values<{
    checkCache: {
        src: "checkCache";
        logic: import("xstate").PromiseActorLogic<any, {
            cacheURL: string;
            utterance: string;
            voice: string;
            locale: string;
        }, import("xstate").EventObject>;
        id: string;
    };
    getAudioFromCache: {
        src: "getAudioFromCache";
        logic: import("xstate").PromiseActorLogic<any, {
            audioContext: AudioContext;
            cacheURL: string;
            utterance: string;
            voice: string;
            locale: string;
        }, import("xstate").EventObject>;
        id: string;
    };
    getAudio: {
        src: "getAudio";
        logic: import("xstate").PromiseActorLogic<any, {
            audioContext: AudioContext;
            audioURL: string;
        }, import("xstate").EventObject>;
        id: string;
    };
    playAudio: {
        src: "playAudio";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
            audioContext: AudioContext;
            audioBuffer: AudioBuffer;
        }, import("xstate").EventObject>;
        id: string;
    };
    createEventsFromStream: {
        src: "createEventsFromStream";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
        id: string;
    };
    ponyfill: {
        src: "ponyfill";
        logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
        id: string;
    };
    start: {
        src: "start";
        logic: import("xstate").CallbackActorLogic<null, {
            utterance: string;
            voice: string;
            ttsLexicon: string;
            locale: string;
            wsaUtt: {
                prototype: SpeechSynthesisUtterance;
                new (text?: string): SpeechSynthesisUtterance;
            };
            wsaTTS: SpeechSynthesis;
            visemes?: boolean;
        }, import("xstate").EventObject>;
        id: string;
    };
}>, import("xstate").Values<{
    ttsStop: {
        type: "ttsStop";
        params: unknown;
    };
    addFiller: {
        type: "addFiller";
        params: {};
    };
    assignCurrentVoice: {
        type: "assignCurrentVoice";
        params: {};
    };
    assignCurrentLocale: {
        type: "assignCurrentLocale";
        params: {};
    };
    sendParentCurrentPersona: {
        type: "sendParentCurrentPersona";
        params: {};
    };
}>, import("xstate").Values<{
    bufferContainsUtterancePartReadyToBeSpoken: {
        type: "bufferContainsUtterancePartReadyToBeSpoken";
        params: unknown;
    };
    bufferIsNonEmpty: {
        type: "bufferIsNonEmpty";
        params: unknown;
    };
}>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
    Operation: "NotReady" | {
        Ready: "Idle" | {
            BufferedSpeaker: {
                Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                    Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                        UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                    };
                };
            };
        } | {
            Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
        } | {
            Speaking: "Go" | "Paused";
        };
    };
    MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
}, string, TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
    readonly id: "tts";
    readonly context: ({ input }: {
        spawn: {
            <TSrc extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                src: "checkCache";
                logic: import("xstate").PromiseActorLogic<any, {
                    cacheURL: string;
                    utterance: string;
                    voice: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            } extends infer T ? T extends {
                src: "checkCache";
                logic: import("xstate").PromiseActorLogic<any, {
                    cacheURL: string;
                    utterance: string;
                    voice: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            } ? T extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T["logic"]>;
                syncSnapshot?: boolean;
            } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                src: "getAudioFromCache";
                logic: import("xstate").PromiseActorLogic<any, {
                    audioContext: AudioContext;
                    cacheURL: string;
                    utterance: string;
                    voice: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            } extends infer T_1 ? T_1 extends {
                src: "getAudioFromCache";
                logic: import("xstate").PromiseActorLogic<any, {
                    audioContext: AudioContext;
                    cacheURL: string;
                    utterance: string;
                    voice: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            } ? T_1 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_1["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_1["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                src: "getAudio";
                logic: import("xstate").PromiseActorLogic<any, {
                    audioContext: AudioContext;
                    audioURL: string;
                }, import("xstate").EventObject>;
                id: string;
            } extends infer T_2 ? T_2 extends {
                src: "getAudio";
                logic: import("xstate").PromiseActorLogic<any, {
                    audioContext: AudioContext;
                    audioURL: string;
                }, import("xstate").EventObject>;
                id: string;
            } ? T_2 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_2["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_2["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                src: "playAudio";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                    audioContext: AudioContext;
                    audioBuffer: AudioBuffer;
                }, import("xstate").EventObject>;
                id: string;
            } extends infer T_3 ? T_3 extends {
                src: "playAudio";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                    audioContext: AudioContext;
                    audioBuffer: AudioBuffer;
                }, import("xstate").EventObject>;
                id: string;
            } ? T_3 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_3["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_3["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                src: "createEventsFromStream";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                id: string;
            } extends infer T_4 ? T_4 extends {
                src: "createEventsFromStream";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                id: string;
            } ? T_4 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_4["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_4["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                id: string;
            } extends infer T_5 ? T_5 extends {
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                id: string;
            } ? T_5 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_5["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_5["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                src: "start";
                logic: import("xstate").CallbackActorLogic<null, {
                    utterance: string;
                    voice: string;
                    ttsLexicon: string;
                    locale: string;
                    wsaUtt: {
                        prototype: SpeechSynthesisUtterance;
                        new (text?: string): SpeechSynthesisUtterance;
                    };
                    wsaTTS: SpeechSynthesis;
                    visemes?: boolean;
                }, import("xstate").EventObject>;
                id: string;
            } extends infer T_6 ? T_6 extends {
                src: "start";
                logic: import("xstate").CallbackActorLogic<null, {
                    utterance: string;
                    voice: string;
                    ttsLexicon: string;
                    locale: string;
                    wsaUtt: {
                        prototype: SpeechSynthesisUtterance;
                        new (text?: string): SpeechSynthesisUtterance;
                    };
                    wsaTTS: SpeechSynthesis;
                    visemes?: boolean;
                }, import("xstate").EventObject>;
                id: string;
            } ? T_6 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_6["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_6["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                checkCache: {
                    src: "checkCache";
                    logic: import("xstate").PromiseActorLogic<any, {
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                };
                getAudioFromCache: {
                    src: "getAudioFromCache";
                    logic: import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                };
                getAudio: {
                    src: "getAudio";
                    logic: import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        audioURL: string;
                    }, import("xstate").EventObject>;
                    id: string;
                };
                playAudio: {
                    src: "playAudio";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                        audioContext: AudioContext;
                        audioBuffer: AudioBuffer;
                    }, import("xstate").EventObject>;
                    id: string;
                };
                createEventsFromStream: {
                    src: "createEventsFromStream";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                    id: string;
                };
                ponyfill: {
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                    id: string;
                };
                start: {
                    src: "start";
                    logic: import("xstate").CallbackActorLogic<null, {
                        utterance: string;
                        voice: string;
                        ttsLexicon: string;
                        locale: string;
                        wsaUtt: {
                            prototype: SpeechSynthesisUtterance;
                            new (text?: string): SpeechSynthesisUtterance;
                        };
                        wsaTTS: SpeechSynthesis;
                        visemes?: boolean;
                    }, import("xstate").EventObject>;
                    id: string;
                };
            }>, "src", TSrc>["logic"]>;
            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                id?: never;
                systemId?: string;
                input?: import("xstate").InputFrom<TLogic>;
                syncSnapshot?: boolean;
            }): import("xstate").ActorRefFromLogic<TLogic>;
        };
        input: TTSInit;
        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
    }) => {
        azureAuthorizationToken: string;
        ttsDefaultVoice: string;
        ttsDefaultFillerDelay: number;
        ttsDefaultFiller: string;
        ttsLexicon: string;
        audioContext: AudioContext;
        azureRegion: string;
        locale: string;
        buffer: string;
    };
    readonly on: {
        readonly ERROR: {
            readonly actions: import("xstate").ActionFunction<TTSContext, {
                type: "ERROR";
            }, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
        };
    };
    readonly type: "parallel";
    readonly states: {
        readonly Operation: {
            readonly initial: "NotReady";
            readonly states: {
                readonly NotReady: {
                    readonly on: {
                        readonly READY: {
                            readonly target: "Ready";
                            readonly actions: import("xstate").ActionFunction<TTSContext, {
                                type: "READY";
                                value: {
                                    wsaTTS: SpeechSynthesis;
                                    wsaUtt: {
                                        prototype: SpeechSynthesisUtterance;
                                        new (text?: string): SpeechSynthesisUtterance;
                                    };
                                };
                            }, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                        };
                    };
                };
                readonly Ready: {
                    readonly initial: "Idle";
                    readonly states: {
                        readonly Idle: {
                            readonly id: "Idle";
                            readonly on: {
                                readonly SPEAK: readonly [{
                                    readonly target: "BufferedSpeaker";
                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<TTSContext, {
                                        type: "SPEAK";
                                        value: Agenda;
                                    }>) => boolean;
                                    readonly actions: import("xstate").ActionFunction<TTSContext, {
                                        type: "SPEAK";
                                        value: Agenda;
                                    }, TTSEvent, undefined, import("xstate").Values<{
                                        checkCache: {
                                            src: "checkCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudioFromCache: {
                                            src: "getAudioFromCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudio: {
                                            src: "getAudio";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        playAudio: {
                                            src: "playAudio";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<null, {
                                                utterance: string;
                                                voice: string;
                                                ttsLexicon: string;
                                                locale: string;
                                                wsaUtt: {
                                                    prototype: SpeechSynthesisUtterance;
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                };
                                                wsaTTS: SpeechSynthesis;
                                                visemes?: boolean;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                }, {
                                    readonly target: "Playing";
                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<TTSContext, {
                                        type: "SPEAK";
                                        value: Agenda;
                                    }>) => boolean;
                                    readonly actions: import("xstate").ActionFunction<TTSContext, {
                                        type: "SPEAK";
                                        value: Agenda;
                                    }, TTSEvent, undefined, import("xstate").Values<{
                                        checkCache: {
                                            src: "checkCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudioFromCache: {
                                            src: "getAudioFromCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudio: {
                                            src: "getAudio";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        playAudio: {
                                            src: "playAudio";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<null, {
                                                utterance: string;
                                                voice: string;
                                                ttsLexicon: string;
                                                locale: string;
                                                wsaUtt: {
                                                    prototype: SpeechSynthesisUtterance;
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                };
                                                wsaTTS: SpeechSynthesis;
                                                visemes?: boolean;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                }, {
                                    readonly target: "Speaking";
                                    readonly actions: readonly [import("xstate").ActionFunction<TTSContext, {
                                        type: "SPEAK";
                                        value: Agenda;
                                    }, TTSEvent, undefined, import("xstate").Values<{
                                        checkCache: {
                                            src: "checkCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudioFromCache: {
                                            src: "getAudioFromCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudio: {
                                            src: "getAudio";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        playAudio: {
                                            src: "playAudio";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<null, {
                                                utterance: string;
                                                voice: string;
                                                ttsLexicon: string;
                                                locale: string;
                                                wsaUtt: {
                                                    prototype: SpeechSynthesisUtterance;
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                };
                                                wsaTTS: SpeechSynthesis;
                                                visemes?: boolean;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<TTSContext, {
                                        type: "SPEAK";
                                        value: Agenda;
                                    }, TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<TTSContext, {
                                        type: "SPEAK";
                                        value: Agenda;
                                    }, TTSEvent>) => void];
                                }];
                            };
                        };
                        readonly BufferedSpeaker: {
                            readonly type: "parallel";
                            readonly invoke: {
                                readonly id: "createEventsFromStream";
                                readonly src: "createEventsFromStream";
                                readonly input: ({ context }: {
                                    context: TTSContext;
                                    event: TTSEvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                }) => Agenda;
                            };
                            readonly on: {
                                readonly STOP: {
                                    readonly target: "Idle";
                                };
                            };
                            readonly states: {
                                readonly Buffer: {
                                    readonly initial: "BufferIdle";
                                    readonly on: {
                                        readonly STREAMING_SET_VOICE: {
                                            readonly actions: "assignCurrentVoice";
                                        };
                                        readonly STREAMING_SET_LOCALE: {
                                            readonly actions: "assignCurrentLocale";
                                        };
                                        readonly STREAMING_SET_PERSONA: {
                                            readonly actions: "sendParentCurrentPersona";
                                        };
                                    };
                                    readonly states: {
                                        readonly BufferIdle: {
                                            readonly id: "BufferIdle";
                                            readonly on: {
                                                readonly STREAMING_CHUNK: {
                                                    readonly target: "Buffering";
                                                };
                                                readonly STREAMING_DONE: "BufferingDone";
                                            };
                                        };
                                        readonly Buffering: {
                                            readonly id: "Buffering";
                                            readonly on: {
                                                readonly STREAMING_CHUNK: {
                                                    readonly target: "Buffering";
                                                    readonly reenter: true;
                                                };
                                                readonly STREAMING_DONE: "BufferingDone";
                                            };
                                            readonly after: {
                                                readonly STREAMING_TIMEOUT: {
                                                    readonly target: "BufferingDone";
                                                    readonly actions: () => void;
                                                };
                                            };
                                            readonly entry: readonly [import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>];
                                        };
                                        readonly BufferingDone: {
                                            readonly id: "BufferingDone";
                                            readonly type: "final";
                                        };
                                    };
                                };
                                readonly Speaker: {
                                    readonly initial: "SpeakingIdle";
                                    readonly states: {
                                        readonly SpeakingIdle: {
                                            readonly id: "SpeakingIdle";
                                            readonly always: readonly [{
                                                readonly target: "Speak";
                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<TTSContext, TTSEvent, undefined, any>;
                                                readonly actions: readonly [import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>, import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>];
                                            }, {
                                                readonly target: "PrepareSpeech";
                                                readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                            }];
                                            readonly after: {
                                                readonly FILLER_DELAY: {
                                                    readonly target: "SpeakingIdle";
                                                    readonly reenter: true;
                                                    readonly actions: "addFiller";
                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<TTSContext, TTSEvent>) => boolean;
                                                };
                                            };
                                        };
                                        readonly PrepareSpeech: {
                                            readonly entry: readonly [import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>];
                                            readonly always: readonly [{
                                                readonly target: "Speak";
                                            }];
                                        };
                                        readonly Speak: {
                                            readonly initial: "Init";
                                            readonly states: {
                                                readonly Init: {
                                                    readonly always: readonly [{
                                                        readonly target: "CheckCache";
                                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<TTSContext, TTSEvent>) => boolean;
                                                    }, {
                                                        readonly target: "Go";
                                                    }];
                                                };
                                                readonly CheckCache: {
                                                    readonly invoke: {
                                                        readonly src: "checkCache";
                                                        readonly input: ({ context }: {
                                                            context: TTSContext;
                                                            event: TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        };
                                                        readonly onError: "Go";
                                                        readonly onDone: readonly [{
                                                            readonly target: "UseCache";
                                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                            readonly actions: ({ event }: import("xstate").ActionArgs<TTSContext, import("xstate").DoneActorEvent<any, string>, TTSEvent>) => void;
                                                        }, {
                                                            readonly target: "Go";
                                                            readonly actions: ({ event }: import("xstate").ActionArgs<TTSContext, import("xstate").DoneActorEvent<any, string>, TTSEvent>) => void;
                                                        }];
                                                    };
                                                };
                                                readonly UseCache: {
                                                    readonly initial: "GetAudio";
                                                    readonly states: {
                                                        readonly GetAudio: {
                                                            readonly invoke: {
                                                                readonly src: "getAudioFromCache";
                                                                readonly input: ({ context }: {
                                                                    context: TTSContext;
                                                                    event: TTSEvent;
                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                                                }) => {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                };
                                                                readonly onDone: {
                                                                    readonly target: "PlayAudio";
                                                                    readonly actions: import("xstate").ActionFunction<TTSContext, import("xstate").DoneActorEvent<any, string>, TTSEvent, undefined, import("xstate").Values<{
                                                                        checkCache: {
                                                                            src: "checkCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudioFromCache: {
                                                                            src: "getAudioFromCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudio: {
                                                                            src: "getAudio";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                audioURL: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        playAudio: {
                                                                            src: "playAudio";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                audioContext: AudioContext;
                                                                                audioBuffer: AudioBuffer;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        createEventsFromStream: {
                                                                            src: "createEventsFromStream";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        ponyfill: {
                                                                            src: "ponyfill";
                                                                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        start: {
                                                                            src: "start";
                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                utterance: string;
                                                                                voice: string;
                                                                                ttsLexicon: string;
                                                                                locale: string;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                                wsaTTS: SpeechSynthesis;
                                                                                visemes?: boolean;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                    }>, never, never, never, never>;
                                                                };
                                                                readonly onError: "#TtsStreamGo";
                                                            };
                                                        };
                                                        readonly PlayAudio: {
                                                            readonly entry: ({ context }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void;
                                                            readonly invoke: {
                                                                readonly src: "playAudio";
                                                                readonly input: ({ context }: {
                                                                    context: TTSContext;
                                                                    event: TTSEvent;
                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                                                }) => {
                                                                    audioBuffer: AudioBuffer;
                                                                    audioContext: AudioContext;
                                                                };
                                                            };
                                                            readonly on: {
                                                                readonly CONTROL: "PausedAudio";
                                                                readonly SPEAK_COMPLETE: readonly [{
                                                                    readonly target: "#SpeakingDone";
                                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<TTSContext, {
                                                                        type: "SPEAK_COMPLETE";
                                                                    }, unknown, any>;
                                                                }, {
                                                                    readonly target: "#SpeakingIdle";
                                                                }];
                                                                readonly TTS_STARTED: {
                                                                    readonly actions: readonly [import("xstate").ActionFunction<TTSContext, {
                                                                        type: "TTS_STARTED";
                                                                        value?: AudioBufferSourceNode;
                                                                    }, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<TTSContext, {
                                                                        type: "TTS_STARTED";
                                                                        value?: AudioBufferSourceNode;
                                                                    }, TTSEvent, undefined, import("xstate").Values<{
                                                                        checkCache: {
                                                                            src: "checkCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudioFromCache: {
                                                                            src: "getAudioFromCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudio: {
                                                                            src: "getAudio";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                audioURL: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        playAudio: {
                                                                            src: "playAudio";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                audioContext: AudioContext;
                                                                                audioBuffer: AudioBuffer;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        createEventsFromStream: {
                                                                            src: "createEventsFromStream";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        ponyfill: {
                                                                            src: "ponyfill";
                                                                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        start: {
                                                                            src: "start";
                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                utterance: string;
                                                                                voice: string;
                                                                                ttsLexicon: string;
                                                                                locale: string;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                                wsaTTS: SpeechSynthesis;
                                                                                visemes?: boolean;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                    }>, never, never, never, never>];
                                                                };
                                                            };
                                                            readonly exit: "ttsStop";
                                                        };
                                                        readonly PausedAudio: {
                                                            readonly on: {
                                                                readonly CONTROL: "PlayAudio";
                                                            };
                                                        };
                                                    };
                                                };
                                                readonly Go: {
                                                    readonly id: "TtsStreamGo";
                                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void];
                                                    readonly invoke: {
                                                        readonly src: "start";
                                                        readonly input: ({ context }: {
                                                            context: TTSContext;
                                                            event: TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            wsaTTS: SpeechSynthesis;
                                                            wsaUtt: {
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                prototype: SpeechSynthesisUtterance;
                                                            };
                                                            ttsLexicon: string;
                                                            visemes: boolean;
                                                            voice: string;
                                                            locale: string;
                                                            utterance: string;
                                                        };
                                                    };
                                                    readonly on: {
                                                        readonly CONTROL: "Paused";
                                                        readonly SPEAK_COMPLETE: readonly [{
                                                            readonly target: "#SpeakingDone";
                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<TTSContext, {
                                                                type: "SPEAK_COMPLETE";
                                                            }, unknown, any>;
                                                        }, {
                                                            readonly target: "#SpeakingIdle";
                                                        }];
                                                        readonly TTS_STARTED: {
                                                            readonly actions: import("xstate").ActionFunction<TTSContext, {
                                                                type: "TTS_STARTED";
                                                                value?: AudioBufferSourceNode;
                                                            }, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                        };
                                                    };
                                                    readonly exit: "ttsStop";
                                                };
                                                readonly Paused: {
                                                    readonly on: {
                                                        readonly CONTROL: "Go";
                                                    };
                                                };
                                            };
                                        };
                                        readonly SpeakingDone: {
                                            readonly id: "SpeakingDone";
                                            readonly type: "final";
                                        };
                                    };
                                };
                            };
                            readonly onDone: {
                                readonly target: "Idle";
                                readonly actions: import("xstate").ActionFunction<TTSContext, import("xstate").DoneStateEvent<unknown>, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                            };
                        };
                        readonly Playing: {
                            readonly on: {
                                readonly SPEAK_COMPLETE: {
                                    readonly target: "Idle";
                                    readonly actions: import("xstate").ActionFunction<TTSContext, {
                                        type: "SPEAK_COMPLETE";
                                    }, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                };
                                readonly TTS_STARTED: {
                                    readonly actions: readonly [import("xstate").ActionFunction<TTSContext, {
                                        type: "TTS_STARTED";
                                        value?: AudioBufferSourceNode;
                                    }, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<TTSContext, {
                                        type: "TTS_STARTED";
                                        value?: AudioBufferSourceNode;
                                    }, TTSEvent, undefined, import("xstate").Values<{
                                        checkCache: {
                                            src: "checkCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudioFromCache: {
                                            src: "getAudioFromCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudio: {
                                            src: "getAudio";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        playAudio: {
                                            src: "playAudio";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<null, {
                                                utterance: string;
                                                voice: string;
                                                ttsLexicon: string;
                                                locale: string;
                                                wsaUtt: {
                                                    prototype: SpeechSynthesisUtterance;
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                };
                                                wsaTTS: SpeechSynthesis;
                                                visemes?: boolean;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                                readonly STOP: {
                                    readonly target: "Idle";
                                };
                            };
                            readonly initial: "FetchAudio";
                            readonly states: {
                                readonly FetchAudio: {
                                    readonly invoke: {
                                        readonly src: "getAudio";
                                        readonly input: ({ context }: {
                                            context: TTSContext;
                                            event: TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            audioContext: AudioContext;
                                            audioURL: string;
                                        };
                                        readonly onDone: {
                                            readonly target: "PlayAudio";
                                            readonly actions: import("xstate").ActionFunction<TTSContext, import("xstate").DoneActorEvent<any, string>, TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        };
                                        readonly onError: {
                                            readonly target: "#Speaking";
                                        };
                                    };
                                };
                                readonly PlayAudio: {
                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void];
                                    readonly invoke: {
                                        readonly src: "playAudio";
                                        readonly input: ({ context }: {
                                            context: TTSContext;
                                            event: TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            audioContext: AudioContext;
                                            audioBuffer: AudioBuffer;
                                        };
                                    };
                                    readonly on: {
                                        readonly CONTROL: "AudioPaused";
                                    };
                                    readonly exit: "ttsStop";
                                };
                                readonly AudioPaused: {
                                    readonly on: {
                                        readonly CONTROL: "PlayAudio";
                                    };
                                };
                            };
                        };
                        readonly Speaking: {
                            readonly id: "Speaking";
                            readonly initial: "Go";
                            readonly on: {
                                readonly STOP: {
                                    readonly target: "Idle";
                                };
                                readonly TTS_STARTED: {
                                    readonly actions: import("xstate").ActionFunction<TTSContext, {
                                        type: "TTS_STARTED";
                                        value?: AudioBufferSourceNode;
                                    }, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                };
                                readonly VISEME: {
                                    readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                        type: "VISEME";
                                        value: any;
                                    }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                };
                                readonly SPEAK_COMPLETE: {
                                    readonly target: "Idle";
                                };
                            };
                            readonly exit: import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                            readonly states: {
                                readonly Go: {
                                    readonly invoke: {
                                        readonly src: "start";
                                        readonly input: ({ context }: {
                                            context: TTSContext;
                                            event: TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            wsaTTS: SpeechSynthesis;
                                            wsaUtt: {
                                                new (text?: string): SpeechSynthesisUtterance;
                                                prototype: SpeechSynthesisUtterance;
                                            };
                                            ttsLexicon: string;
                                            voice: string;
                                            visemes: boolean;
                                            locale: string;
                                            utterance: string;
                                        };
                                    };
                                    readonly on: {
                                        readonly CONTROL: "Paused";
                                    };
                                    readonly exit: "ttsStop";
                                };
                                readonly Paused: {
                                    readonly on: {
                                        readonly SPEAK_COMPLETE: {};
                                        readonly CONTROL: "Go";
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
        readonly MaybeHandleNewTokens: {
            readonly initial: "Choice";
            readonly states: {
                readonly Choice: {
                    readonly always: readonly [{
                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<TTSContext, TTSEvent>) => boolean;
                        readonly target: "Ponyfill";
                    }, {
                        readonly target: "NoPonyfill";
                    }];
                };
                readonly NoPonyfill: {
                    readonly entry: readonly [import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                        checkCache: {
                            src: "checkCache";
                            logic: import("xstate").PromiseActorLogic<any, {
                                cacheURL: string;
                                utterance: string;
                                voice: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        getAudioFromCache: {
                            src: "getAudioFromCache";
                            logic: import("xstate").PromiseActorLogic<any, {
                                audioContext: AudioContext;
                                cacheURL: string;
                                utterance: string;
                                voice: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        getAudio: {
                            src: "getAudio";
                            logic: import("xstate").PromiseActorLogic<any, {
                                audioContext: AudioContext;
                                audioURL: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        playAudio: {
                            src: "playAudio";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                audioContext: AudioContext;
                                audioBuffer: AudioBuffer;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<null, {
                                utterance: string;
                                voice: string;
                                ttsLexicon: string;
                                locale: string;
                                wsaUtt: {
                                    prototype: SpeechSynthesisUtterance;
                                    new (text?: string): SpeechSynthesisUtterance;
                                };
                                wsaTTS: SpeechSynthesis;
                                visemes?: boolean;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>];
                };
                readonly Ponyfill: {
                    readonly invoke: {
                        readonly id: "ponyTTS";
                        readonly src: "ponyfill";
                        readonly input: ({ context }: {
                            context: TTSContext;
                            event: TTSEvent;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                        }) => {
                            azureAuthorizationToken: string;
                            azureRegion: string;
                            audioContext: AudioContext;
                        };
                    };
                    readonly on: {
                        readonly READY: {
                            readonly actions: import("xstate").ActionFunction<TTSContext, {
                                type: "READY";
                                value: {
                                    wsaTTS: SpeechSynthesis;
                                    wsaUtt: {
                                        prototype: SpeechSynthesisUtterance;
                                        new (text?: string): SpeechSynthesisUtterance;
                                    };
                                };
                            }, TTSEvent, undefined, import("xstate").Values<{
                                checkCache: {
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudioFromCache: {
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudio: {
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                playAudio: {
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>;
                        };
                        readonly NEW_TOKEN: {
                            readonly target: "Ponyfill";
                            readonly actions: import("xstate").ActionFunction<TTSContext, {
                                type: "NEW_TOKEN";
                                value: string;
                            }, TTSEvent, undefined, import("xstate").Values<{
                                checkCache: {
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudioFromCache: {
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudio: {
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                playAudio: {
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>;
                            readonly reenter: true;
                        };
                    };
                };
            };
        };
    };
}>;
//# sourceMappingURL=tts.d.ts.map