import type { Settings, Agenda, Hypothesis, RecogniseParameters, SpeechStateEvent } from "./types";
interface SSContext {
    settings: Settings;
    audioContext?: AudioContext;
    asrRef?: any;
    ttsRef?: any;
    azureAuthorizationToken?: string;
}
declare const speechstate: import("xstate").StateMachine<SSContext, SpeechStateEvent, {
    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
            cacheURL: string;
            utterance: string;
            voice: string;
            locale: string;
        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
            audioContext: AudioContext;
            cacheURL: string;
            utterance: string;
            voice: string;
            locale: string;
        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
            audioContext: AudioContext;
            audioURL: string;
        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
            audioContext: AudioContext;
            audioBuffer: AudioBuffer;
        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
            utterance: string;
            voice: string;
            ttsLexicon: string;
            locale: string;
            wsaUtt: {
                prototype: SpeechSynthesisUtterance;
                new (text?: string): SpeechSynthesisUtterance;
            };
            wsaTTS: SpeechSynthesis;
            visemes?: boolean;
        }, import("xstate").EventObject>>;
    }, import("xstate").Values<{
        checkCache: {
            src: "checkCache";
            logic: import("xstate").PromiseActorLogic<any, {
                cacheURL: string;
                utterance: string;
                voice: string;
                locale: string;
            }, import("xstate").EventObject>;
            id: string;
        };
        getAudioFromCache: {
            src: "getAudioFromCache";
            logic: import("xstate").PromiseActorLogic<any, {
                audioContext: AudioContext;
                cacheURL: string;
                utterance: string;
                voice: string;
                locale: string;
            }, import("xstate").EventObject>;
            id: string;
        };
        getAudio: {
            src: "getAudio";
            logic: import("xstate").PromiseActorLogic<any, {
                audioContext: AudioContext;
                audioURL: string;
            }, import("xstate").EventObject>;
            id: string;
        };
        playAudio: {
            src: "playAudio";
            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                audioContext: AudioContext;
                audioBuffer: AudioBuffer;
            }, import("xstate").EventObject>;
            id: string;
        };
        createEventsFromStream: {
            src: "createEventsFromStream";
            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
            id: string;
        };
        ponyfill: {
            src: "ponyfill";
            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
            id: string;
        };
        start: {
            src: "start";
            logic: import("xstate").CallbackActorLogic<null, {
                utterance: string;
                voice: string;
                ttsLexicon: string;
                locale: string;
                wsaUtt: {
                    prototype: SpeechSynthesisUtterance;
                    new (text?: string): SpeechSynthesisUtterance;
                };
                wsaTTS: SpeechSynthesis;
                visemes?: boolean;
            }, import("xstate").EventObject>;
            id: string;
        };
    }>, import("xstate").Values<{
        ttsStop: {
            type: "ttsStop";
            params: unknown;
        };
        addFiller: {
            type: "addFiller";
            params: {};
        };
        assignCurrentVoice: {
            type: "assignCurrentVoice";
            params: {};
        };
        assignCurrentLocale: {
            type: "assignCurrentLocale";
            params: {};
        };
        sendParentCurrentPersona: {
            type: "sendParentCurrentPersona";
            params: {};
        };
    }>, import("xstate").Values<{
        bufferContainsUtterancePartReadyToBeSpoken: {
            type: "bufferContainsUtterancePartReadyToBeSpoken";
            params: unknown;
        };
        bufferIsNonEmpty: {
            type: "bufferIsNonEmpty";
            params: unknown;
        };
    }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
        Operation: "NotReady" | {
            Ready: "Idle" | {
                BufferedSpeaker: {
                    Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                    Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                        Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                            UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                        };
                    };
                };
            } | {
                Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
            } | {
                Speaking: "Go" | "Paused";
            };
        };
        MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
    }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
        readonly id: "tts";
        readonly context: ({ input }: {
            spawn: {
                <TSrc extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                    src: "checkCache";
                    logic: import("xstate").PromiseActorLogic<any, {
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } extends infer T ? T extends {
                    src: "checkCache";
                    logic: import("xstate").PromiseActorLogic<any, {
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } ? T extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                    src: "getAudioFromCache";
                    logic: import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } extends infer T_1 ? T_1 extends {
                    src: "getAudioFromCache";
                    logic: import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } ? T_1 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_1["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_1["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                    src: "getAudio";
                    logic: import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        audioURL: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } extends infer T_2 ? T_2 extends {
                    src: "getAudio";
                    logic: import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        audioURL: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } ? T_2 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_2["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_2["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                    src: "playAudio";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                        audioContext: AudioContext;
                        audioBuffer: AudioBuffer;
                    }, import("xstate").EventObject>;
                    id: string;
                } extends infer T_3 ? T_3 extends {
                    src: "playAudio";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                        audioContext: AudioContext;
                        audioBuffer: AudioBuffer;
                    }, import("xstate").EventObject>;
                    id: string;
                } ? T_3 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_3["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_3["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                    src: "createEventsFromStream";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                    id: string;
                } extends infer T_4 ? T_4 extends {
                    src: "createEventsFromStream";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                    id: string;
                } ? T_4 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_4["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_4["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                    id: string;
                } extends infer T_5 ? T_5 extends {
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                    id: string;
                } ? T_5 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_5["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_5["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                    src: "start";
                    logic: import("xstate").CallbackActorLogic<null, {
                        utterance: string;
                        voice: string;
                        ttsLexicon: string;
                        locale: string;
                        wsaUtt: {
                            prototype: SpeechSynthesisUtterance;
                            new (text?: string): SpeechSynthesisUtterance;
                        };
                        wsaTTS: SpeechSynthesis;
                        visemes?: boolean;
                    }, import("xstate").EventObject>;
                    id: string;
                } extends infer T_6 ? T_6 extends {
                    src: "start";
                    logic: import("xstate").CallbackActorLogic<null, {
                        utterance: string;
                        voice: string;
                        ttsLexicon: string;
                        locale: string;
                        wsaUtt: {
                            prototype: SpeechSynthesisUtterance;
                            new (text?: string): SpeechSynthesisUtterance;
                        };
                        wsaTTS: SpeechSynthesis;
                        visemes?: boolean;
                    }, import("xstate").EventObject>;
                    id: string;
                } ? T_6 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_6["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_6["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                    checkCache: {
                        src: "checkCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    getAudioFromCache: {
                        src: "getAudioFromCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    getAudio: {
                        src: "getAudio";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            audioURL: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    playAudio: {
                        src: "playAudio";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                            audioContext: AudioContext;
                            audioBuffer: AudioBuffer;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    createEventsFromStream: {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    start: {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<null, {
                            utterance: string;
                            voice: string;
                            ttsLexicon: string;
                            locale: string;
                            wsaUtt: {
                                prototype: SpeechSynthesisUtterance;
                                new (text?: string): SpeechSynthesisUtterance;
                            };
                            wsaTTS: SpeechSynthesis;
                            visemes?: boolean;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, "src", TSrc>["logic"]>;
                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                    id?: never;
                    systemId?: string;
                    input?: import("xstate").InputFrom<TLogic>;
                    syncSnapshot?: boolean;
                }): import("xstate").ActorRefFromLogic<TLogic>;
            };
            input: import("./types").TTSInit;
            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
        }) => {
            azureAuthorizationToken: string;
            ttsDefaultVoice: string;
            ttsDefaultFillerDelay: number;
            ttsDefaultFiller: string;
            ttsLexicon: string;
            audioContext: AudioContext;
            azureRegion: string;
            locale: string;
            buffer: string;
        };
        readonly on: {
            readonly ERROR: {
                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                    type: "ERROR";
                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
            };
        };
        readonly type: "parallel";
        readonly states: {
            readonly Operation: {
                readonly initial: "NotReady";
                readonly states: {
                    readonly NotReady: {
                        readonly on: {
                            readonly READY: {
                                readonly target: "Ready";
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "READY";
                                    value: {
                                        wsaTTS: SpeechSynthesis;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                    };
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                            };
                        };
                    };
                    readonly Ready: {
                        readonly initial: "Idle";
                        readonly states: {
                            readonly Idle: {
                                readonly id: "Idle";
                                readonly on: {
                                    readonly SPEAK: readonly [{
                                        readonly target: "BufferedSpeaker";
                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                            type: "SPEAK";
                                            value: Agenda;
                                        }>) => boolean;
                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                            type: "SPEAK";
                                            value: Agenda;
                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            checkCache: {
                                                src: "checkCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudioFromCache: {
                                                src: "getAudioFromCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudio: {
                                                src: "getAudio";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            playAudio: {
                                                src: "playAudio";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>;
                                    }, {
                                        readonly target: "Playing";
                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                            type: "SPEAK";
                                            value: Agenda;
                                        }>) => boolean;
                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                            type: "SPEAK";
                                            value: Agenda;
                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            checkCache: {
                                                src: "checkCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudioFromCache: {
                                                src: "getAudioFromCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudio: {
                                                src: "getAudio";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            playAudio: {
                                                src: "playAudio";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>;
                                    }, {
                                        readonly target: "Speaking";
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                            type: "SPEAK";
                                            value: Agenda;
                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            checkCache: {
                                                src: "checkCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudioFromCache: {
                                                src: "getAudioFromCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudio: {
                                                src: "getAudio";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            playAudio: {
                                                src: "playAudio";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                            type: "SPEAK";
                                            value: Agenda;
                                        }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                            type: "SPEAK";
                                            value: Agenda;
                                        }, import("./types").TTSEvent>) => void];
                                    }];
                                };
                            };
                            readonly BufferedSpeaker: {
                                readonly type: "parallel";
                                readonly invoke: {
                                    readonly id: "createEventsFromStream";
                                    readonly src: "createEventsFromStream";
                                    readonly input: ({ context }: {
                                        context: import("./types").TTSContext;
                                        event: import("./types").TTSEvent;
                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                    }) => Agenda;
                                };
                                readonly on: {
                                    readonly STOP: {
                                        readonly target: "Idle";
                                    };
                                };
                                readonly states: {
                                    readonly Buffer: {
                                        readonly initial: "BufferIdle";
                                        readonly on: {
                                            readonly STREAMING_SET_VOICE: {
                                                readonly actions: "assignCurrentVoice";
                                            };
                                            readonly STREAMING_SET_LOCALE: {
                                                readonly actions: "assignCurrentLocale";
                                            };
                                            readonly STREAMING_SET_PERSONA: {
                                                readonly actions: "sendParentCurrentPersona";
                                            };
                                        };
                                        readonly states: {
                                            readonly BufferIdle: {
                                                readonly id: "BufferIdle";
                                                readonly on: {
                                                    readonly STREAMING_CHUNK: {
                                                        readonly target: "Buffering";
                                                    };
                                                    readonly STREAMING_DONE: "BufferingDone";
                                                };
                                            };
                                            readonly Buffering: {
                                                readonly id: "Buffering";
                                                readonly on: {
                                                    readonly STREAMING_CHUNK: {
                                                        readonly target: "Buffering";
                                                        readonly reenter: true;
                                                    };
                                                    readonly STREAMING_DONE: "BufferingDone";
                                                };
                                                readonly after: {
                                                    readonly STREAMING_TIMEOUT: {
                                                        readonly target: "BufferingDone";
                                                        readonly actions: () => void;
                                                    };
                                                };
                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>];
                                            };
                                            readonly BufferingDone: {
                                                readonly id: "BufferingDone";
                                                readonly type: "final";
                                            };
                                        };
                                    };
                                    readonly Speaker: {
                                        readonly initial: "SpeakingIdle";
                                        readonly states: {
                                            readonly SpeakingIdle: {
                                                readonly id: "SpeakingIdle";
                                                readonly always: readonly [{
                                                    readonly target: "Speak";
                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                }, {
                                                    readonly target: "PrepareSpeech";
                                                    readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                }];
                                                readonly after: {
                                                    readonly FILLER_DELAY: {
                                                        readonly target: "SpeakingIdle";
                                                        readonly reenter: true;
                                                        readonly actions: "addFiller";
                                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                    };
                                                };
                                            };
                                            readonly PrepareSpeech: {
                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>];
                                                readonly always: readonly [{
                                                    readonly target: "Speak";
                                                }];
                                            };
                                            readonly Speak: {
                                                readonly initial: "Init";
                                                readonly states: {
                                                    readonly Init: {
                                                        readonly always: readonly [{
                                                            readonly target: "CheckCache";
                                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                        }, {
                                                            readonly target: "Go";
                                                        }];
                                                    };
                                                    readonly CheckCache: {
                                                        readonly invoke: {
                                                            readonly src: "checkCache";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            };
                                                            readonly onError: "Go";
                                                            readonly onDone: readonly [{
                                                                readonly target: "UseCache";
                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                            }, {
                                                                readonly target: "Go";
                                                                readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                            }];
                                                        };
                                                    };
                                                    readonly UseCache: {
                                                        readonly initial: "GetAudio";
                                                        readonly states: {
                                                            readonly GetAudio: {
                                                                readonly invoke: {
                                                                    readonly src: "getAudioFromCache";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        audioContext: AudioContext;
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    };
                                                                    readonly onDone: {
                                                                        readonly target: "PlayAudio";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    };
                                                                    readonly onError: "#TtsStreamGo";
                                                                };
                                                            };
                                                            readonly PlayAudio: {
                                                                readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                readonly invoke: {
                                                                    readonly src: "playAudio";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        audioBuffer: AudioBuffer;
                                                                        audioContext: AudioContext;
                                                                    };
                                                                };
                                                                readonly on: {
                                                                    readonly CONTROL: "PausedAudio";
                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                        readonly target: "#SpeakingDone";
                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                            type: "SPEAK_COMPLETE";
                                                                        }, unknown, any>;
                                                                    }, {
                                                                        readonly target: "#SpeakingIdle";
                                                                    }];
                                                                    readonly TTS_STARTED: {
                                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "TTS_STARTED";
                                                                            value?: AudioBufferSourceNode;
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "TTS_STARTED";
                                                                            value?: AudioBufferSourceNode;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>];
                                                                    };
                                                                };
                                                                readonly exit: "ttsStop";
                                                            };
                                                            readonly PausedAudio: {
                                                                readonly on: {
                                                                    readonly CONTROL: "PlayAudio";
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly Go: {
                                                        readonly id: "TtsStreamGo";
                                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly invoke: {
                                                            readonly src: "start";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                wsaTTS: SpeechSynthesis;
                                                                wsaUtt: {
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                    prototype: SpeechSynthesisUtterance;
                                                                };
                                                                ttsLexicon: string;
                                                                visemes: boolean;
                                                                voice: string;
                                                                locale: string;
                                                                utterance: string;
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly CONTROL: "Paused";
                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                readonly target: "#SpeakingDone";
                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                    type: "SPEAK_COMPLETE";
                                                                }, unknown, any>;
                                                            }, {
                                                                readonly target: "#SpeakingIdle";
                                                            }];
                                                            readonly TTS_STARTED: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                    type: "TTS_STARTED";
                                                                    value?: AudioBufferSourceNode;
                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                            };
                                                        };
                                                        readonly exit: "ttsStop";
                                                    };
                                                    readonly Paused: {
                                                        readonly on: {
                                                            readonly CONTROL: "Go";
                                                        };
                                                    };
                                                };
                                            };
                                            readonly SpeakingDone: {
                                                readonly id: "SpeakingDone";
                                                readonly type: "final";
                                            };
                                        };
                                    };
                                };
                                readonly onDone: {
                                    readonly target: "Idle";
                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                };
                            };
                            readonly Playing: {
                                readonly on: {
                                    readonly SPEAK_COMPLETE: {
                                        readonly target: "Idle";
                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                            type: "SPEAK_COMPLETE";
                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                    };
                                    readonly TTS_STARTED: {
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                            type: "TTS_STARTED";
                                            value?: AudioBufferSourceNode;
                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                            type: "TTS_STARTED";
                                            value?: AudioBufferSourceNode;
                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            checkCache: {
                                                src: "checkCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudioFromCache: {
                                                src: "getAudioFromCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudio: {
                                                src: "getAudio";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            playAudio: {
                                                src: "playAudio";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    };
                                    readonly STOP: {
                                        readonly target: "Idle";
                                    };
                                };
                                readonly initial: "FetchAudio";
                                readonly states: {
                                    readonly FetchAudio: {
                                        readonly invoke: {
                                            readonly src: "getAudio";
                                            readonly input: ({ context }: {
                                                context: import("./types").TTSContext;
                                                event: import("./types").TTSEvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            };
                                            readonly onDone: {
                                                readonly target: "PlayAudio";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                            };
                                            readonly onError: {
                                                readonly target: "#Speaking";
                                            };
                                        };
                                    };
                                    readonly PlayAudio: {
                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                        readonly invoke: {
                                            readonly src: "playAudio";
                                            readonly input: ({ context }: {
                                                context: import("./types").TTSContext;
                                                event: import("./types").TTSEvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            };
                                        };
                                        readonly on: {
                                            readonly CONTROL: "AudioPaused";
                                        };
                                        readonly exit: "ttsStop";
                                    };
                                    readonly AudioPaused: {
                                        readonly on: {
                                            readonly CONTROL: "PlayAudio";
                                        };
                                    };
                                };
                            };
                            readonly Speaking: {
                                readonly id: "Speaking";
                                readonly initial: "Go";
                                readonly on: {
                                    readonly STOP: {
                                        readonly target: "Idle";
                                    };
                                    readonly TTS_STARTED: {
                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                            type: "TTS_STARTED";
                                            value?: AudioBufferSourceNode;
                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                    };
                                    readonly VISEME: {
                                        readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                            type: "VISEME";
                                            value: any;
                                        }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                    };
                                    readonly SPEAK_COMPLETE: {
                                        readonly target: "Idle";
                                    };
                                };
                                readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                readonly states: {
                                    readonly Go: {
                                        readonly invoke: {
                                            readonly src: "start";
                                            readonly input: ({ context }: {
                                                context: import("./types").TTSContext;
                                                event: import("./types").TTSEvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                wsaTTS: SpeechSynthesis;
                                                wsaUtt: {
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                    prototype: SpeechSynthesisUtterance;
                                                };
                                                ttsLexicon: string;
                                                voice: string;
                                                visemes: boolean;
                                                locale: string;
                                                utterance: string;
                                            };
                                        };
                                        readonly on: {
                                            readonly CONTROL: "Paused";
                                        };
                                        readonly exit: "ttsStop";
                                    };
                                    readonly Paused: {
                                        readonly on: {
                                            readonly SPEAK_COMPLETE: {};
                                            readonly CONTROL: "Go";
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
            readonly MaybeHandleNewTokens: {
                readonly initial: "Choice";
                readonly states: {
                    readonly Choice: {
                        readonly always: readonly [{
                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                            readonly target: "Ponyfill";
                        }, {
                            readonly target: "NoPonyfill";
                        }];
                    };
                    readonly NoPonyfill: {
                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                            checkCache: {
                                src: "checkCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                            getAudioFromCache: {
                                src: "getAudioFromCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                            getAudio: {
                                src: "getAudio";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    audioURL: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                            playAudio: {
                                src: "playAudio";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                    audioContext: AudioContext;
                                    audioBuffer: AudioBuffer;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                            createEventsFromStream: {
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                id: string;
                            };
                            ponyfill: {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            };
                            start: {
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<null, {
                                    utterance: string;
                                    voice: string;
                                    ttsLexicon: string;
                                    locale: string;
                                    wsaUtt: {
                                        prototype: SpeechSynthesisUtterance;
                                        new (text?: string): SpeechSynthesisUtterance;
                                    };
                                    wsaTTS: SpeechSynthesis;
                                    visemes?: boolean;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                        }>, never, never, never, never>];
                    };
                    readonly Ponyfill: {
                        readonly invoke: {
                            readonly id: "ponyTTS";
                            readonly src: "ponyfill";
                            readonly input: ({ context }: {
                                context: import("./types").TTSContext;
                                event: import("./types").TTSEvent;
                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                            }) => {
                                azureAuthorizationToken: string;
                                azureRegion: string;
                                audioContext: AudioContext;
                            };
                        };
                        readonly on: {
                            readonly READY: {
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "READY";
                                    value: {
                                        wsaTTS: SpeechSynthesis;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                    };
                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                    checkCache: {
                                        src: "checkCache";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            cacheURL: string;
                                            utterance: string;
                                            voice: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    getAudioFromCache: {
                                        src: "getAudioFromCache";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            audioContext: AudioContext;
                                            cacheURL: string;
                                            utterance: string;
                                            voice: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    getAudio: {
                                        src: "getAudio";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            audioContext: AudioContext;
                                            audioURL: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    playAudio: {
                                        src: "playAudio";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                            audioContext: AudioContext;
                                            audioBuffer: AudioBuffer;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<null, {
                                            utterance: string;
                                            voice: string;
                                            ttsLexicon: string;
                                            locale: string;
                                            wsaUtt: {
                                                prototype: SpeechSynthesisUtterance;
                                                new (text?: string): SpeechSynthesisUtterance;
                                            };
                                            wsaTTS: SpeechSynthesis;
                                            visemes?: boolean;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>;
                            };
                            readonly NEW_TOKEN: {
                                readonly target: "Ponyfill";
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "NEW_TOKEN";
                                    value: string;
                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                    checkCache: {
                                        src: "checkCache";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            cacheURL: string;
                                            utterance: string;
                                            voice: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    getAudioFromCache: {
                                        src: "getAudioFromCache";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            audioContext: AudioContext;
                                            cacheURL: string;
                                            utterance: string;
                                            voice: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    getAudio: {
                                        src: "getAudio";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            audioContext: AudioContext;
                                            audioURL: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    playAudio: {
                                        src: "playAudio";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                            audioContext: AudioContext;
                                            audioBuffer: AudioBuffer;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<null, {
                                            utterance: string;
                                            voice: string;
                                            ttsLexicon: string;
                                            locale: string;
                                            wsaUtt: {
                                                prototype: SpeechSynthesisUtterance;
                                                new (text?: string): SpeechSynthesisUtterance;
                                            };
                                            wsaTTS: SpeechSynthesis;
                                            visemes?: boolean;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>;
                                readonly reenter: true;
                            };
                        };
                    };
                };
            };
        };
    }>> | import("xstate").ActorRefFromLogic<import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
            query: string;
            locale: string;
        }, import("xstate").EventObject>>;
    }, import("xstate").Values<{
        maybe_ponyfill: {
            src: "maybe_ponyfill";
            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
            id: string;
        };
        nluPromise: {
            src: "nluPromise";
            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                query: string;
                locale: string;
            }, import("xstate").EventObject>;
            id: string;
        };
    }>, import("xstate").Values<{
        raise_noinput_after_timeout: {
            type: "raise_noinput_after_timeout";
            params: {};
        };
        cancel_noinput_timeout: {
            type: "cancel_noinput_timeout";
            params: {};
        };
    }>, {
        type: "nlu_is_activated";
        params: unknown;
    }, "noinputTimeout", "Ready" | "Fail" | {
        Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
            Pausing: "Paused" | "WaitToPause" | "Continue";
        };
    }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
        readonly id: "asr";
        readonly context: ({ input }: {
            spawn: {
                <TSrc extends "maybe_ponyfill" | "nluPromise">(logic: TSrc, ...[options]: ({
                    src: "maybe_ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                    id: string;
                } extends infer T ? T extends {
                    src: "maybe_ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                    id: string;
                } ? T extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                    src: "nluPromise";
                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                        query: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } extends infer T_1 ? T_1 extends {
                    src: "nluPromise";
                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                        query: string;
                        locale: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } ? T_1 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_1["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_1["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                    maybe_ponyfill: {
                        src: "maybe_ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    nluPromise: {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, "src", TSrc>["logic"]>;
                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                    id?: never;
                    systemId?: string;
                    input?: import("xstate").InputFrom<TLogic>;
                    syncSnapshot?: boolean;
                }): import("xstate").ActorRefFromLogic<TLogic>;
            };
            input: import("./types").ASRInit;
            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
        }) => {
            azureAuthorizationToken: string;
            asrDefaultCompleteTimeout: number;
            asrDefaultNoInputTimeout: number;
            locale: string;
            audioContext: AudioContext;
            azureRegion: string;
            azureLanguageCredentials: import("./types").AzureLanguageCredentials;
            speechRecognitionEndpointId: string;
        };
        readonly initial: "Ready";
        readonly on: {
            readonly NEW_TOKEN: {
                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                    type: "NEW_TOKEN";
                    value: string;
                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                    maybe_ponyfill: {
                        src: "maybe_ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    nluPromise: {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, never, never, never, never>;
            };
        };
        readonly states: {
            readonly Fail: {};
            readonly Ready: {
                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                readonly on: {
                    readonly START: {
                        readonly target: "Recognising";
                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                            type: "START";
                            value?: RecogniseParameters;
                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                            maybe_ponyfill: {
                                src: "maybe_ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            };
                            nluPromise: {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                        }>, never, never, never, never>;
                    };
                };
            };
            readonly Recognising: {
                readonly onDone: "Ready";
                readonly invoke: {
                    readonly id: "asr";
                    readonly src: "maybe_ponyfill";
                    readonly input: ({ context }: {
                        context: import("./types").ASRContext;
                        event: import("./types").ASREvent;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                    }) => {
                        azureRegion: string;
                        audioContext: AudioContext;
                        azureAuthorizationToken: string;
                        locale: string;
                        speechRecognitionEndpointId: string;
                        completeTimeout: number;
                        hints: string[];
                    };
                };
                readonly on: {
                    readonly FINAL_RESULT: readonly [{
                        readonly target: ".NLURequest";
                        readonly guard: {
                            readonly type: "nlu_is_activated";
                        };
                    }, {
                        readonly target: ".WaitToStop";
                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                            type: "FINAL_RESULT";
                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                    }];
                    readonly RESULT: {
                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                            type: "RESULT";
                            value: Hypothesis[];
                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                            maybe_ponyfill: {
                                src: "maybe_ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            };
                            nluPromise: {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                        }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                            type: "RESULT";
                            value: Hypothesis[];
                        }, undefined, import("./types").ASREvent>];
                        readonly target: ".InterimResult";
                    };
                    readonly STOP: {
                        readonly target: ".WaitToStop";
                    };
                    readonly CONTROL: {
                        readonly target: ".Pausing";
                    };
                    readonly NOINPUT: {
                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                            type: "NOINPUT";
                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                        readonly target: ".WaitToStop";
                    };
                };
                readonly initial: "WaitForRecogniser";
                readonly states: {
                    readonly WaitForRecogniser: {
                        readonly on: {
                            readonly STARTED: {
                                readonly target: "NoInput";
                                readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "STARTED";
                                    value: {
                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                    };
                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                            };
                        };
                    };
                    readonly NoInput: {
                        readonly entry: {
                            readonly type: "raise_noinput_after_timeout";
                        };
                        readonly on: {
                            readonly STARTSPEECH: {
                                readonly target: "InProgress";
                                readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                    type: "STARTSPEECH";
                                }, undefined, import("./types").ASREvent>;
                            };
                        };
                        readonly exit: {
                            readonly type: "cancel_noinput_timeout";
                        };
                    };
                    readonly InProgress: {
                        readonly entry: () => void;
                    };
                    readonly InterimResult: {
                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                    };
                    readonly WaitToStop: {
                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                        readonly on: {
                            readonly LISTEN_COMPLETE: {
                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "LISTEN_COMPLETE";
                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                readonly target: "Stopped";
                            };
                        };
                    };
                    readonly Pausing: {
                        readonly onDone: "#asr.Recognising";
                        readonly initial: "WaitToPause";
                        readonly states: {
                            readonly WaitToPause: {
                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                readonly on: {
                                    readonly LISTEN_COMPLETE: {
                                        readonly target: "Paused";
                                    };
                                };
                            };
                            readonly Paused: {
                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                readonly on: {
                                    readonly CONTROL: {
                                        readonly target: "Continue";
                                    };
                                };
                            };
                            readonly Continue: {
                                readonly type: "final";
                            };
                        };
                    };
                    readonly NLURequest: {
                        readonly invoke: {
                            readonly src: "nluPromise";
                            readonly input: ({ context }: {
                                context: import("./types").ASRContext;
                                event: import("./types").ASREvent;
                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                            }) => {
                                endpoint: string;
                                key: string;
                                projectName: string;
                                deploymentName: string;
                                query: string;
                                locale: string;
                            };
                            readonly onDone: readonly [{
                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                readonly target: "WaitToStop";
                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                            }, {
                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                readonly target: "WaitToStop";
                            }];
                            readonly onError: {
                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                readonly target: "WaitToStop";
                            };
                        };
                    };
                    readonly Stopped: {
                        readonly type: "final";
                    };
                };
            };
        };
    }>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").StateMachine<{
        queue: number[];
    }, {
        type: "VISEME";
        value: any;
    }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
        readonly context: {
            readonly queue: [];
        };
        readonly initial: "Init";
        readonly states: {
            readonly Init: {
                readonly on: {
                    readonly VISEME: readonly [{
                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                            queue: number[];
                        }, {
                            type: "VISEME";
                            value: any;
                        }>) => boolean;
                        readonly actions: readonly [import("xstate").ActionFunction<{
                            queue: number[];
                        }, {
                            type: "VISEME";
                            value: any;
                        }, {
                            type: "VISEME";
                            value: any;
                        }, undefined, never, never, never, never, never>];
                    }];
                };
            };
        };
    }>>;
}, import("xstate").Values<{
    audioContext: {
        src: "audioContext";
        logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
        id: string;
    };
    tts: {
        src: "tts";
        logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
            [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                cacheURL: string;
                utterance: string;
                voice: string;
                locale: string;
            }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                audioContext: AudioContext;
                cacheURL: string;
                utterance: string;
                voice: string;
                locale: string;
            }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                audioContext: AudioContext;
                audioURL: string;
            }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                audioContext: AudioContext;
                audioBuffer: AudioBuffer;
            }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                utterance: string;
                voice: string;
                ttsLexicon: string;
                locale: string;
                wsaUtt: {
                    prototype: SpeechSynthesisUtterance;
                    new (text?: string): SpeechSynthesisUtterance;
                };
                wsaTTS: SpeechSynthesis;
                visemes?: boolean;
            }, import("xstate").EventObject>>;
        }, import("xstate").Values<{
            checkCache: {
                src: "checkCache";
                logic: import("xstate").PromiseActorLogic<any, {
                    cacheURL: string;
                    utterance: string;
                    voice: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            };
            getAudioFromCache: {
                src: "getAudioFromCache";
                logic: import("xstate").PromiseActorLogic<any, {
                    audioContext: AudioContext;
                    cacheURL: string;
                    utterance: string;
                    voice: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            };
            getAudio: {
                src: "getAudio";
                logic: import("xstate").PromiseActorLogic<any, {
                    audioContext: AudioContext;
                    audioURL: string;
                }, import("xstate").EventObject>;
                id: string;
            };
            playAudio: {
                src: "playAudio";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                    audioContext: AudioContext;
                    audioBuffer: AudioBuffer;
                }, import("xstate").EventObject>;
                id: string;
            };
            createEventsFromStream: {
                src: "createEventsFromStream";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                id: string;
            };
            ponyfill: {
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                id: string;
            };
            start: {
                src: "start";
                logic: import("xstate").CallbackActorLogic<null, {
                    utterance: string;
                    voice: string;
                    ttsLexicon: string;
                    locale: string;
                    wsaUtt: {
                        prototype: SpeechSynthesisUtterance;
                        new (text?: string): SpeechSynthesisUtterance;
                    };
                    wsaTTS: SpeechSynthesis;
                    visemes?: boolean;
                }, import("xstate").EventObject>;
                id: string;
            };
        }>, import("xstate").Values<{
            ttsStop: {
                type: "ttsStop";
                params: unknown;
            };
            addFiller: {
                type: "addFiller";
                params: {};
            };
            assignCurrentVoice: {
                type: "assignCurrentVoice";
                params: {};
            };
            assignCurrentLocale: {
                type: "assignCurrentLocale";
                params: {};
            };
            sendParentCurrentPersona: {
                type: "sendParentCurrentPersona";
                params: {};
            };
        }>, import("xstate").Values<{
            bufferContainsUtterancePartReadyToBeSpoken: {
                type: "bufferContainsUtterancePartReadyToBeSpoken";
                params: unknown;
            };
            bufferIsNonEmpty: {
                type: "bufferIsNonEmpty";
                params: unknown;
            };
        }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
            Operation: "NotReady" | {
                Ready: "Idle" | {
                    BufferedSpeaker: {
                        Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                        Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                            Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                            };
                        };
                    };
                } | {
                    Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                } | {
                    Speaking: "Go" | "Paused";
                };
            };
            MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
        }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
            readonly id: "tts";
            readonly context: ({ input }: {
                spawn: {
                    <TSrc extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                        src: "checkCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } extends infer T ? T extends {
                        src: "checkCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } ? T extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                        src: "getAudioFromCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_1 ? T_1 extends {
                        src: "getAudioFromCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } ? T_1 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_1["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_1["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                        src: "getAudio";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            audioURL: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_2 ? T_2 extends {
                        src: "getAudio";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            audioURL: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } ? T_2 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_2["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_2["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                        src: "playAudio";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                            audioContext: AudioContext;
                            audioBuffer: AudioBuffer;
                        }, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_3 ? T_3 extends {
                        src: "playAudio";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                            audioContext: AudioContext;
                            audioBuffer: AudioBuffer;
                        }, import("xstate").EventObject>;
                        id: string;
                    } ? T_3 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_3["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_3["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_4 ? T_4 extends {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                        id: string;
                    } ? T_4 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_4["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_4["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_5 ? T_5 extends {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    } ? T_5 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_5["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_5["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<null, {
                            utterance: string;
                            voice: string;
                            ttsLexicon: string;
                            locale: string;
                            wsaUtt: {
                                prototype: SpeechSynthesisUtterance;
                                new (text?: string): SpeechSynthesisUtterance;
                            };
                            wsaTTS: SpeechSynthesis;
                            visemes?: boolean;
                        }, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_6 ? T_6 extends {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<null, {
                            utterance: string;
                            voice: string;
                            ttsLexicon: string;
                            locale: string;
                            wsaUtt: {
                                prototype: SpeechSynthesisUtterance;
                                new (text?: string): SpeechSynthesisUtterance;
                            };
                            wsaTTS: SpeechSynthesis;
                            visemes?: boolean;
                        }, import("xstate").EventObject>;
                        id: string;
                    } ? T_6 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_6["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_6["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                        checkCache: {
                            src: "checkCache";
                            logic: import("xstate").PromiseActorLogic<any, {
                                cacheURL: string;
                                utterance: string;
                                voice: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        getAudioFromCache: {
                            src: "getAudioFromCache";
                            logic: import("xstate").PromiseActorLogic<any, {
                                audioContext: AudioContext;
                                cacheURL: string;
                                utterance: string;
                                voice: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        getAudio: {
                            src: "getAudio";
                            logic: import("xstate").PromiseActorLogic<any, {
                                audioContext: AudioContext;
                                audioURL: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        playAudio: {
                            src: "playAudio";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                audioContext: AudioContext;
                                audioBuffer: AudioBuffer;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<null, {
                                utterance: string;
                                voice: string;
                                ttsLexicon: string;
                                locale: string;
                                wsaUtt: {
                                    prototype: SpeechSynthesisUtterance;
                                    new (text?: string): SpeechSynthesisUtterance;
                                };
                                wsaTTS: SpeechSynthesis;
                                visemes?: boolean;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, "src", TSrc>["logic"]>;
                    <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                        id?: never;
                        systemId?: string;
                        input?: import("xstate").InputFrom<TLogic>;
                        syncSnapshot?: boolean;
                    }): import("xstate").ActorRefFromLogic<TLogic>;
                };
                input: import("./types").TTSInit;
                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
            }) => {
                azureAuthorizationToken: string;
                ttsDefaultVoice: string;
                ttsDefaultFillerDelay: number;
                ttsDefaultFiller: string;
                ttsLexicon: string;
                audioContext: AudioContext;
                azureRegion: string;
                locale: string;
                buffer: string;
            };
            readonly on: {
                readonly ERROR: {
                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                        type: "ERROR";
                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                };
            };
            readonly type: "parallel";
            readonly states: {
                readonly Operation: {
                    readonly initial: "NotReady";
                    readonly states: {
                        readonly NotReady: {
                            readonly on: {
                                readonly READY: {
                                    readonly target: "Ready";
                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                        type: "READY";
                                        value: {
                                            wsaTTS: SpeechSynthesis;
                                            wsaUtt: {
                                                prototype: SpeechSynthesisUtterance;
                                                new (text?: string): SpeechSynthesisUtterance;
                                            };
                                        };
                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                };
                            };
                        };
                        readonly Ready: {
                            readonly initial: "Idle";
                            readonly states: {
                                readonly Idle: {
                                    readonly id: "Idle";
                                    readonly on: {
                                        readonly SPEAK: readonly [{
                                            readonly target: "BufferedSpeaker";
                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: Agenda;
                                            }>) => boolean;
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: Agenda;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        }, {
                                            readonly target: "Playing";
                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: Agenda;
                                            }>) => boolean;
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: Agenda;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        }, {
                                            readonly target: "Speaking";
                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: Agenda;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: Agenda;
                                            }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: Agenda;
                                            }, import("./types").TTSEvent>) => void];
                                        }];
                                    };
                                };
                                readonly BufferedSpeaker: {
                                    readonly type: "parallel";
                                    readonly invoke: {
                                        readonly id: "createEventsFromStream";
                                        readonly src: "createEventsFromStream";
                                        readonly input: ({ context }: {
                                            context: import("./types").TTSContext;
                                            event: import("./types").TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                        }) => Agenda;
                                    };
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "Idle";
                                        };
                                    };
                                    readonly states: {
                                        readonly Buffer: {
                                            readonly initial: "BufferIdle";
                                            readonly on: {
                                                readonly STREAMING_SET_VOICE: {
                                                    readonly actions: "assignCurrentVoice";
                                                };
                                                readonly STREAMING_SET_LOCALE: {
                                                    readonly actions: "assignCurrentLocale";
                                                };
                                                readonly STREAMING_SET_PERSONA: {
                                                    readonly actions: "sendParentCurrentPersona";
                                                };
                                            };
                                            readonly states: {
                                                readonly BufferIdle: {
                                                    readonly id: "BufferIdle";
                                                    readonly on: {
                                                        readonly STREAMING_CHUNK: {
                                                            readonly target: "Buffering";
                                                        };
                                                        readonly STREAMING_DONE: "BufferingDone";
                                                    };
                                                };
                                                readonly Buffering: {
                                                    readonly id: "Buffering";
                                                    readonly on: {
                                                        readonly STREAMING_CHUNK: {
                                                            readonly target: "Buffering";
                                                            readonly reenter: true;
                                                        };
                                                        readonly STREAMING_DONE: "BufferingDone";
                                                    };
                                                    readonly after: {
                                                        readonly STREAMING_TIMEOUT: {
                                                            readonly target: "BufferingDone";
                                                            readonly actions: () => void;
                                                        };
                                                    };
                                                    readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                };
                                                readonly BufferingDone: {
                                                    readonly id: "BufferingDone";
                                                    readonly type: "final";
                                                };
                                            };
                                        };
                                        readonly Speaker: {
                                            readonly initial: "SpeakingIdle";
                                            readonly states: {
                                                readonly SpeakingIdle: {
                                                    readonly id: "SpeakingIdle";
                                                    readonly always: readonly [{
                                                        readonly target: "Speak";
                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                    }, {
                                                        readonly target: "PrepareSpeech";
                                                        readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    }];
                                                    readonly after: {
                                                        readonly FILLER_DELAY: {
                                                            readonly target: "SpeakingIdle";
                                                            readonly reenter: true;
                                                            readonly actions: "addFiller";
                                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                        };
                                                    };
                                                };
                                                readonly PrepareSpeech: {
                                                    readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                    readonly always: readonly [{
                                                        readonly target: "Speak";
                                                    }];
                                                };
                                                readonly Speak: {
                                                    readonly initial: "Init";
                                                    readonly states: {
                                                        readonly Init: {
                                                            readonly always: readonly [{
                                                                readonly target: "CheckCache";
                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                            }, {
                                                                readonly target: "Go";
                                                            }];
                                                        };
                                                        readonly CheckCache: {
                                                            readonly invoke: {
                                                                readonly src: "checkCache";
                                                                readonly input: ({ context }: {
                                                                    context: import("./types").TTSContext;
                                                                    event: import("./types").TTSEvent;
                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                }) => {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                };
                                                                readonly onError: "Go";
                                                                readonly onDone: readonly [{
                                                                    readonly target: "UseCache";
                                                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                    readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                }, {
                                                                    readonly target: "Go";
                                                                    readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                }];
                                                            };
                                                        };
                                                        readonly UseCache: {
                                                            readonly initial: "GetAudio";
                                                            readonly states: {
                                                                readonly GetAudio: {
                                                                    readonly invoke: {
                                                                        readonly src: "getAudioFromCache";
                                                                        readonly input: ({ context }: {
                                                                            context: import("./types").TTSContext;
                                                                            event: import("./types").TTSEvent;
                                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                        }) => {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        };
                                                                        readonly onDone: {
                                                                            readonly target: "PlayAudio";
                                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                checkCache: {
                                                                                    src: "checkCache";
                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                        cacheURL: string;
                                                                                        utterance: string;
                                                                                        voice: string;
                                                                                        locale: string;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                getAudioFromCache: {
                                                                                    src: "getAudioFromCache";
                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                        audioContext: AudioContext;
                                                                                        cacheURL: string;
                                                                                        utterance: string;
                                                                                        voice: string;
                                                                                        locale: string;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                getAudio: {
                                                                                    src: "getAudio";
                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                        audioContext: AudioContext;
                                                                                        audioURL: string;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                playAudio: {
                                                                                    src: "playAudio";
                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                        audioContext: AudioContext;
                                                                                        audioBuffer: AudioBuffer;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                createEventsFromStream: {
                                                                                    src: "createEventsFromStream";
                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                ponyfill: {
                                                                                    src: "ponyfill";
                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                start: {
                                                                                    src: "start";
                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                        utterance: string;
                                                                                        voice: string;
                                                                                        ttsLexicon: string;
                                                                                        locale: string;
                                                                                        wsaUtt: {
                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                        };
                                                                                        wsaTTS: SpeechSynthesis;
                                                                                        visemes?: boolean;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                            }>, never, never, never, never>;
                                                                        };
                                                                        readonly onError: "#TtsStreamGo";
                                                                    };
                                                                };
                                                                readonly PlayAudio: {
                                                                    readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                    readonly invoke: {
                                                                        readonly src: "playAudio";
                                                                        readonly input: ({ context }: {
                                                                            context: import("./types").TTSContext;
                                                                            event: import("./types").TTSEvent;
                                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                        }) => {
                                                                            audioBuffer: AudioBuffer;
                                                                            audioContext: AudioContext;
                                                                        };
                                                                    };
                                                                    readonly on: {
                                                                        readonly CONTROL: "PausedAudio";
                                                                        readonly SPEAK_COMPLETE: readonly [{
                                                                            readonly target: "#SpeakingDone";
                                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                type: "SPEAK_COMPLETE";
                                                                            }, unknown, any>;
                                                                        }, {
                                                                            readonly target: "#SpeakingIdle";
                                                                        }];
                                                                        readonly TTS_STARTED: {
                                                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                type: "TTS_STARTED";
                                                                                value?: AudioBufferSourceNode;
                                                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                type: "TTS_STARTED";
                                                                                value?: AudioBufferSourceNode;
                                                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                checkCache: {
                                                                                    src: "checkCache";
                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                        cacheURL: string;
                                                                                        utterance: string;
                                                                                        voice: string;
                                                                                        locale: string;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                getAudioFromCache: {
                                                                                    src: "getAudioFromCache";
                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                        audioContext: AudioContext;
                                                                                        cacheURL: string;
                                                                                        utterance: string;
                                                                                        voice: string;
                                                                                        locale: string;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                getAudio: {
                                                                                    src: "getAudio";
                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                        audioContext: AudioContext;
                                                                                        audioURL: string;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                playAudio: {
                                                                                    src: "playAudio";
                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                        audioContext: AudioContext;
                                                                                        audioBuffer: AudioBuffer;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                createEventsFromStream: {
                                                                                    src: "createEventsFromStream";
                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                ponyfill: {
                                                                                    src: "ponyfill";
                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                                start: {
                                                                                    src: "start";
                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                        utterance: string;
                                                                                        voice: string;
                                                                                        ttsLexicon: string;
                                                                                        locale: string;
                                                                                        wsaUtt: {
                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                        };
                                                                                        wsaTTS: SpeechSynthesis;
                                                                                        visemes?: boolean;
                                                                                    }, import("xstate").EventObject>;
                                                                                    id: string;
                                                                                };
                                                                            }>, never, never, never, never>];
                                                                        };
                                                                    };
                                                                    readonly exit: "ttsStop";
                                                                };
                                                                readonly PausedAudio: {
                                                                    readonly on: {
                                                                        readonly CONTROL: "PlayAudio";
                                                                    };
                                                                };
                                                            };
                                                        };
                                                        readonly Go: {
                                                            readonly id: "TtsStreamGo";
                                                            readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                            readonly invoke: {
                                                                readonly src: "start";
                                                                readonly input: ({ context }: {
                                                                    context: import("./types").TTSContext;
                                                                    event: import("./types").TTSEvent;
                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                }) => {
                                                                    wsaTTS: SpeechSynthesis;
                                                                    wsaUtt: {
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                        prototype: SpeechSynthesisUtterance;
                                                                    };
                                                                    ttsLexicon: string;
                                                                    visemes: boolean;
                                                                    voice: string;
                                                                    locale: string;
                                                                    utterance: string;
                                                                };
                                                            };
                                                            readonly on: {
                                                                readonly CONTROL: "Paused";
                                                                readonly SPEAK_COMPLETE: readonly [{
                                                                    readonly target: "#SpeakingDone";
                                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                        type: "SPEAK_COMPLETE";
                                                                    }, unknown, any>;
                                                                }, {
                                                                    readonly target: "#SpeakingIdle";
                                                                }];
                                                                readonly TTS_STARTED: {
                                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                        type: "TTS_STARTED";
                                                                        value?: AudioBufferSourceNode;
                                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                };
                                                            };
                                                            readonly exit: "ttsStop";
                                                        };
                                                        readonly Paused: {
                                                            readonly on: {
                                                                readonly CONTROL: "Go";
                                                            };
                                                        };
                                                    };
                                                };
                                                readonly SpeakingDone: {
                                                    readonly id: "SpeakingDone";
                                                    readonly type: "final";
                                                };
                                            };
                                        };
                                    };
                                    readonly onDone: {
                                        readonly target: "Idle";
                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                    };
                                };
                                readonly Playing: {
                                    readonly on: {
                                        readonly SPEAK_COMPLETE: {
                                            readonly target: "Idle";
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK_COMPLETE";
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                        };
                                        readonly TTS_STARTED: {
                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "TTS_STARTED";
                                                value?: AudioBufferSourceNode;
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "TTS_STARTED";
                                                value?: AudioBufferSourceNode;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>];
                                        };
                                        readonly STOP: {
                                            readonly target: "Idle";
                                        };
                                    };
                                    readonly initial: "FetchAudio";
                                    readonly states: {
                                        readonly FetchAudio: {
                                            readonly invoke: {
                                                readonly src: "getAudio";
                                                readonly input: ({ context }: {
                                                    context: import("./types").TTSContext;
                                                    event: import("./types").TTSEvent;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                };
                                                readonly onDone: {
                                                    readonly target: "PlayAudio";
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>;
                                                };
                                                readonly onError: {
                                                    readonly target: "#Speaking";
                                                };
                                            };
                                        };
                                        readonly PlayAudio: {
                                            readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                            readonly invoke: {
                                                readonly src: "playAudio";
                                                readonly input: ({ context }: {
                                                    context: import("./types").TTSContext;
                                                    event: import("./types").TTSEvent;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                };
                                            };
                                            readonly on: {
                                                readonly CONTROL: "AudioPaused";
                                            };
                                            readonly exit: "ttsStop";
                                        };
                                        readonly AudioPaused: {
                                            readonly on: {
                                                readonly CONTROL: "PlayAudio";
                                            };
                                        };
                                    };
                                };
                                readonly Speaking: {
                                    readonly id: "Speaking";
                                    readonly initial: "Go";
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "Idle";
                                        };
                                        readonly TTS_STARTED: {
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "TTS_STARTED";
                                                value?: AudioBufferSourceNode;
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                        };
                                        readonly VISEME: {
                                            readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                type: "VISEME";
                                                value: any;
                                            }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                        };
                                        readonly SPEAK_COMPLETE: {
                                            readonly target: "Idle";
                                        };
                                    };
                                    readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                    readonly states: {
                                        readonly Go: {
                                            readonly invoke: {
                                                readonly src: "start";
                                                readonly input: ({ context }: {
                                                    context: import("./types").TTSContext;
                                                    event: import("./types").TTSEvent;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    wsaTTS: SpeechSynthesis;
                                                    wsaUtt: {
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                        prototype: SpeechSynthesisUtterance;
                                                    };
                                                    ttsLexicon: string;
                                                    voice: string;
                                                    visemes: boolean;
                                                    locale: string;
                                                    utterance: string;
                                                };
                                            };
                                            readonly on: {
                                                readonly CONTROL: "Paused";
                                            };
                                            readonly exit: "ttsStop";
                                        };
                                        readonly Paused: {
                                            readonly on: {
                                                readonly SPEAK_COMPLETE: {};
                                                readonly CONTROL: "Go";
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
                readonly MaybeHandleNewTokens: {
                    readonly initial: "Choice";
                    readonly states: {
                        readonly Choice: {
                            readonly always: readonly [{
                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                readonly target: "Ponyfill";
                            }, {
                                readonly target: "NoPonyfill";
                            }];
                        };
                        readonly NoPonyfill: {
                            readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                checkCache: {
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudioFromCache: {
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudio: {
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                playAudio: {
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>];
                        };
                        readonly Ponyfill: {
                            readonly invoke: {
                                readonly id: "ponyTTS";
                                readonly src: "ponyfill";
                                readonly input: ({ context }: {
                                    context: import("./types").TTSContext;
                                    event: import("./types").TTSEvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                }) => {
                                    azureAuthorizationToken: string;
                                    azureRegion: string;
                                    audioContext: AudioContext;
                                };
                            };
                            readonly on: {
                                readonly READY: {
                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                        type: "READY";
                                        value: {
                                            wsaTTS: SpeechSynthesis;
                                            wsaUtt: {
                                                prototype: SpeechSynthesisUtterance;
                                                new (text?: string): SpeechSynthesisUtterance;
                                            };
                                        };
                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                        checkCache: {
                                            src: "checkCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudioFromCache: {
                                            src: "getAudioFromCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudio: {
                                            src: "getAudio";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        playAudio: {
                                            src: "playAudio";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<null, {
                                                utterance: string;
                                                voice: string;
                                                ttsLexicon: string;
                                                locale: string;
                                                wsaUtt: {
                                                    prototype: SpeechSynthesisUtterance;
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                };
                                                wsaTTS: SpeechSynthesis;
                                                visemes?: boolean;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                };
                                readonly NEW_TOKEN: {
                                    readonly target: "Ponyfill";
                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                        type: "NEW_TOKEN";
                                        value: string;
                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                        checkCache: {
                                            src: "checkCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudioFromCache: {
                                            src: "getAudioFromCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudio: {
                                            src: "getAudio";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        playAudio: {
                                            src: "playAudio";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<null, {
                                                utterance: string;
                                                voice: string;
                                                ttsLexicon: string;
                                                locale: string;
                                                wsaUtt: {
                                                    prototype: SpeechSynthesisUtterance;
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                };
                                                wsaTTS: SpeechSynthesis;
                                                visemes?: boolean;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                    readonly reenter: true;
                                };
                            };
                        };
                    };
                };
            };
        }>;
        id: string;
    };
    asr: {
        src: "asr";
        logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
            [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                query: string;
                locale: string;
            }, import("xstate").EventObject>>;
        }, import("xstate").Values<{
            maybe_ponyfill: {
                src: "maybe_ponyfill";
                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                id: string;
            };
            nluPromise: {
                src: "nluPromise";
                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                    query: string;
                    locale: string;
                }, import("xstate").EventObject>;
                id: string;
            };
        }>, import("xstate").Values<{
            raise_noinput_after_timeout: {
                type: "raise_noinput_after_timeout";
                params: {};
            };
            cancel_noinput_timeout: {
                type: "cancel_noinput_timeout";
                params: {};
            };
        }>, {
            type: "nlu_is_activated";
            params: unknown;
        }, "noinputTimeout", "Ready" | "Fail" | {
            Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                Pausing: "Paused" | "WaitToPause" | "Continue";
            };
        }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
            readonly id: "asr";
            readonly context: ({ input }: {
                spawn: {
                    <TSrc extends "maybe_ponyfill" | "nluPromise">(logic: TSrc, ...[options]: ({
                        src: "maybe_ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    } extends infer T ? T extends {
                        src: "maybe_ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    } ? T extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_1 ? T_1 extends {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } ? T_1 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_1["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_1["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                        maybe_ponyfill: {
                            src: "maybe_ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                query: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, "src", TSrc>["logic"]>;
                    <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                        id?: never;
                        systemId?: string;
                        input?: import("xstate").InputFrom<TLogic>;
                        syncSnapshot?: boolean;
                    }): import("xstate").ActorRefFromLogic<TLogic>;
                };
                input: import("./types").ASRInit;
                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
            }) => {
                azureAuthorizationToken: string;
                asrDefaultCompleteTimeout: number;
                asrDefaultNoInputTimeout: number;
                locale: string;
                audioContext: AudioContext;
                azureRegion: string;
                azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                speechRecognitionEndpointId: string;
            };
            readonly initial: "Ready";
            readonly on: {
                readonly NEW_TOKEN: {
                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                        type: "NEW_TOKEN";
                        value: string;
                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                        maybe_ponyfill: {
                            src: "maybe_ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                query: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>;
                };
            };
            readonly states: {
                readonly Fail: {};
                readonly Ready: {
                    readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                    readonly on: {
                        readonly START: {
                            readonly target: "Recognising";
                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "START";
                                value?: RecogniseParameters;
                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                maybe_ponyfill: {
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>;
                        };
                    };
                };
                readonly Recognising: {
                    readonly onDone: "Ready";
                    readonly invoke: {
                        readonly id: "asr";
                        readonly src: "maybe_ponyfill";
                        readonly input: ({ context }: {
                            context: import("./types").ASRContext;
                            event: import("./types").ASREvent;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                        }) => {
                            azureRegion: string;
                            audioContext: AudioContext;
                            azureAuthorizationToken: string;
                            locale: string;
                            speechRecognitionEndpointId: string;
                            completeTimeout: number;
                            hints: string[];
                        };
                    };
                    readonly on: {
                        readonly FINAL_RESULT: readonly [{
                            readonly target: ".NLURequest";
                            readonly guard: {
                                readonly type: "nlu_is_activated";
                            };
                        }, {
                            readonly target: ".WaitToStop";
                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "FINAL_RESULT";
                            }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                        }];
                        readonly RESULT: {
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "RESULT";
                                value: Hypothesis[];
                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                maybe_ponyfill: {
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                type: "RESULT";
                                value: Hypothesis[];
                            }, undefined, import("./types").ASREvent>];
                            readonly target: ".InterimResult";
                        };
                        readonly STOP: {
                            readonly target: ".WaitToStop";
                        };
                        readonly CONTROL: {
                            readonly target: ".Pausing";
                        };
                        readonly NOINPUT: {
                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "NOINPUT";
                            }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                            readonly target: ".WaitToStop";
                        };
                    };
                    readonly initial: "WaitForRecogniser";
                    readonly states: {
                        readonly WaitForRecogniser: {
                            readonly on: {
                                readonly STARTED: {
                                    readonly target: "NoInput";
                                    readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "STARTED";
                                        value: {
                                            wsaASRinstance: import("./types").MySpeechRecognition;
                                        };
                                    }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                };
                            };
                        };
                        readonly NoInput: {
                            readonly entry: {
                                readonly type: "raise_noinput_after_timeout";
                            };
                            readonly on: {
                                readonly STARTSPEECH: {
                                    readonly target: "InProgress";
                                    readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                        type: "STARTSPEECH";
                                    }, undefined, import("./types").ASREvent>;
                                };
                            };
                            readonly exit: {
                                readonly type: "cancel_noinput_timeout";
                            };
                        };
                        readonly InProgress: {
                            readonly entry: () => void;
                        };
                        readonly InterimResult: {
                            readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                        };
                        readonly WaitToStop: {
                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                            readonly on: {
                                readonly LISTEN_COMPLETE: {
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "LISTEN_COMPLETE";
                                    }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    readonly target: "Stopped";
                                };
                            };
                        };
                        readonly Pausing: {
                            readonly onDone: "#asr.Recognising";
                            readonly initial: "WaitToPause";
                            readonly states: {
                                readonly WaitToPause: {
                                    readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    readonly on: {
                                        readonly LISTEN_COMPLETE: {
                                            readonly target: "Paused";
                                        };
                                    };
                                };
                                readonly Paused: {
                                    readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    readonly on: {
                                        readonly CONTROL: {
                                            readonly target: "Continue";
                                        };
                                    };
                                };
                                readonly Continue: {
                                    readonly type: "final";
                                };
                            };
                        };
                        readonly NLURequest: {
                            readonly invoke: {
                                readonly src: "nluPromise";
                                readonly input: ({ context }: {
                                    context: import("./types").ASRContext;
                                    event: import("./types").ASREvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                }) => {
                                    endpoint: string;
                                    key: string;
                                    projectName: string;
                                    deploymentName: string;
                                    query: string;
                                    locale: string;
                                };
                                readonly onDone: readonly [{
                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                    readonly target: "WaitToStop";
                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                }, {
                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                    readonly target: "WaitToStop";
                                }];
                                readonly onError: {
                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                    readonly target: "WaitToStop";
                                };
                            };
                        };
                        readonly Stopped: {
                            readonly type: "final";
                        };
                    };
                };
            };
        }>;
        id: string;
    };
    getToken: {
        src: "getToken";
        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
        id: string;
    };
    visemes: {
        src: "visemes";
        logic: import("xstate").StateMachine<{
            queue: number[];
        }, {
            type: "VISEME";
            value: any;
        }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
            readonly context: {
                readonly queue: [];
            };
            readonly initial: "Init";
            readonly states: {
                readonly Init: {
                    readonly on: {
                        readonly VISEME: readonly [{
                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                queue: number[];
                            }, {
                                type: "VISEME";
                                value: any;
                            }>) => boolean;
                            readonly actions: readonly [import("xstate").ActionFunction<{
                                queue: number[];
                            }, {
                                type: "VISEME";
                                value: any;
                            }, {
                                type: "VISEME";
                                value: any;
                            }, undefined, never, never, never, never, never>];
                        }];
                    };
                };
            };
        }>;
        id: string;
    };
}>, import("xstate").Values<{
    spawnTTS: {
        type: "spawnTTS";
        params: {};
    };
    spawnASR: {
        type: "spawnASR";
        params: {};
    };
}>, never, "NEW_TOKEN_INTERVAL", "Stopped" | {
    Active: {
        AsrTtsSpawner: "Idle" | "Fail" | "CreateAudioContext" | "Spawn" | "GenerateToken" | "GenerateNewTokens";
        AsrTtsManager: "Fail" | "Stopped" | "Initialize" | "PreReady" | {
            Ready: "Idle" | "WaitForRecogniser" | {
                Speaking: "Paused" | "Start" | "Proceed";
            } | {
                Recognising: "Paused" | "Proceed";
            };
        };
    };
}, string, Settings, {}, import("xstate").EventObject, import("xstate").MetaObject, {
    readonly context: ({ input }: {
        spawn: {
            <TSrc extends "audioContext" | "tts" | "asr" | "getToken" | "visemes">(logic: TSrc, ...[options]: ({
                src: "audioContext";
                logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                id: string;
            } extends infer T ? T extends {
                src: "audioContext";
                logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                id: string;
            } ? T extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T["logic"]>;
                syncSnapshot?: boolean;
            } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                src: "tts";
                logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        audioURL: string;
                    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                        audioContext: AudioContext;
                        audioBuffer: AudioBuffer;
                    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                        utterance: string;
                        voice: string;
                        ttsLexicon: string;
                        locale: string;
                        wsaUtt: {
                            prototype: SpeechSynthesisUtterance;
                            new (text?: string): SpeechSynthesisUtterance;
                        };
                        wsaTTS: SpeechSynthesis;
                        visemes?: boolean;
                    }, import("xstate").EventObject>>;
                }, import("xstate").Values<{
                    checkCache: {
                        src: "checkCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    getAudioFromCache: {
                        src: "getAudioFromCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    getAudio: {
                        src: "getAudio";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            audioURL: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    playAudio: {
                        src: "playAudio";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                            audioContext: AudioContext;
                            audioBuffer: AudioBuffer;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    createEventsFromStream: {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    start: {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<null, {
                            utterance: string;
                            voice: string;
                            ttsLexicon: string;
                            locale: string;
                            wsaUtt: {
                                prototype: SpeechSynthesisUtterance;
                                new (text?: string): SpeechSynthesisUtterance;
                            };
                            wsaTTS: SpeechSynthesis;
                            visemes?: boolean;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, import("xstate").Values<{
                    ttsStop: {
                        type: "ttsStop";
                        params: unknown;
                    };
                    addFiller: {
                        type: "addFiller";
                        params: {};
                    };
                    assignCurrentVoice: {
                        type: "assignCurrentVoice";
                        params: {};
                    };
                    assignCurrentLocale: {
                        type: "assignCurrentLocale";
                        params: {};
                    };
                    sendParentCurrentPersona: {
                        type: "sendParentCurrentPersona";
                        params: {};
                    };
                }>, import("xstate").Values<{
                    bufferContainsUtterancePartReadyToBeSpoken: {
                        type: "bufferContainsUtterancePartReadyToBeSpoken";
                        params: unknown;
                    };
                    bufferIsNonEmpty: {
                        type: "bufferIsNonEmpty";
                        params: unknown;
                    };
                }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
                    Operation: "NotReady" | {
                        Ready: "Idle" | {
                            BufferedSpeaker: {
                                Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                                Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                                    Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                        UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                                    };
                                };
                            };
                        } | {
                            Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                        } | {
                            Speaking: "Go" | "Paused";
                        };
                    };
                    MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
                }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly id: "tts";
                    readonly context: ({ input }: {
                        spawn: {
                            <TSrc_1 extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc_1, ...[options]: ({
                                src: "checkCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_1 ? T_1 extends {
                                src: "checkCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_1 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_1["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_1["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                                src: "getAudioFromCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_2 ? T_2 extends {
                                src: "getAudioFromCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_2 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_2["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_2["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                                src: "getAudio";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    audioURL: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_3 ? T_3 extends {
                                src: "getAudio";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    audioURL: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_3 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_3["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_3["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                                src: "playAudio";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                    audioContext: AudioContext;
                                    audioBuffer: AudioBuffer;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_4 ? T_4 extends {
                                src: "playAudio";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                    audioContext: AudioContext;
                                    audioBuffer: AudioBuffer;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_4 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_4["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_4["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_5 ? T_5 extends {
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                id: string;
                            } ? T_5 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_5["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_5["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_6 ? T_6 extends {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } ? T_6 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_6["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_6["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never) | ({
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<null, {
                                    utterance: string;
                                    voice: string;
                                    ttsLexicon: string;
                                    locale: string;
                                    wsaUtt: {
                                        prototype: SpeechSynthesisUtterance;
                                        new (text?: string): SpeechSynthesisUtterance;
                                    };
                                    wsaTTS: SpeechSynthesis;
                                    visemes?: boolean;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_7 ? T_7 extends {
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<null, {
                                    utterance: string;
                                    voice: string;
                                    ttsLexicon: string;
                                    locale: string;
                                    wsaUtt: {
                                        prototype: SpeechSynthesisUtterance;
                                        new (text?: string): SpeechSynthesisUtterance;
                                    };
                                    wsaTTS: SpeechSynthesis;
                                    visemes?: boolean;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_7 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_7["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_7["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_7 in import("xstate").RequiredActorOptions<T_7>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_7>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                checkCache: {
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudioFromCache: {
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudio: {
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                playAudio: {
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, "src", TSrc_1>["logic"]>;
                            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                id?: never;
                                systemId?: string;
                                input?: import("xstate").InputFrom<TLogic>;
                                syncSnapshot?: boolean;
                            }): import("xstate").ActorRefFromLogic<TLogic>;
                        };
                        input: import("./types").TTSInit;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                    }) => {
                        azureAuthorizationToken: string;
                        ttsDefaultVoice: string;
                        ttsDefaultFillerDelay: number;
                        ttsDefaultFiller: string;
                        ttsLexicon: string;
                        audioContext: AudioContext;
                        azureRegion: string;
                        locale: string;
                        buffer: string;
                    };
                    readonly on: {
                        readonly ERROR: {
                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                type: "ERROR";
                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                        };
                    };
                    readonly type: "parallel";
                    readonly states: {
                        readonly Operation: {
                            readonly initial: "NotReady";
                            readonly states: {
                                readonly NotReady: {
                                    readonly on: {
                                        readonly READY: {
                                            readonly target: "Ready";
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "READY";
                                                value: {
                                                    wsaTTS: SpeechSynthesis;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                };
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                        };
                                    };
                                };
                                readonly Ready: {
                                    readonly initial: "Idle";
                                    readonly states: {
                                        readonly Idle: {
                                            readonly id: "Idle";
                                            readonly on: {
                                                readonly SPEAK: readonly [{
                                                    readonly target: "BufferedSpeaker";
                                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }>) => boolean;
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>;
                                                }, {
                                                    readonly target: "Playing";
                                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }>) => boolean;
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>;
                                                }, {
                                                    readonly target: "Speaking";
                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent>) => void];
                                                }];
                                            };
                                        };
                                        readonly BufferedSpeaker: {
                                            readonly type: "parallel";
                                            readonly invoke: {
                                                readonly id: "createEventsFromStream";
                                                readonly src: "createEventsFromStream";
                                                readonly input: ({ context }: {
                                                    context: import("./types").TTSContext;
                                                    event: import("./types").TTSEvent;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => Agenda;
                                            };
                                            readonly on: {
                                                readonly STOP: {
                                                    readonly target: "Idle";
                                                };
                                            };
                                            readonly states: {
                                                readonly Buffer: {
                                                    readonly initial: "BufferIdle";
                                                    readonly on: {
                                                        readonly STREAMING_SET_VOICE: {
                                                            readonly actions: "assignCurrentVoice";
                                                        };
                                                        readonly STREAMING_SET_LOCALE: {
                                                            readonly actions: "assignCurrentLocale";
                                                        };
                                                        readonly STREAMING_SET_PERSONA: {
                                                            readonly actions: "sendParentCurrentPersona";
                                                        };
                                                    };
                                                    readonly states: {
                                                        readonly BufferIdle: {
                                                            readonly id: "BufferIdle";
                                                            readonly on: {
                                                                readonly STREAMING_CHUNK: {
                                                                    readonly target: "Buffering";
                                                                };
                                                                readonly STREAMING_DONE: "BufferingDone";
                                                            };
                                                        };
                                                        readonly Buffering: {
                                                            readonly id: "Buffering";
                                                            readonly on: {
                                                                readonly STREAMING_CHUNK: {
                                                                    readonly target: "Buffering";
                                                                    readonly reenter: true;
                                                                };
                                                                readonly STREAMING_DONE: "BufferingDone";
                                                            };
                                                            readonly after: {
                                                                readonly STREAMING_TIMEOUT: {
                                                                    readonly target: "BufferingDone";
                                                                    readonly actions: () => void;
                                                                };
                                                            };
                                                            readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                checkCache: {
                                                                    src: "checkCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudioFromCache: {
                                                                    src: "getAudioFromCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudio: {
                                                                    src: "getAudio";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        audioURL: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                playAudio: {
                                                                    src: "playAudio";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                        audioContext: AudioContext;
                                                                        audioBuffer: AudioBuffer;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                        utterance: string;
                                                                        voice: string;
                                                                        ttsLexicon: string;
                                                                        locale: string;
                                                                        wsaUtt: {
                                                                            prototype: SpeechSynthesisUtterance;
                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                        };
                                                                        wsaTTS: SpeechSynthesis;
                                                                        visemes?: boolean;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>];
                                                        };
                                                        readonly BufferingDone: {
                                                            readonly id: "BufferingDone";
                                                            readonly type: "final";
                                                        };
                                                    };
                                                };
                                                readonly Speaker: {
                                                    readonly initial: "SpeakingIdle";
                                                    readonly states: {
                                                        readonly SpeakingIdle: {
                                                            readonly id: "SpeakingIdle";
                                                            readonly always: readonly [{
                                                                readonly target: "Speak";
                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            }, {
                                                                readonly target: "PrepareSpeech";
                                                                readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                            }];
                                                            readonly after: {
                                                                readonly FILLER_DELAY: {
                                                                    readonly target: "SpeakingIdle";
                                                                    readonly reenter: true;
                                                                    readonly actions: "addFiller";
                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                };
                                                            };
                                                        };
                                                        readonly PrepareSpeech: {
                                                            readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                checkCache: {
                                                                    src: "checkCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudioFromCache: {
                                                                    src: "getAudioFromCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudio: {
                                                                    src: "getAudio";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        audioURL: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                playAudio: {
                                                                    src: "playAudio";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                        audioContext: AudioContext;
                                                                        audioBuffer: AudioBuffer;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                        utterance: string;
                                                                        voice: string;
                                                                        ttsLexicon: string;
                                                                        locale: string;
                                                                        wsaUtt: {
                                                                            prototype: SpeechSynthesisUtterance;
                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                        };
                                                                        wsaTTS: SpeechSynthesis;
                                                                        visemes?: boolean;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>];
                                                            readonly always: readonly [{
                                                                readonly target: "Speak";
                                                            }];
                                                        };
                                                        readonly Speak: {
                                                            readonly initial: "Init";
                                                            readonly states: {
                                                                readonly Init: {
                                                                    readonly always: readonly [{
                                                                        readonly target: "CheckCache";
                                                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                    }, {
                                                                        readonly target: "Go";
                                                                    }];
                                                                };
                                                                readonly CheckCache: {
                                                                    readonly invoke: {
                                                                        readonly src: "checkCache";
                                                                        readonly input: ({ context }: {
                                                                            context: import("./types").TTSContext;
                                                                            event: import("./types").TTSEvent;
                                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                        }) => {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        };
                                                                        readonly onError: "Go";
                                                                        readonly onDone: readonly [{
                                                                            readonly target: "UseCache";
                                                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                            readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                        }, {
                                                                            readonly target: "Go";
                                                                            readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                        }];
                                                                    };
                                                                };
                                                                readonly UseCache: {
                                                                    readonly initial: "GetAudio";
                                                                    readonly states: {
                                                                        readonly GetAudio: {
                                                                            readonly invoke: {
                                                                                readonly src: "getAudioFromCache";
                                                                                readonly input: ({ context }: {
                                                                                    context: import("./types").TTSContext;
                                                                                    event: import("./types").TTSEvent;
                                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                }) => {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                };
                                                                                readonly onDone: {
                                                                                    readonly target: "PlayAudio";
                                                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                        checkCache: {
                                                                                            src: "checkCache";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                cacheURL: string;
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                locale: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        getAudioFromCache: {
                                                                                            src: "getAudioFromCache";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                audioContext: AudioContext;
                                                                                                cacheURL: string;
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                locale: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        getAudio: {
                                                                                            src: "getAudio";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                audioContext: AudioContext;
                                                                                                audioURL: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        playAudio: {
                                                                                            src: "playAudio";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                audioContext: AudioContext;
                                                                                                audioBuffer: AudioBuffer;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        createEventsFromStream: {
                                                                                            src: "createEventsFromStream";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        ponyfill: {
                                                                                            src: "ponyfill";
                                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        start: {
                                                                                            src: "start";
                                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                ttsLexicon: string;
                                                                                                locale: string;
                                                                                                wsaUtt: {
                                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                                };
                                                                                                wsaTTS: SpeechSynthesis;
                                                                                                visemes?: boolean;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                    }>, never, never, never, never>;
                                                                                };
                                                                                readonly onError: "#TtsStreamGo";
                                                                            };
                                                                        };
                                                                        readonly PlayAudio: {
                                                                            readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                            readonly invoke: {
                                                                                readonly src: "playAudio";
                                                                                readonly input: ({ context }: {
                                                                                    context: import("./types").TTSContext;
                                                                                    event: import("./types").TTSEvent;
                                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                }) => {
                                                                                    audioBuffer: AudioBuffer;
                                                                                    audioContext: AudioContext;
                                                                                };
                                                                            };
                                                                            readonly on: {
                                                                                readonly CONTROL: "PausedAudio";
                                                                                readonly SPEAK_COMPLETE: readonly [{
                                                                                    readonly target: "#SpeakingDone";
                                                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                        type: "SPEAK_COMPLETE";
                                                                                    }, unknown, any>;
                                                                                }, {
                                                                                    readonly target: "#SpeakingIdle";
                                                                                }];
                                                                                readonly TTS_STARTED: {
                                                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                        type: "TTS_STARTED";
                                                                                        value?: AudioBufferSourceNode;
                                                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                        type: "TTS_STARTED";
                                                                                        value?: AudioBufferSourceNode;
                                                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                        checkCache: {
                                                                                            src: "checkCache";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                cacheURL: string;
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                locale: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        getAudioFromCache: {
                                                                                            src: "getAudioFromCache";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                audioContext: AudioContext;
                                                                                                cacheURL: string;
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                locale: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        getAudio: {
                                                                                            src: "getAudio";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                audioContext: AudioContext;
                                                                                                audioURL: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        playAudio: {
                                                                                            src: "playAudio";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                audioContext: AudioContext;
                                                                                                audioBuffer: AudioBuffer;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        createEventsFromStream: {
                                                                                            src: "createEventsFromStream";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        ponyfill: {
                                                                                            src: "ponyfill";
                                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        start: {
                                                                                            src: "start";
                                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                ttsLexicon: string;
                                                                                                locale: string;
                                                                                                wsaUtt: {
                                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                                };
                                                                                                wsaTTS: SpeechSynthesis;
                                                                                                visemes?: boolean;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                    }>, never, never, never, never>];
                                                                                };
                                                                            };
                                                                            readonly exit: "ttsStop";
                                                                        };
                                                                        readonly PausedAudio: {
                                                                            readonly on: {
                                                                                readonly CONTROL: "PlayAudio";
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                                readonly Go: {
                                                                    readonly id: "TtsStreamGo";
                                                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                    readonly invoke: {
                                                                        readonly src: "start";
                                                                        readonly input: ({ context }: {
                                                                            context: import("./types").TTSContext;
                                                                            event: import("./types").TTSEvent;
                                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                        }) => {
                                                                            wsaTTS: SpeechSynthesis;
                                                                            wsaUtt: {
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                prototype: SpeechSynthesisUtterance;
                                                                            };
                                                                            ttsLexicon: string;
                                                                            visemes: boolean;
                                                                            voice: string;
                                                                            locale: string;
                                                                            utterance: string;
                                                                        };
                                                                    };
                                                                    readonly on: {
                                                                        readonly CONTROL: "Paused";
                                                                        readonly SPEAK_COMPLETE: readonly [{
                                                                            readonly target: "#SpeakingDone";
                                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                type: "SPEAK_COMPLETE";
                                                                            }, unknown, any>;
                                                                        }, {
                                                                            readonly target: "#SpeakingIdle";
                                                                        }];
                                                                        readonly TTS_STARTED: {
                                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                type: "TTS_STARTED";
                                                                                value?: AudioBufferSourceNode;
                                                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        };
                                                                    };
                                                                    readonly exit: "ttsStop";
                                                                };
                                                                readonly Paused: {
                                                                    readonly on: {
                                                                        readonly CONTROL: "Go";
                                                                    };
                                                                };
                                                            };
                                                        };
                                                        readonly SpeakingDone: {
                                                            readonly id: "SpeakingDone";
                                                            readonly type: "final";
                                                        };
                                                    };
                                                };
                                            };
                                            readonly onDone: {
                                                readonly target: "Idle";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                            };
                                        };
                                        readonly Playing: {
                                            readonly on: {
                                                readonly SPEAK_COMPLETE: {
                                                    readonly target: "Idle";
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "SPEAK_COMPLETE";
                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                };
                                                readonly TTS_STARTED: {
                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "TTS_STARTED";
                                                        value?: AudioBufferSourceNode;
                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "TTS_STARTED";
                                                        value?: AudioBufferSourceNode;
                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                };
                                                readonly STOP: {
                                                    readonly target: "Idle";
                                                };
                                            };
                                            readonly initial: "FetchAudio";
                                            readonly states: {
                                                readonly FetchAudio: {
                                                    readonly invoke: {
                                                        readonly src: "getAudio";
                                                        readonly input: ({ context }: {
                                                            context: import("./types").TTSContext;
                                                            event: import("./types").TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        };
                                                        readonly onDone: {
                                                            readonly target: "PlayAudio";
                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                checkCache: {
                                                                    src: "checkCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudioFromCache: {
                                                                    src: "getAudioFromCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudio: {
                                                                    src: "getAudio";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        audioURL: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                playAudio: {
                                                                    src: "playAudio";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                        audioContext: AudioContext;
                                                                        audioBuffer: AudioBuffer;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                        utterance: string;
                                                                        voice: string;
                                                                        ttsLexicon: string;
                                                                        locale: string;
                                                                        wsaUtt: {
                                                                            prototype: SpeechSynthesisUtterance;
                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                        };
                                                                        wsaTTS: SpeechSynthesis;
                                                                        visemes?: boolean;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>;
                                                        };
                                                        readonly onError: {
                                                            readonly target: "#Speaking";
                                                        };
                                                    };
                                                };
                                                readonly PlayAudio: {
                                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly invoke: {
                                                        readonly src: "playAudio";
                                                        readonly input: ({ context }: {
                                                            context: import("./types").TTSContext;
                                                            event: import("./types").TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        };
                                                    };
                                                    readonly on: {
                                                        readonly CONTROL: "AudioPaused";
                                                    };
                                                    readonly exit: "ttsStop";
                                                };
                                                readonly AudioPaused: {
                                                    readonly on: {
                                                        readonly CONTROL: "PlayAudio";
                                                    };
                                                };
                                            };
                                        };
                                        readonly Speaking: {
                                            readonly id: "Speaking";
                                            readonly initial: "Go";
                                            readonly on: {
                                                readonly STOP: {
                                                    readonly target: "Idle";
                                                };
                                                readonly TTS_STARTED: {
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "TTS_STARTED";
                                                        value?: AudioBufferSourceNode;
                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                };
                                                readonly VISEME: {
                                                    readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                        type: "VISEME";
                                                        value: any;
                                                    }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                                };
                                                readonly SPEAK_COMPLETE: {
                                                    readonly target: "Idle";
                                                };
                                            };
                                            readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                            readonly states: {
                                                readonly Go: {
                                                    readonly invoke: {
                                                        readonly src: "start";
                                                        readonly input: ({ context }: {
                                                            context: import("./types").TTSContext;
                                                            event: import("./types").TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            wsaTTS: SpeechSynthesis;
                                                            wsaUtt: {
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                prototype: SpeechSynthesisUtterance;
                                                            };
                                                            ttsLexicon: string;
                                                            voice: string;
                                                            visemes: boolean;
                                                            locale: string;
                                                            utterance: string;
                                                        };
                                                    };
                                                    readonly on: {
                                                        readonly CONTROL: "Paused";
                                                    };
                                                    readonly exit: "ttsStop";
                                                };
                                                readonly Paused: {
                                                    readonly on: {
                                                        readonly SPEAK_COMPLETE: {};
                                                        readonly CONTROL: "Go";
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                        readonly MaybeHandleNewTokens: {
                            readonly initial: "Choice";
                            readonly states: {
                                readonly Choice: {
                                    readonly always: readonly [{
                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                        readonly target: "Ponyfill";
                                    }, {
                                        readonly target: "NoPonyfill";
                                    }];
                                };
                                readonly NoPonyfill: {
                                    readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                        checkCache: {
                                            src: "checkCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudioFromCache: {
                                            src: "getAudioFromCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudio: {
                                            src: "getAudio";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        playAudio: {
                                            src: "playAudio";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<null, {
                                                utterance: string;
                                                voice: string;
                                                ttsLexicon: string;
                                                locale: string;
                                                wsaUtt: {
                                                    prototype: SpeechSynthesisUtterance;
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                };
                                                wsaTTS: SpeechSynthesis;
                                                visemes?: boolean;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                                readonly Ponyfill: {
                                    readonly invoke: {
                                        readonly id: "ponyTTS";
                                        readonly src: "ponyfill";
                                        readonly input: ({ context }: {
                                            context: import("./types").TTSContext;
                                            event: import("./types").TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            azureAuthorizationToken: string;
                                            azureRegion: string;
                                            audioContext: AudioContext;
                                        };
                                    };
                                    readonly on: {
                                        readonly READY: {
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "READY";
                                                value: {
                                                    wsaTTS: SpeechSynthesis;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                };
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        };
                                        readonly NEW_TOKEN: {
                                            readonly target: "Ponyfill";
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "NEW_TOKEN";
                                                value: string;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                            readonly reenter: true;
                                        };
                                    };
                                };
                            };
                        };
                    };
                }>;
                id: string;
            } extends infer T_1 ? T_1 extends {
                src: "tts";
                logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        cacheURL: string;
                        utterance: string;
                        voice: string;
                        locale: string;
                    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                        audioContext: AudioContext;
                        audioURL: string;
                    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                        audioContext: AudioContext;
                        audioBuffer: AudioBuffer;
                    }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                        utterance: string;
                        voice: string;
                        ttsLexicon: string;
                        locale: string;
                        wsaUtt: {
                            prototype: SpeechSynthesisUtterance;
                            new (text?: string): SpeechSynthesisUtterance;
                        };
                        wsaTTS: SpeechSynthesis;
                        visemes?: boolean;
                    }, import("xstate").EventObject>>;
                }, import("xstate").Values<{
                    checkCache: {
                        src: "checkCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    getAudioFromCache: {
                        src: "getAudioFromCache";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    getAudio: {
                        src: "getAudio";
                        logic: import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            audioURL: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    playAudio: {
                        src: "playAudio";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                            audioContext: AudioContext;
                            audioBuffer: AudioBuffer;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                    createEventsFromStream: {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    start: {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<null, {
                            utterance: string;
                            voice: string;
                            ttsLexicon: string;
                            locale: string;
                            wsaUtt: {
                                prototype: SpeechSynthesisUtterance;
                                new (text?: string): SpeechSynthesisUtterance;
                            };
                            wsaTTS: SpeechSynthesis;
                            visemes?: boolean;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, import("xstate").Values<{
                    ttsStop: {
                        type: "ttsStop";
                        params: unknown;
                    };
                    addFiller: {
                        type: "addFiller";
                        params: {};
                    };
                    assignCurrentVoice: {
                        type: "assignCurrentVoice";
                        params: {};
                    };
                    assignCurrentLocale: {
                        type: "assignCurrentLocale";
                        params: {};
                    };
                    sendParentCurrentPersona: {
                        type: "sendParentCurrentPersona";
                        params: {};
                    };
                }>, import("xstate").Values<{
                    bufferContainsUtterancePartReadyToBeSpoken: {
                        type: "bufferContainsUtterancePartReadyToBeSpoken";
                        params: unknown;
                    };
                    bufferIsNonEmpty: {
                        type: "bufferIsNonEmpty";
                        params: unknown;
                    };
                }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
                    Operation: "NotReady" | {
                        Ready: "Idle" | {
                            BufferedSpeaker: {
                                Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                                Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                                    Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                        UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                                    };
                                };
                            };
                        } | {
                            Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                        } | {
                            Speaking: "Go" | "Paused";
                        };
                    };
                    MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
                }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly id: "tts";
                    readonly context: ({ input }: {
                        spawn: {
                            <TSrc_1 extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc_1, ...[options]: ({
                                src: "checkCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_2 ? T_2 extends {
                                src: "checkCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_2 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_2["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_2["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                                src: "getAudioFromCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_3 ? T_3 extends {
                                src: "getAudioFromCache";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    cacheURL: string;
                                    utterance: string;
                                    voice: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_3 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_3["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_3["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                                src: "getAudio";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    audioURL: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_4 ? T_4 extends {
                                src: "getAudio";
                                logic: import("xstate").PromiseActorLogic<any, {
                                    audioContext: AudioContext;
                                    audioURL: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_4 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_4["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_4["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                                src: "playAudio";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                    audioContext: AudioContext;
                                    audioBuffer: AudioBuffer;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_5 ? T_5 extends {
                                src: "playAudio";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                    audioContext: AudioContext;
                                    audioBuffer: AudioBuffer;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_5 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_5["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_5["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_6 ? T_6 extends {
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                id: string;
                            } ? T_6 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_6["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_6["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never) | ({
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_7 ? T_7 extends {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } ? T_7 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_7["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_7["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_7 in import("xstate").RequiredActorOptions<T_7>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_7>>> : never : never : never) | ({
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<null, {
                                    utterance: string;
                                    voice: string;
                                    ttsLexicon: string;
                                    locale: string;
                                    wsaUtt: {
                                        prototype: SpeechSynthesisUtterance;
                                        new (text?: string): SpeechSynthesisUtterance;
                                    };
                                    wsaTTS: SpeechSynthesis;
                                    visemes?: boolean;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_8 ? T_8 extends {
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<null, {
                                    utterance: string;
                                    voice: string;
                                    ttsLexicon: string;
                                    locale: string;
                                    wsaUtt: {
                                        prototype: SpeechSynthesisUtterance;
                                        new (text?: string): SpeechSynthesisUtterance;
                                    };
                                    wsaTTS: SpeechSynthesis;
                                    visemes?: boolean;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_8 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_8["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_8["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_8 in import("xstate").RequiredActorOptions<T_8>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_8>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                checkCache: {
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudioFromCache: {
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                getAudio: {
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                playAudio: {
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, "src", TSrc_1>["logic"]>;
                            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                id?: never;
                                systemId?: string;
                                input?: import("xstate").InputFrom<TLogic>;
                                syncSnapshot?: boolean;
                            }): import("xstate").ActorRefFromLogic<TLogic>;
                        };
                        input: import("./types").TTSInit;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                    }) => {
                        azureAuthorizationToken: string;
                        ttsDefaultVoice: string;
                        ttsDefaultFillerDelay: number;
                        ttsDefaultFiller: string;
                        ttsLexicon: string;
                        audioContext: AudioContext;
                        azureRegion: string;
                        locale: string;
                        buffer: string;
                    };
                    readonly on: {
                        readonly ERROR: {
                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                type: "ERROR";
                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                        };
                    };
                    readonly type: "parallel";
                    readonly states: {
                        readonly Operation: {
                            readonly initial: "NotReady";
                            readonly states: {
                                readonly NotReady: {
                                    readonly on: {
                                        readonly READY: {
                                            readonly target: "Ready";
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "READY";
                                                value: {
                                                    wsaTTS: SpeechSynthesis;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                };
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                        };
                                    };
                                };
                                readonly Ready: {
                                    readonly initial: "Idle";
                                    readonly states: {
                                        readonly Idle: {
                                            readonly id: "Idle";
                                            readonly on: {
                                                readonly SPEAK: readonly [{
                                                    readonly target: "BufferedSpeaker";
                                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }>) => boolean;
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>;
                                                }, {
                                                    readonly target: "Playing";
                                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }>) => boolean;
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>;
                                                }, {
                                                    readonly target: "Speaking";
                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                        type: "SPEAK";
                                                        value: Agenda;
                                                    }, import("./types").TTSEvent>) => void];
                                                }];
                                            };
                                        };
                                        readonly BufferedSpeaker: {
                                            readonly type: "parallel";
                                            readonly invoke: {
                                                readonly id: "createEventsFromStream";
                                                readonly src: "createEventsFromStream";
                                                readonly input: ({ context }: {
                                                    context: import("./types").TTSContext;
                                                    event: import("./types").TTSEvent;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => Agenda;
                                            };
                                            readonly on: {
                                                readonly STOP: {
                                                    readonly target: "Idle";
                                                };
                                            };
                                            readonly states: {
                                                readonly Buffer: {
                                                    readonly initial: "BufferIdle";
                                                    readonly on: {
                                                        readonly STREAMING_SET_VOICE: {
                                                            readonly actions: "assignCurrentVoice";
                                                        };
                                                        readonly STREAMING_SET_LOCALE: {
                                                            readonly actions: "assignCurrentLocale";
                                                        };
                                                        readonly STREAMING_SET_PERSONA: {
                                                            readonly actions: "sendParentCurrentPersona";
                                                        };
                                                    };
                                                    readonly states: {
                                                        readonly BufferIdle: {
                                                            readonly id: "BufferIdle";
                                                            readonly on: {
                                                                readonly STREAMING_CHUNK: {
                                                                    readonly target: "Buffering";
                                                                };
                                                                readonly STREAMING_DONE: "BufferingDone";
                                                            };
                                                        };
                                                        readonly Buffering: {
                                                            readonly id: "Buffering";
                                                            readonly on: {
                                                                readonly STREAMING_CHUNK: {
                                                                    readonly target: "Buffering";
                                                                    readonly reenter: true;
                                                                };
                                                                readonly STREAMING_DONE: "BufferingDone";
                                                            };
                                                            readonly after: {
                                                                readonly STREAMING_TIMEOUT: {
                                                                    readonly target: "BufferingDone";
                                                                    readonly actions: () => void;
                                                                };
                                                            };
                                                            readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                checkCache: {
                                                                    src: "checkCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudioFromCache: {
                                                                    src: "getAudioFromCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudio: {
                                                                    src: "getAudio";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        audioURL: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                playAudio: {
                                                                    src: "playAudio";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                        audioContext: AudioContext;
                                                                        audioBuffer: AudioBuffer;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                        utterance: string;
                                                                        voice: string;
                                                                        ttsLexicon: string;
                                                                        locale: string;
                                                                        wsaUtt: {
                                                                            prototype: SpeechSynthesisUtterance;
                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                        };
                                                                        wsaTTS: SpeechSynthesis;
                                                                        visemes?: boolean;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>];
                                                        };
                                                        readonly BufferingDone: {
                                                            readonly id: "BufferingDone";
                                                            readonly type: "final";
                                                        };
                                                    };
                                                };
                                                readonly Speaker: {
                                                    readonly initial: "SpeakingIdle";
                                                    readonly states: {
                                                        readonly SpeakingIdle: {
                                                            readonly id: "SpeakingIdle";
                                                            readonly always: readonly [{
                                                                readonly target: "Speak";
                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            }, {
                                                                readonly target: "PrepareSpeech";
                                                                readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                            }];
                                                            readonly after: {
                                                                readonly FILLER_DELAY: {
                                                                    readonly target: "SpeakingIdle";
                                                                    readonly reenter: true;
                                                                    readonly actions: "addFiller";
                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                };
                                                            };
                                                        };
                                                        readonly PrepareSpeech: {
                                                            readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                checkCache: {
                                                                    src: "checkCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudioFromCache: {
                                                                    src: "getAudioFromCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudio: {
                                                                    src: "getAudio";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        audioURL: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                playAudio: {
                                                                    src: "playAudio";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                        audioContext: AudioContext;
                                                                        audioBuffer: AudioBuffer;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                        utterance: string;
                                                                        voice: string;
                                                                        ttsLexicon: string;
                                                                        locale: string;
                                                                        wsaUtt: {
                                                                            prototype: SpeechSynthesisUtterance;
                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                        };
                                                                        wsaTTS: SpeechSynthesis;
                                                                        visemes?: boolean;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>];
                                                            readonly always: readonly [{
                                                                readonly target: "Speak";
                                                            }];
                                                        };
                                                        readonly Speak: {
                                                            readonly initial: "Init";
                                                            readonly states: {
                                                                readonly Init: {
                                                                    readonly always: readonly [{
                                                                        readonly target: "CheckCache";
                                                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                    }, {
                                                                        readonly target: "Go";
                                                                    }];
                                                                };
                                                                readonly CheckCache: {
                                                                    readonly invoke: {
                                                                        readonly src: "checkCache";
                                                                        readonly input: ({ context }: {
                                                                            context: import("./types").TTSContext;
                                                                            event: import("./types").TTSEvent;
                                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                        }) => {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        };
                                                                        readonly onError: "Go";
                                                                        readonly onDone: readonly [{
                                                                            readonly target: "UseCache";
                                                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                            readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                        }, {
                                                                            readonly target: "Go";
                                                                            readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                        }];
                                                                    };
                                                                };
                                                                readonly UseCache: {
                                                                    readonly initial: "GetAudio";
                                                                    readonly states: {
                                                                        readonly GetAudio: {
                                                                            readonly invoke: {
                                                                                readonly src: "getAudioFromCache";
                                                                                readonly input: ({ context }: {
                                                                                    context: import("./types").TTSContext;
                                                                                    event: import("./types").TTSEvent;
                                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                }) => {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                };
                                                                                readonly onDone: {
                                                                                    readonly target: "PlayAudio";
                                                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                        checkCache: {
                                                                                            src: "checkCache";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                cacheURL: string;
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                locale: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        getAudioFromCache: {
                                                                                            src: "getAudioFromCache";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                audioContext: AudioContext;
                                                                                                cacheURL: string;
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                locale: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        getAudio: {
                                                                                            src: "getAudio";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                audioContext: AudioContext;
                                                                                                audioURL: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        playAudio: {
                                                                                            src: "playAudio";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                audioContext: AudioContext;
                                                                                                audioBuffer: AudioBuffer;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        createEventsFromStream: {
                                                                                            src: "createEventsFromStream";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        ponyfill: {
                                                                                            src: "ponyfill";
                                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        start: {
                                                                                            src: "start";
                                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                ttsLexicon: string;
                                                                                                locale: string;
                                                                                                wsaUtt: {
                                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                                };
                                                                                                wsaTTS: SpeechSynthesis;
                                                                                                visemes?: boolean;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                    }>, never, never, never, never>;
                                                                                };
                                                                                readonly onError: "#TtsStreamGo";
                                                                            };
                                                                        };
                                                                        readonly PlayAudio: {
                                                                            readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                            readonly invoke: {
                                                                                readonly src: "playAudio";
                                                                                readonly input: ({ context }: {
                                                                                    context: import("./types").TTSContext;
                                                                                    event: import("./types").TTSEvent;
                                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                }) => {
                                                                                    audioBuffer: AudioBuffer;
                                                                                    audioContext: AudioContext;
                                                                                };
                                                                            };
                                                                            readonly on: {
                                                                                readonly CONTROL: "PausedAudio";
                                                                                readonly SPEAK_COMPLETE: readonly [{
                                                                                    readonly target: "#SpeakingDone";
                                                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                        type: "SPEAK_COMPLETE";
                                                                                    }, unknown, any>;
                                                                                }, {
                                                                                    readonly target: "#SpeakingIdle";
                                                                                }];
                                                                                readonly TTS_STARTED: {
                                                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                        type: "TTS_STARTED";
                                                                                        value?: AudioBufferSourceNode;
                                                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                        type: "TTS_STARTED";
                                                                                        value?: AudioBufferSourceNode;
                                                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                        checkCache: {
                                                                                            src: "checkCache";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                cacheURL: string;
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                locale: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        getAudioFromCache: {
                                                                                            src: "getAudioFromCache";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                audioContext: AudioContext;
                                                                                                cacheURL: string;
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                locale: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        getAudio: {
                                                                                            src: "getAudio";
                                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                                audioContext: AudioContext;
                                                                                                audioURL: string;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        playAudio: {
                                                                                            src: "playAudio";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                audioContext: AudioContext;
                                                                                                audioBuffer: AudioBuffer;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        createEventsFromStream: {
                                                                                            src: "createEventsFromStream";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        ponyfill: {
                                                                                            src: "ponyfill";
                                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        start: {
                                                                                            src: "start";
                                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                                utterance: string;
                                                                                                voice: string;
                                                                                                ttsLexicon: string;
                                                                                                locale: string;
                                                                                                wsaUtt: {
                                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                                };
                                                                                                wsaTTS: SpeechSynthesis;
                                                                                                visemes?: boolean;
                                                                                            }, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                    }>, never, never, never, never>];
                                                                                };
                                                                            };
                                                                            readonly exit: "ttsStop";
                                                                        };
                                                                        readonly PausedAudio: {
                                                                            readonly on: {
                                                                                readonly CONTROL: "PlayAudio";
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                                readonly Go: {
                                                                    readonly id: "TtsStreamGo";
                                                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                    readonly invoke: {
                                                                        readonly src: "start";
                                                                        readonly input: ({ context }: {
                                                                            context: import("./types").TTSContext;
                                                                            event: import("./types").TTSEvent;
                                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                        }) => {
                                                                            wsaTTS: SpeechSynthesis;
                                                                            wsaUtt: {
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                prototype: SpeechSynthesisUtterance;
                                                                            };
                                                                            ttsLexicon: string;
                                                                            visemes: boolean;
                                                                            voice: string;
                                                                            locale: string;
                                                                            utterance: string;
                                                                        };
                                                                    };
                                                                    readonly on: {
                                                                        readonly CONTROL: "Paused";
                                                                        readonly SPEAK_COMPLETE: readonly [{
                                                                            readonly target: "#SpeakingDone";
                                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                type: "SPEAK_COMPLETE";
                                                                            }, unknown, any>;
                                                                        }, {
                                                                            readonly target: "#SpeakingIdle";
                                                                        }];
                                                                        readonly TTS_STARTED: {
                                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                type: "TTS_STARTED";
                                                                                value?: AudioBufferSourceNode;
                                                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        };
                                                                    };
                                                                    readonly exit: "ttsStop";
                                                                };
                                                                readonly Paused: {
                                                                    readonly on: {
                                                                        readonly CONTROL: "Go";
                                                                    };
                                                                };
                                                            };
                                                        };
                                                        readonly SpeakingDone: {
                                                            readonly id: "SpeakingDone";
                                                            readonly type: "final";
                                                        };
                                                    };
                                                };
                                            };
                                            readonly onDone: {
                                                readonly target: "Idle";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                            };
                                        };
                                        readonly Playing: {
                                            readonly on: {
                                                readonly SPEAK_COMPLETE: {
                                                    readonly target: "Idle";
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "SPEAK_COMPLETE";
                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                };
                                                readonly TTS_STARTED: {
                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "TTS_STARTED";
                                                        value?: AudioBufferSourceNode;
                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "TTS_STARTED";
                                                        value?: AudioBufferSourceNode;
                                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        checkCache: {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudioFromCache: {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        getAudio: {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        playAudio: {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                };
                                                readonly STOP: {
                                                    readonly target: "Idle";
                                                };
                                            };
                                            readonly initial: "FetchAudio";
                                            readonly states: {
                                                readonly FetchAudio: {
                                                    readonly invoke: {
                                                        readonly src: "getAudio";
                                                        readonly input: ({ context }: {
                                                            context: import("./types").TTSContext;
                                                            event: import("./types").TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        };
                                                        readonly onDone: {
                                                            readonly target: "PlayAudio";
                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                checkCache: {
                                                                    src: "checkCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudioFromCache: {
                                                                    src: "getAudioFromCache";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        cacheURL: string;
                                                                        utterance: string;
                                                                        voice: string;
                                                                        locale: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                getAudio: {
                                                                    src: "getAudio";
                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                        audioContext: AudioContext;
                                                                        audioURL: string;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                playAudio: {
                                                                    src: "playAudio";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                        audioContext: AudioContext;
                                                                        audioBuffer: AudioBuffer;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                        utterance: string;
                                                                        voice: string;
                                                                        ttsLexicon: string;
                                                                        locale: string;
                                                                        wsaUtt: {
                                                                            prototype: SpeechSynthesisUtterance;
                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                        };
                                                                        wsaTTS: SpeechSynthesis;
                                                                        visemes?: boolean;
                                                                    }, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>;
                                                        };
                                                        readonly onError: {
                                                            readonly target: "#Speaking";
                                                        };
                                                    };
                                                };
                                                readonly PlayAudio: {
                                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly invoke: {
                                                        readonly src: "playAudio";
                                                        readonly input: ({ context }: {
                                                            context: import("./types").TTSContext;
                                                            event: import("./types").TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        };
                                                    };
                                                    readonly on: {
                                                        readonly CONTROL: "AudioPaused";
                                                    };
                                                    readonly exit: "ttsStop";
                                                };
                                                readonly AudioPaused: {
                                                    readonly on: {
                                                        readonly CONTROL: "PlayAudio";
                                                    };
                                                };
                                            };
                                        };
                                        readonly Speaking: {
                                            readonly id: "Speaking";
                                            readonly initial: "Go";
                                            readonly on: {
                                                readonly STOP: {
                                                    readonly target: "Idle";
                                                };
                                                readonly TTS_STARTED: {
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "TTS_STARTED";
                                                        value?: AudioBufferSourceNode;
                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                };
                                                readonly VISEME: {
                                                    readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                        type: "VISEME";
                                                        value: any;
                                                    }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                                };
                                                readonly SPEAK_COMPLETE: {
                                                    readonly target: "Idle";
                                                };
                                            };
                                            readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                            readonly states: {
                                                readonly Go: {
                                                    readonly invoke: {
                                                        readonly src: "start";
                                                        readonly input: ({ context }: {
                                                            context: import("./types").TTSContext;
                                                            event: import("./types").TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            wsaTTS: SpeechSynthesis;
                                                            wsaUtt: {
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                prototype: SpeechSynthesisUtterance;
                                                            };
                                                            ttsLexicon: string;
                                                            voice: string;
                                                            visemes: boolean;
                                                            locale: string;
                                                            utterance: string;
                                                        };
                                                    };
                                                    readonly on: {
                                                        readonly CONTROL: "Paused";
                                                    };
                                                    readonly exit: "ttsStop";
                                                };
                                                readonly Paused: {
                                                    readonly on: {
                                                        readonly SPEAK_COMPLETE: {};
                                                        readonly CONTROL: "Go";
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                        readonly MaybeHandleNewTokens: {
                            readonly initial: "Choice";
                            readonly states: {
                                readonly Choice: {
                                    readonly always: readonly [{
                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                        readonly target: "Ponyfill";
                                    }, {
                                        readonly target: "NoPonyfill";
                                    }];
                                };
                                readonly NoPonyfill: {
                                    readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                        checkCache: {
                                            src: "checkCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudioFromCache: {
                                            src: "getAudioFromCache";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                cacheURL: string;
                                                utterance: string;
                                                voice: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        getAudio: {
                                            src: "getAudio";
                                            logic: import("xstate").PromiseActorLogic<any, {
                                                audioContext: AudioContext;
                                                audioURL: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        playAudio: {
                                            src: "playAudio";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                audioContext: AudioContext;
                                                audioBuffer: AudioBuffer;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<null, {
                                                utterance: string;
                                                voice: string;
                                                ttsLexicon: string;
                                                locale: string;
                                                wsaUtt: {
                                                    prototype: SpeechSynthesisUtterance;
                                                    new (text?: string): SpeechSynthesisUtterance;
                                                };
                                                wsaTTS: SpeechSynthesis;
                                                visemes?: boolean;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                                readonly Ponyfill: {
                                    readonly invoke: {
                                        readonly id: "ponyTTS";
                                        readonly src: "ponyfill";
                                        readonly input: ({ context }: {
                                            context: import("./types").TTSContext;
                                            event: import("./types").TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            azureAuthorizationToken: string;
                                            azureRegion: string;
                                            audioContext: AudioContext;
                                        };
                                    };
                                    readonly on: {
                                        readonly READY: {
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "READY";
                                                value: {
                                                    wsaTTS: SpeechSynthesis;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                };
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        };
                                        readonly NEW_TOKEN: {
                                            readonly target: "Ponyfill";
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "NEW_TOKEN";
                                                value: string;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                            readonly reenter: true;
                                        };
                                    };
                                };
                            };
                        };
                    };
                }>;
                id: string;
            } ? T_1 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_1["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_1["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                src: "asr";
                logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                        query: string;
                        locale: string;
                    }, import("xstate").EventObject>>;
                }, import("xstate").Values<{
                    maybe_ponyfill: {
                        src: "maybe_ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    nluPromise: {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, import("xstate").Values<{
                    raise_noinput_after_timeout: {
                        type: "raise_noinput_after_timeout";
                        params: {};
                    };
                    cancel_noinput_timeout: {
                        type: "cancel_noinput_timeout";
                        params: {};
                    };
                }>, {
                    type: "nlu_is_activated";
                    params: unknown;
                }, "noinputTimeout", "Ready" | "Fail" | {
                    Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                        Pausing: "Paused" | "WaitToPause" | "Continue";
                    };
                }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly id: "asr";
                    readonly context: ({ input }: {
                        spawn: {
                            <TSrc_1 extends "maybe_ponyfill" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                src: "maybe_ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_2 ? T_2 extends {
                                src: "maybe_ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } ? T_2 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_2["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_2["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_3 ? T_3 extends {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_3 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_3["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_3["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                maybe_ponyfill: {
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, "src", TSrc_1>["logic"]>;
                            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                id?: never;
                                systemId?: string;
                                input?: import("xstate").InputFrom<TLogic>;
                                syncSnapshot?: boolean;
                            }): import("xstate").ActorRefFromLogic<TLogic>;
                        };
                        input: import("./types").ASRInit;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                    }) => {
                        azureAuthorizationToken: string;
                        asrDefaultCompleteTimeout: number;
                        asrDefaultNoInputTimeout: number;
                        locale: string;
                        audioContext: AudioContext;
                        azureRegion: string;
                        azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                        speechRecognitionEndpointId: string;
                    };
                    readonly initial: "Ready";
                    readonly on: {
                        readonly NEW_TOKEN: {
                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "NEW_TOKEN";
                                value: string;
                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                maybe_ponyfill: {
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>;
                        };
                    };
                    readonly states: {
                        readonly Fail: {};
                        readonly Ready: {
                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                            readonly on: {
                                readonly START: {
                                    readonly target: "Recognising";
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "START";
                                        value?: RecogniseParameters;
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        maybe_ponyfill: {
                                            src: "maybe_ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                };
                            };
                        };
                        readonly Recognising: {
                            readonly onDone: "Ready";
                            readonly invoke: {
                                readonly id: "asr";
                                readonly src: "maybe_ponyfill";
                                readonly input: ({ context }: {
                                    context: import("./types").ASRContext;
                                    event: import("./types").ASREvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                }) => {
                                    azureRegion: string;
                                    audioContext: AudioContext;
                                    azureAuthorizationToken: string;
                                    locale: string;
                                    speechRecognitionEndpointId: string;
                                    completeTimeout: number;
                                    hints: string[];
                                };
                            };
                            readonly on: {
                                readonly FINAL_RESULT: readonly [{
                                    readonly target: ".NLURequest";
                                    readonly guard: {
                                        readonly type: "nlu_is_activated";
                                    };
                                }, {
                                    readonly target: ".WaitToStop";
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "FINAL_RESULT";
                                    }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                }];
                                readonly RESULT: {
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "RESULT";
                                        value: Hypothesis[];
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        maybe_ponyfill: {
                                            src: "maybe_ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                        type: "RESULT";
                                        value: Hypothesis[];
                                    }, undefined, import("./types").ASREvent>];
                                    readonly target: ".InterimResult";
                                };
                                readonly STOP: {
                                    readonly target: ".WaitToStop";
                                };
                                readonly CONTROL: {
                                    readonly target: ".Pausing";
                                };
                                readonly NOINPUT: {
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "NOINPUT";
                                    }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    readonly target: ".WaitToStop";
                                };
                            };
                            readonly initial: "WaitForRecogniser";
                            readonly states: {
                                readonly WaitForRecogniser: {
                                    readonly on: {
                                        readonly STARTED: {
                                            readonly target: "NoInput";
                                            readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                type: "STARTED";
                                                value: {
                                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                                };
                                            }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                        };
                                    };
                                };
                                readonly NoInput: {
                                    readonly entry: {
                                        readonly type: "raise_noinput_after_timeout";
                                    };
                                    readonly on: {
                                        readonly STARTSPEECH: {
                                            readonly target: "InProgress";
                                            readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                type: "STARTSPEECH";
                                            }, undefined, import("./types").ASREvent>;
                                        };
                                    };
                                    readonly exit: {
                                        readonly type: "cancel_noinput_timeout";
                                    };
                                };
                                readonly InProgress: {
                                    readonly entry: () => void;
                                };
                                readonly InterimResult: {
                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                };
                                readonly WaitToStop: {
                                    readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    readonly on: {
                                        readonly LISTEN_COMPLETE: {
                                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                type: "LISTEN_COMPLETE";
                                            }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                            readonly target: "Stopped";
                                        };
                                    };
                                };
                                readonly Pausing: {
                                    readonly onDone: "#asr.Recognising";
                                    readonly initial: "WaitToPause";
                                    readonly states: {
                                        readonly WaitToPause: {
                                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                            readonly on: {
                                                readonly LISTEN_COMPLETE: {
                                                    readonly target: "Paused";
                                                };
                                            };
                                        };
                                        readonly Paused: {
                                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Continue";
                                                };
                                            };
                                        };
                                        readonly Continue: {
                                            readonly type: "final";
                                        };
                                    };
                                };
                                readonly NLURequest: {
                                    readonly invoke: {
                                        readonly src: "nluPromise";
                                        readonly input: ({ context }: {
                                            context: import("./types").ASRContext;
                                            event: import("./types").ASREvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            endpoint: string;
                                            key: string;
                                            projectName: string;
                                            deploymentName: string;
                                            query: string;
                                            locale: string;
                                        };
                                        readonly onDone: readonly [{
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                            readonly target: "WaitToStop";
                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                        }, {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                            readonly target: "WaitToStop";
                                        }];
                                        readonly onError: {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                            readonly target: "WaitToStop";
                                        };
                                    };
                                };
                                readonly Stopped: {
                                    readonly type: "final";
                                };
                            };
                        };
                    };
                }>;
                id: string;
            } extends infer T_2 ? T_2 extends {
                src: "asr";
                logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                        query: string;
                        locale: string;
                    }, import("xstate").EventObject>>;
                }, import("xstate").Values<{
                    maybe_ponyfill: {
                        src: "maybe_ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    nluPromise: {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                            locale: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, import("xstate").Values<{
                    raise_noinput_after_timeout: {
                        type: "raise_noinput_after_timeout";
                        params: {};
                    };
                    cancel_noinput_timeout: {
                        type: "cancel_noinput_timeout";
                        params: {};
                    };
                }>, {
                    type: "nlu_is_activated";
                    params: unknown;
                }, "noinputTimeout", "Ready" | "Fail" | {
                    Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                        Pausing: "Paused" | "WaitToPause" | "Continue";
                    };
                }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly id: "asr";
                    readonly context: ({ input }: {
                        spawn: {
                            <TSrc_1 extends "maybe_ponyfill" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                src: "maybe_ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_3 ? T_3 extends {
                                src: "maybe_ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } ? T_3 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_3["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_3["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_4 ? T_4 extends {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                    locale: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_4 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_4["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_4["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                maybe_ponyfill: {
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, "src", TSrc_1>["logic"]>;
                            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                id?: never;
                                systemId?: string;
                                input?: import("xstate").InputFrom<TLogic>;
                                syncSnapshot?: boolean;
                            }): import("xstate").ActorRefFromLogic<TLogic>;
                        };
                        input: import("./types").ASRInit;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                    }) => {
                        azureAuthorizationToken: string;
                        asrDefaultCompleteTimeout: number;
                        asrDefaultNoInputTimeout: number;
                        locale: string;
                        audioContext: AudioContext;
                        azureRegion: string;
                        azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                        speechRecognitionEndpointId: string;
                    };
                    readonly initial: "Ready";
                    readonly on: {
                        readonly NEW_TOKEN: {
                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "NEW_TOKEN";
                                value: string;
                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                maybe_ponyfill: {
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>;
                        };
                    };
                    readonly states: {
                        readonly Fail: {};
                        readonly Ready: {
                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                            readonly on: {
                                readonly START: {
                                    readonly target: "Recognising";
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "START";
                                        value?: RecogniseParameters;
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        maybe_ponyfill: {
                                            src: "maybe_ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                };
                            };
                        };
                        readonly Recognising: {
                            readonly onDone: "Ready";
                            readonly invoke: {
                                readonly id: "asr";
                                readonly src: "maybe_ponyfill";
                                readonly input: ({ context }: {
                                    context: import("./types").ASRContext;
                                    event: import("./types").ASREvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                }) => {
                                    azureRegion: string;
                                    audioContext: AudioContext;
                                    azureAuthorizationToken: string;
                                    locale: string;
                                    speechRecognitionEndpointId: string;
                                    completeTimeout: number;
                                    hints: string[];
                                };
                            };
                            readonly on: {
                                readonly FINAL_RESULT: readonly [{
                                    readonly target: ".NLURequest";
                                    readonly guard: {
                                        readonly type: "nlu_is_activated";
                                    };
                                }, {
                                    readonly target: ".WaitToStop";
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "FINAL_RESULT";
                                    }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                }];
                                readonly RESULT: {
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "RESULT";
                                        value: Hypothesis[];
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        maybe_ponyfill: {
                                            src: "maybe_ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                                locale: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                        type: "RESULT";
                                        value: Hypothesis[];
                                    }, undefined, import("./types").ASREvent>];
                                    readonly target: ".InterimResult";
                                };
                                readonly STOP: {
                                    readonly target: ".WaitToStop";
                                };
                                readonly CONTROL: {
                                    readonly target: ".Pausing";
                                };
                                readonly NOINPUT: {
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "NOINPUT";
                                    }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    readonly target: ".WaitToStop";
                                };
                            };
                            readonly initial: "WaitForRecogniser";
                            readonly states: {
                                readonly WaitForRecogniser: {
                                    readonly on: {
                                        readonly STARTED: {
                                            readonly target: "NoInput";
                                            readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                type: "STARTED";
                                                value: {
                                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                                };
                                            }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                        };
                                    };
                                };
                                readonly NoInput: {
                                    readonly entry: {
                                        readonly type: "raise_noinput_after_timeout";
                                    };
                                    readonly on: {
                                        readonly STARTSPEECH: {
                                            readonly target: "InProgress";
                                            readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                type: "STARTSPEECH";
                                            }, undefined, import("./types").ASREvent>;
                                        };
                                    };
                                    readonly exit: {
                                        readonly type: "cancel_noinput_timeout";
                                    };
                                };
                                readonly InProgress: {
                                    readonly entry: () => void;
                                };
                                readonly InterimResult: {
                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                };
                                readonly WaitToStop: {
                                    readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    readonly on: {
                                        readonly LISTEN_COMPLETE: {
                                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                type: "LISTEN_COMPLETE";
                                            }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                            readonly target: "Stopped";
                                        };
                                    };
                                };
                                readonly Pausing: {
                                    readonly onDone: "#asr.Recognising";
                                    readonly initial: "WaitToPause";
                                    readonly states: {
                                        readonly WaitToPause: {
                                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                            readonly on: {
                                                readonly LISTEN_COMPLETE: {
                                                    readonly target: "Paused";
                                                };
                                            };
                                        };
                                        readonly Paused: {
                                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Continue";
                                                };
                                            };
                                        };
                                        readonly Continue: {
                                            readonly type: "final";
                                        };
                                    };
                                };
                                readonly NLURequest: {
                                    readonly invoke: {
                                        readonly src: "nluPromise";
                                        readonly input: ({ context }: {
                                            context: import("./types").ASRContext;
                                            event: import("./types").ASREvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            endpoint: string;
                                            key: string;
                                            projectName: string;
                                            deploymentName: string;
                                            query: string;
                                            locale: string;
                                        };
                                        readonly onDone: readonly [{
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                            readonly target: "WaitToStop";
                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                        }, {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                            readonly target: "WaitToStop";
                                        }];
                                        readonly onError: {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                            readonly target: "WaitToStop";
                                        };
                                    };
                                };
                                readonly Stopped: {
                                    readonly type: "final";
                                };
                            };
                        };
                    };
                }>;
                id: string;
            } ? T_2 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_2["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_2["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                src: "getToken";
                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                id: string;
            } extends infer T_3 ? T_3 extends {
                src: "getToken";
                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                id: string;
            } ? T_3 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_3["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_3["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                src: "visemes";
                logic: import("xstate").StateMachine<{
                    queue: number[];
                }, {
                    type: "VISEME";
                    value: any;
                }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly context: {
                        readonly queue: [];
                    };
                    readonly initial: "Init";
                    readonly states: {
                        readonly Init: {
                            readonly on: {
                                readonly VISEME: readonly [{
                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                        queue: number[];
                                    }, {
                                        type: "VISEME";
                                        value: any;
                                    }>) => boolean;
                                    readonly actions: readonly [import("xstate").ActionFunction<{
                                        queue: number[];
                                    }, {
                                        type: "VISEME";
                                        value: any;
                                    }, {
                                        type: "VISEME";
                                        value: any;
                                    }, undefined, never, never, never, never, never>];
                                }];
                            };
                        };
                    };
                }>;
                id: string;
            } extends infer T_4 ? T_4 extends {
                src: "visemes";
                logic: import("xstate").StateMachine<{
                    queue: number[];
                }, {
                    type: "VISEME";
                    value: any;
                }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly context: {
                        readonly queue: [];
                    };
                    readonly initial: "Init";
                    readonly states: {
                        readonly Init: {
                            readonly on: {
                                readonly VISEME: readonly [{
                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                        queue: number[];
                                    }, {
                                        type: "VISEME";
                                        value: any;
                                    }>) => boolean;
                                    readonly actions: readonly [import("xstate").ActionFunction<{
                                        queue: number[];
                                    }, {
                                        type: "VISEME";
                                        value: any;
                                    }, {
                                        type: "VISEME";
                                        value: any;
                                    }, undefined, never, never, never, never, never>];
                                }];
                            };
                        };
                    };
                }>;
                id: string;
            } ? T_4 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_4["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_4["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                audioContext: {
                    src: "audioContext";
                    logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                    id: string;
                };
                tts: {
                    src: "tts";
                    logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            audioURL: string;
                        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                            audioContext: AudioContext;
                            audioBuffer: AudioBuffer;
                        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                            utterance: string;
                            voice: string;
                            ttsLexicon: string;
                            locale: string;
                            wsaUtt: {
                                prototype: SpeechSynthesisUtterance;
                                new (text?: string): SpeechSynthesisUtterance;
                            };
                            wsaTTS: SpeechSynthesis;
                            visemes?: boolean;
                        }, import("xstate").EventObject>>;
                    }, import("xstate").Values<{
                        checkCache: {
                            src: "checkCache";
                            logic: import("xstate").PromiseActorLogic<any, {
                                cacheURL: string;
                                utterance: string;
                                voice: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        getAudioFromCache: {
                            src: "getAudioFromCache";
                            logic: import("xstate").PromiseActorLogic<any, {
                                audioContext: AudioContext;
                                cacheURL: string;
                                utterance: string;
                                voice: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        getAudio: {
                            src: "getAudio";
                            logic: import("xstate").PromiseActorLogic<any, {
                                audioContext: AudioContext;
                                audioURL: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        playAudio: {
                            src: "playAudio";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                audioContext: AudioContext;
                                audioBuffer: AudioBuffer;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<null, {
                                utterance: string;
                                voice: string;
                                ttsLexicon: string;
                                locale: string;
                                wsaUtt: {
                                    prototype: SpeechSynthesisUtterance;
                                    new (text?: string): SpeechSynthesisUtterance;
                                };
                                wsaTTS: SpeechSynthesis;
                                visemes?: boolean;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, import("xstate").Values<{
                        ttsStop: {
                            type: "ttsStop";
                            params: unknown;
                        };
                        addFiller: {
                            type: "addFiller";
                            params: {};
                        };
                        assignCurrentVoice: {
                            type: "assignCurrentVoice";
                            params: {};
                        };
                        assignCurrentLocale: {
                            type: "assignCurrentLocale";
                            params: {};
                        };
                        sendParentCurrentPersona: {
                            type: "sendParentCurrentPersona";
                            params: {};
                        };
                    }>, import("xstate").Values<{
                        bufferContainsUtterancePartReadyToBeSpoken: {
                            type: "bufferContainsUtterancePartReadyToBeSpoken";
                            params: unknown;
                        };
                        bufferIsNonEmpty: {
                            type: "bufferIsNonEmpty";
                            params: unknown;
                        };
                    }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
                        Operation: "NotReady" | {
                            Ready: "Idle" | {
                                BufferedSpeaker: {
                                    Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                                    Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                                        Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                            UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                                        };
                                    };
                                };
                            } | {
                                Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                            } | {
                                Speaking: "Go" | "Paused";
                            };
                        };
                        MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
                    }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly id: "tts";
                        readonly context: ({ input }: {
                            spawn: {
                                <TSrc_1 extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc_1, ...[options]: ({
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_5 ? T_5 extends {
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_5 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_5["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_5["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_6 ? T_6 extends {
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_6 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_6["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_6["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never) | ({
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_7 ? T_7 extends {
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_7 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_7["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_7["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_7 in import("xstate").RequiredActorOptions<T_7>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_7>>> : never : never : never) | ({
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_8 ? T_8 extends {
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_8 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_8["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_8["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_8 in import("xstate").RequiredActorOptions<T_8>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_8>>> : never : never : never) | ({
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_9 ? T_9 extends {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                } ? T_9 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_9["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_9["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_9 in import("xstate").RequiredActorOptions<T_9>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_9>>> : never : never : never) | ({
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_10 ? T_10 extends {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } ? T_10 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_10["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_10["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_10 in import("xstate").RequiredActorOptions<T_10>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_10>>> : never : never : never) | ({
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_11 ? T_11 extends {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_11 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_11["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_11["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_11 in import("xstate").RequiredActorOptions<T_11>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_11>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                    checkCache: {
                                        src: "checkCache";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            cacheURL: string;
                                            utterance: string;
                                            voice: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    getAudioFromCache: {
                                        src: "getAudioFromCache";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            audioContext: AudioContext;
                                            cacheURL: string;
                                            utterance: string;
                                            voice: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    getAudio: {
                                        src: "getAudio";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            audioContext: AudioContext;
                                            audioURL: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    playAudio: {
                                        src: "playAudio";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                            audioContext: AudioContext;
                                            audioBuffer: AudioBuffer;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<null, {
                                            utterance: string;
                                            voice: string;
                                            ttsLexicon: string;
                                            locale: string;
                                            wsaUtt: {
                                                prototype: SpeechSynthesisUtterance;
                                                new (text?: string): SpeechSynthesisUtterance;
                                            };
                                            wsaTTS: SpeechSynthesis;
                                            visemes?: boolean;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, "src", TSrc_1>["logic"]>;
                                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                    id?: never;
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<TLogic>;
                                    syncSnapshot?: boolean;
                                }): import("xstate").ActorRefFromLogic<TLogic>;
                            };
                            input: import("./types").TTSInit;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                        }) => {
                            azureAuthorizationToken: string;
                            ttsDefaultVoice: string;
                            ttsDefaultFillerDelay: number;
                            ttsDefaultFiller: string;
                            ttsLexicon: string;
                            audioContext: AudioContext;
                            azureRegion: string;
                            locale: string;
                            buffer: string;
                        };
                        readonly on: {
                            readonly ERROR: {
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "ERROR";
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                            };
                        };
                        readonly type: "parallel";
                        readonly states: {
                            readonly Operation: {
                                readonly initial: "NotReady";
                                readonly states: {
                                    readonly NotReady: {
                                        readonly on: {
                                            readonly READY: {
                                                readonly target: "Ready";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "READY";
                                                    value: {
                                                        wsaTTS: SpeechSynthesis;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                    };
                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                            };
                                        };
                                    };
                                    readonly Ready: {
                                        readonly initial: "Idle";
                                        readonly states: {
                                            readonly Idle: {
                                                readonly id: "Idle";
                                                readonly on: {
                                                    readonly SPEAK: readonly [{
                                                        readonly target: "BufferedSpeaker";
                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }>) => boolean;
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>;
                                                    }, {
                                                        readonly target: "Playing";
                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }>) => boolean;
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>;
                                                    }, {
                                                        readonly target: "Speaking";
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent>) => void];
                                                    }];
                                                };
                                            };
                                            readonly BufferedSpeaker: {
                                                readonly type: "parallel";
                                                readonly invoke: {
                                                    readonly id: "createEventsFromStream";
                                                    readonly src: "createEventsFromStream";
                                                    readonly input: ({ context }: {
                                                        context: import("./types").TTSContext;
                                                        event: import("./types").TTSEvent;
                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                    }) => Agenda;
                                                };
                                                readonly on: {
                                                    readonly STOP: {
                                                        readonly target: "Idle";
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Buffer: {
                                                        readonly initial: "BufferIdle";
                                                        readonly on: {
                                                            readonly STREAMING_SET_VOICE: {
                                                                readonly actions: "assignCurrentVoice";
                                                            };
                                                            readonly STREAMING_SET_LOCALE: {
                                                                readonly actions: "assignCurrentLocale";
                                                            };
                                                            readonly STREAMING_SET_PERSONA: {
                                                                readonly actions: "sendParentCurrentPersona";
                                                            };
                                                        };
                                                        readonly states: {
                                                            readonly BufferIdle: {
                                                                readonly id: "BufferIdle";
                                                                readonly on: {
                                                                    readonly STREAMING_CHUNK: {
                                                                        readonly target: "Buffering";
                                                                    };
                                                                    readonly STREAMING_DONE: "BufferingDone";
                                                                };
                                                            };
                                                            readonly Buffering: {
                                                                readonly id: "Buffering";
                                                                readonly on: {
                                                                    readonly STREAMING_CHUNK: {
                                                                        readonly target: "Buffering";
                                                                        readonly reenter: true;
                                                                    };
                                                                    readonly STREAMING_DONE: "BufferingDone";
                                                                };
                                                                readonly after: {
                                                                    readonly STREAMING_TIMEOUT: {
                                                                        readonly target: "BufferingDone";
                                                                        readonly actions: () => void;
                                                                    };
                                                                };
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly BufferingDone: {
                                                                readonly id: "BufferingDone";
                                                                readonly type: "final";
                                                            };
                                                        };
                                                    };
                                                    readonly Speaker: {
                                                        readonly initial: "SpeakingIdle";
                                                        readonly states: {
                                                            readonly SpeakingIdle: {
                                                                readonly id: "SpeakingIdle";
                                                                readonly always: readonly [{
                                                                    readonly target: "Speak";
                                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                        checkCache: {
                                                                            src: "checkCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudioFromCache: {
                                                                            src: "getAudioFromCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudio: {
                                                                            src: "getAudio";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                audioURL: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        playAudio: {
                                                                            src: "playAudio";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                audioContext: AudioContext;
                                                                                audioBuffer: AudioBuffer;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        createEventsFromStream: {
                                                                            src: "createEventsFromStream";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        ponyfill: {
                                                                            src: "ponyfill";
                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        start: {
                                                                            src: "start";
                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                utterance: string;
                                                                                voice: string;
                                                                                ttsLexicon: string;
                                                                                locale: string;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                                wsaTTS: SpeechSynthesis;
                                                                                visemes?: boolean;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                    }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                        checkCache: {
                                                                            src: "checkCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudioFromCache: {
                                                                            src: "getAudioFromCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudio: {
                                                                            src: "getAudio";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                audioURL: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        playAudio: {
                                                                            src: "playAudio";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                audioContext: AudioContext;
                                                                                audioBuffer: AudioBuffer;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        createEventsFromStream: {
                                                                            src: "createEventsFromStream";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        ponyfill: {
                                                                            src: "ponyfill";
                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        start: {
                                                                            src: "start";
                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                utterance: string;
                                                                                voice: string;
                                                                                ttsLexicon: string;
                                                                                locale: string;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                                wsaTTS: SpeechSynthesis;
                                                                                visemes?: boolean;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                    }>, never, never, never, never>];
                                                                }, {
                                                                    readonly target: "PrepareSpeech";
                                                                    readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                                }];
                                                                readonly after: {
                                                                    readonly FILLER_DELAY: {
                                                                        readonly target: "SpeakingIdle";
                                                                        readonly reenter: true;
                                                                        readonly actions: "addFiller";
                                                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                    };
                                                                };
                                                            };
                                                            readonly PrepareSpeech: {
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                                readonly always: readonly [{
                                                                    readonly target: "Speak";
                                                                }];
                                                            };
                                                            readonly Speak: {
                                                                readonly initial: "Init";
                                                                readonly states: {
                                                                    readonly Init: {
                                                                        readonly always: readonly [{
                                                                            readonly target: "CheckCache";
                                                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                        }, {
                                                                            readonly target: "Go";
                                                                        }];
                                                                    };
                                                                    readonly CheckCache: {
                                                                        readonly invoke: {
                                                                            readonly src: "checkCache";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => {
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            };
                                                                            readonly onError: "Go";
                                                                            readonly onDone: readonly [{
                                                                                readonly target: "UseCache";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                                readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                            }, {
                                                                                readonly target: "Go";
                                                                                readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                            }];
                                                                        };
                                                                    };
                                                                    readonly UseCache: {
                                                                        readonly initial: "GetAudio";
                                                                        readonly states: {
                                                                            readonly GetAudio: {
                                                                                readonly invoke: {
                                                                                    readonly src: "getAudioFromCache";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        cacheURL: string;
                                                                                        utterance: string;
                                                                                        voice: string;
                                                                                        locale: string;
                                                                                    };
                                                                                    readonly onDone: {
                                                                                        readonly target: "PlayAudio";
                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>;
                                                                                    };
                                                                                    readonly onError: "#TtsStreamGo";
                                                                                };
                                                                            };
                                                                            readonly PlayAudio: {
                                                                                readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                                readonly invoke: {
                                                                                    readonly src: "playAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioBuffer: AudioBuffer;
                                                                                        audioContext: AudioContext;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "PausedAudio";
                                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                                        readonly target: "#SpeakingDone";
                                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                            type: "SPEAK_COMPLETE";
                                                                                        }, unknown, any>;
                                                                                    }, {
                                                                                        readonly target: "#SpeakingIdle";
                                                                                    }];
                                                                                    readonly TTS_STARTED: {
                                                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                            type: "TTS_STARTED";
                                                                                            value?: AudioBufferSourceNode;
                                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                            type: "TTS_STARTED";
                                                                                            value?: AudioBufferSourceNode;
                                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                    };
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly PausedAudio: {
                                                                                readonly on: {
                                                                                    readonly CONTROL: "PlayAudio";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Go: {
                                                                        readonly id: "TtsStreamGo";
                                                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                        readonly invoke: {
                                                                            readonly src: "start";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                };
                                                                                ttsLexicon: string;
                                                                                visemes: boolean;
                                                                                voice: string;
                                                                                locale: string;
                                                                                utterance: string;
                                                                            };
                                                                        };
                                                                        readonly on: {
                                                                            readonly CONTROL: "Paused";
                                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                                readonly target: "#SpeakingDone";
                                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                    type: "SPEAK_COMPLETE";
                                                                                }, unknown, any>;
                                                                            }, {
                                                                                readonly target: "#SpeakingIdle";
                                                                            }];
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                        };
                                                                        readonly exit: "ttsStop";
                                                                    };
                                                                    readonly Paused: {
                                                                        readonly on: {
                                                                            readonly CONTROL: "Go";
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                            readonly SpeakingDone: {
                                                                readonly id: "SpeakingDone";
                                                                readonly type: "final";
                                                            };
                                                        };
                                                    };
                                                };
                                                readonly onDone: {
                                                    readonly target: "Idle";
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                };
                                            };
                                            readonly Playing: {
                                                readonly on: {
                                                    readonly SPEAK_COMPLETE: {
                                                        readonly target: "Idle";
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "SPEAK_COMPLETE";
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                    };
                                                    readonly TTS_STARTED: {
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "TTS_STARTED";
                                                            value?: AudioBufferSourceNode;
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "TTS_STARTED";
                                                            value?: AudioBufferSourceNode;
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                    };
                                                    readonly STOP: {
                                                        readonly target: "Idle";
                                                    };
                                                };
                                                readonly initial: "FetchAudio";
                                                readonly states: {
                                                    readonly FetchAudio: {
                                                        readonly invoke: {
                                                            readonly src: "getAudio";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            };
                                                            readonly onDone: {
                                                                readonly target: "PlayAudio";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>;
                                                            };
                                                            readonly onError: {
                                                                readonly target: "#Speaking";
                                                            };
                                                        };
                                                    };
                                                    readonly PlayAudio: {
                                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly invoke: {
                                                            readonly src: "playAudio";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly CONTROL: "AudioPaused";
                                                        };
                                                        readonly exit: "ttsStop";
                                                    };
                                                    readonly AudioPaused: {
                                                        readonly on: {
                                                            readonly CONTROL: "PlayAudio";
                                                        };
                                                    };
                                                };
                                            };
                                            readonly Speaking: {
                                                readonly id: "Speaking";
                                                readonly initial: "Go";
                                                readonly on: {
                                                    readonly STOP: {
                                                        readonly target: "Idle";
                                                    };
                                                    readonly TTS_STARTED: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "TTS_STARTED";
                                                            value?: AudioBufferSourceNode;
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                    };
                                                    readonly VISEME: {
                                                        readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                            type: "VISEME";
                                                            value: any;
                                                        }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                                    };
                                                    readonly SPEAK_COMPLETE: {
                                                        readonly target: "Idle";
                                                    };
                                                };
                                                readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                readonly states: {
                                                    readonly Go: {
                                                        readonly invoke: {
                                                            readonly src: "start";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                wsaTTS: SpeechSynthesis;
                                                                wsaUtt: {
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                    prototype: SpeechSynthesisUtterance;
                                                                };
                                                                ttsLexicon: string;
                                                                voice: string;
                                                                visemes: boolean;
                                                                locale: string;
                                                                utterance: string;
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly CONTROL: "Paused";
                                                        };
                                                        readonly exit: "ttsStop";
                                                    };
                                                    readonly Paused: {
                                                        readonly on: {
                                                            readonly SPEAK_COMPLETE: {};
                                                            readonly CONTROL: "Go";
                                                        };
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                            readonly MaybeHandleNewTokens: {
                                readonly initial: "Choice";
                                readonly states: {
                                    readonly Choice: {
                                        readonly always: readonly [{
                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                            readonly target: "Ponyfill";
                                        }, {
                                            readonly target: "NoPonyfill";
                                        }];
                                    };
                                    readonly NoPonyfill: {
                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            checkCache: {
                                                src: "checkCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudioFromCache: {
                                                src: "getAudioFromCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudio: {
                                                src: "getAudio";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            playAudio: {
                                                src: "playAudio";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    };
                                    readonly Ponyfill: {
                                        readonly invoke: {
                                            readonly id: "ponyTTS";
                                            readonly src: "ponyfill";
                                            readonly input: ({ context }: {
                                                context: import("./types").TTSContext;
                                                event: import("./types").TTSEvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                azureAuthorizationToken: string;
                                                azureRegion: string;
                                                audioContext: AudioContext;
                                            };
                                        };
                                        readonly on: {
                                            readonly READY: {
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "READY";
                                                    value: {
                                                        wsaTTS: SpeechSynthesis;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                    };
                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                            };
                                            readonly NEW_TOKEN: {
                                                readonly target: "Ponyfill";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "NEW_TOKEN";
                                                    value: string;
                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                                readonly reenter: true;
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    }>;
                    id: string;
                };
                asr: {
                    src: "asr";
                    logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                            locale: string;
                        }, import("xstate").EventObject>>;
                    }, import("xstate").Values<{
                        maybe_ponyfill: {
                            src: "maybe_ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                query: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, import("xstate").Values<{
                        raise_noinput_after_timeout: {
                            type: "raise_noinput_after_timeout";
                            params: {};
                        };
                        cancel_noinput_timeout: {
                            type: "cancel_noinput_timeout";
                            params: {};
                        };
                    }>, {
                        type: "nlu_is_activated";
                        params: unknown;
                    }, "noinputTimeout", "Ready" | "Fail" | {
                        Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                            Pausing: "Paused" | "WaitToPause" | "Continue";
                        };
                    }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly id: "asr";
                        readonly context: ({ input }: {
                            spawn: {
                                <TSrc_1 extends "maybe_ponyfill" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_5 ? T_5 extends {
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } ? T_5 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_5["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_5["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_6 ? T_6 extends {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_6 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_6["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_6["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                    maybe_ponyfill: {
                                        src: "maybe_ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, "src", TSrc_1>["logic"]>;
                                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                    id?: never;
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<TLogic>;
                                    syncSnapshot?: boolean;
                                }): import("xstate").ActorRefFromLogic<TLogic>;
                            };
                            input: import("./types").ASRInit;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                        }) => {
                            azureAuthorizationToken: string;
                            asrDefaultCompleteTimeout: number;
                            asrDefaultNoInputTimeout: number;
                            locale: string;
                            audioContext: AudioContext;
                            azureRegion: string;
                            azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                            speechRecognitionEndpointId: string;
                        };
                        readonly initial: "Ready";
                        readonly on: {
                            readonly NEW_TOKEN: {
                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "NEW_TOKEN";
                                    value: string;
                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                    maybe_ponyfill: {
                                        src: "maybe_ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>;
                            };
                        };
                        readonly states: {
                            readonly Fail: {};
                            readonly Ready: {
                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                readonly on: {
                                    readonly START: {
                                        readonly target: "Recognising";
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "START";
                                            value?: RecogniseParameters;
                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            maybe_ponyfill: {
                                                src: "maybe_ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>;
                                    };
                                };
                            };
                            readonly Recognising: {
                                readonly onDone: "Ready";
                                readonly invoke: {
                                    readonly id: "asr";
                                    readonly src: "maybe_ponyfill";
                                    readonly input: ({ context }: {
                                        context: import("./types").ASRContext;
                                        event: import("./types").ASREvent;
                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                    }) => {
                                        azureRegion: string;
                                        audioContext: AudioContext;
                                        azureAuthorizationToken: string;
                                        locale: string;
                                        speechRecognitionEndpointId: string;
                                        completeTimeout: number;
                                        hints: string[];
                                    };
                                };
                                readonly on: {
                                    readonly FINAL_RESULT: readonly [{
                                        readonly target: ".NLURequest";
                                        readonly guard: {
                                            readonly type: "nlu_is_activated";
                                        };
                                    }, {
                                        readonly target: ".WaitToStop";
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "FINAL_RESULT";
                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    }];
                                    readonly RESULT: {
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "RESULT";
                                            value: Hypothesis[];
                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            maybe_ponyfill: {
                                                src: "maybe_ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                            type: "RESULT";
                                            value: Hypothesis[];
                                        }, undefined, import("./types").ASREvent>];
                                        readonly target: ".InterimResult";
                                    };
                                    readonly STOP: {
                                        readonly target: ".WaitToStop";
                                    };
                                    readonly CONTROL: {
                                        readonly target: ".Pausing";
                                    };
                                    readonly NOINPUT: {
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "NOINPUT";
                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                        readonly target: ".WaitToStop";
                                    };
                                };
                                readonly initial: "WaitForRecogniser";
                                readonly states: {
                                    readonly WaitForRecogniser: {
                                        readonly on: {
                                            readonly STARTED: {
                                                readonly target: "NoInput";
                                                readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                    type: "STARTED";
                                                    value: {
                                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                                    };
                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                            };
                                        };
                                    };
                                    readonly NoInput: {
                                        readonly entry: {
                                            readonly type: "raise_noinput_after_timeout";
                                        };
                                        readonly on: {
                                            readonly STARTSPEECH: {
                                                readonly target: "InProgress";
                                                readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                    type: "STARTSPEECH";
                                                }, undefined, import("./types").ASREvent>;
                                            };
                                        };
                                        readonly exit: {
                                            readonly type: "cancel_noinput_timeout";
                                        };
                                    };
                                    readonly InProgress: {
                                        readonly entry: () => void;
                                    };
                                    readonly InterimResult: {
                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                    };
                                    readonly WaitToStop: {
                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                        readonly on: {
                                            readonly LISTEN_COMPLETE: {
                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                    type: "LISTEN_COMPLETE";
                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                readonly target: "Stopped";
                                            };
                                        };
                                    };
                                    readonly Pausing: {
                                        readonly onDone: "#asr.Recognising";
                                        readonly initial: "WaitToPause";
                                        readonly states: {
                                            readonly WaitToPause: {
                                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                readonly on: {
                                                    readonly LISTEN_COMPLETE: {
                                                        readonly target: "Paused";
                                                    };
                                                };
                                            };
                                            readonly Paused: {
                                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                readonly on: {
                                                    readonly CONTROL: {
                                                        readonly target: "Continue";
                                                    };
                                                };
                                            };
                                            readonly Continue: {
                                                readonly type: "final";
                                            };
                                        };
                                    };
                                    readonly NLURequest: {
                                        readonly invoke: {
                                            readonly src: "nluPromise";
                                            readonly input: ({ context }: {
                                                context: import("./types").ASRContext;
                                                event: import("./types").ASREvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                endpoint: string;
                                                key: string;
                                                projectName: string;
                                                deploymentName: string;
                                                query: string;
                                                locale: string;
                                            };
                                            readonly onDone: readonly [{
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                readonly target: "WaitToStop";
                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                            }, {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                readonly target: "WaitToStop";
                                            }];
                                            readonly onError: {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                readonly target: "WaitToStop";
                                            };
                                        };
                                    };
                                    readonly Stopped: {
                                        readonly type: "final";
                                    };
                                };
                            };
                        };
                    }>;
                    id: string;
                };
                getToken: {
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                };
                visemes: {
                    src: "visemes";
                    logic: import("xstate").StateMachine<{
                        queue: number[];
                    }, {
                        type: "VISEME";
                        value: any;
                    }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly context: {
                            readonly queue: [];
                        };
                        readonly initial: "Init";
                        readonly states: {
                            readonly Init: {
                                readonly on: {
                                    readonly VISEME: readonly [{
                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                            queue: number[];
                                        }, {
                                            type: "VISEME";
                                            value: any;
                                        }>) => boolean;
                                        readonly actions: readonly [import("xstate").ActionFunction<{
                                            queue: number[];
                                        }, {
                                            type: "VISEME";
                                            value: any;
                                        }, {
                                            type: "VISEME";
                                            value: any;
                                        }, undefined, never, never, never, never, never>];
                                    }];
                                };
                            };
                        };
                    }>;
                    id: string;
                };
            }>, "src", TSrc>["logic"]>;
            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                id?: never;
                systemId?: string;
                input?: import("xstate").InputFrom<TLogic>;
                syncSnapshot?: boolean;
            }): import("xstate").ActorRefFromLogic<TLogic>;
        };
        input: Settings;
        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<SSContext, SpeechStateEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, SpeechStateEvent, import("xstate").AnyEventObject>;
    }) => {
        settings: Settings;
    };
    readonly id: "speechstate";
    readonly initial: "Active";
    readonly states: {
        readonly Stopped: {
            readonly meta: {
                readonly view: "stopped";
            };
            readonly entry: readonly [import("xstate").StopAction<SSContext, SpeechStateEvent, undefined, SpeechStateEvent>, import("xstate").StopAction<SSContext, SpeechStateEvent, undefined, SpeechStateEvent>, import("xstate").ActionFunction<SSContext, SpeechStateEvent, SpeechStateEvent, undefined, import("xstate").Values<{
                audioContext: {
                    src: "audioContext";
                    logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                    id: string;
                };
                tts: {
                    src: "tts";
                    logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            cacheURL: string;
                            utterance: string;
                            voice: string;
                            locale: string;
                        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                            audioContext: AudioContext;
                            audioURL: string;
                        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                            audioContext: AudioContext;
                            audioBuffer: AudioBuffer;
                        }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                            utterance: string;
                            voice: string;
                            ttsLexicon: string;
                            locale: string;
                            wsaUtt: {
                                prototype: SpeechSynthesisUtterance;
                                new (text?: string): SpeechSynthesisUtterance;
                            };
                            wsaTTS: SpeechSynthesis;
                            visemes?: boolean;
                        }, import("xstate").EventObject>>;
                    }, import("xstate").Values<{
                        checkCache: {
                            src: "checkCache";
                            logic: import("xstate").PromiseActorLogic<any, {
                                cacheURL: string;
                                utterance: string;
                                voice: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        getAudioFromCache: {
                            src: "getAudioFromCache";
                            logic: import("xstate").PromiseActorLogic<any, {
                                audioContext: AudioContext;
                                cacheURL: string;
                                utterance: string;
                                voice: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        getAudio: {
                            src: "getAudio";
                            logic: import("xstate").PromiseActorLogic<any, {
                                audioContext: AudioContext;
                                audioURL: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        playAudio: {
                            src: "playAudio";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                audioContext: AudioContext;
                                audioBuffer: AudioBuffer;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<null, {
                                utterance: string;
                                voice: string;
                                ttsLexicon: string;
                                locale: string;
                                wsaUtt: {
                                    prototype: SpeechSynthesisUtterance;
                                    new (text?: string): SpeechSynthesisUtterance;
                                };
                                wsaTTS: SpeechSynthesis;
                                visemes?: boolean;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, import("xstate").Values<{
                        ttsStop: {
                            type: "ttsStop";
                            params: unknown;
                        };
                        addFiller: {
                            type: "addFiller";
                            params: {};
                        };
                        assignCurrentVoice: {
                            type: "assignCurrentVoice";
                            params: {};
                        };
                        assignCurrentLocale: {
                            type: "assignCurrentLocale";
                            params: {};
                        };
                        sendParentCurrentPersona: {
                            type: "sendParentCurrentPersona";
                            params: {};
                        };
                    }>, import("xstate").Values<{
                        bufferContainsUtterancePartReadyToBeSpoken: {
                            type: "bufferContainsUtterancePartReadyToBeSpoken";
                            params: unknown;
                        };
                        bufferIsNonEmpty: {
                            type: "bufferIsNonEmpty";
                            params: unknown;
                        };
                    }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
                        Operation: "NotReady" | {
                            Ready: "Idle" | {
                                BufferedSpeaker: {
                                    Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                                    Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                                        Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                            UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                                        };
                                    };
                                };
                            } | {
                                Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                            } | {
                                Speaking: "Go" | "Paused";
                            };
                        };
                        MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
                    }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly id: "tts";
                        readonly context: ({ input }: {
                            spawn: {
                                <TSrc extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T ? T extends {
                                    src: "checkCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_1 ? T_1 extends {
                                    src: "getAudioFromCache";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        cacheURL: string;
                                        utterance: string;
                                        voice: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_1 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_1["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_1["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_2 ? T_2 extends {
                                    src: "getAudio";
                                    logic: import("xstate").PromiseActorLogic<any, {
                                        audioContext: AudioContext;
                                        audioURL: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_2 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_2["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_2["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_3 ? T_3 extends {
                                    src: "playAudio";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                        audioContext: AudioContext;
                                        audioBuffer: AudioBuffer;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_3 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_3["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_3["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_4 ? T_4 extends {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                } ? T_4 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_4["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_4["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_5 ? T_5 extends {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } ? T_5 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_5["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_5["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_6 ? T_6 extends {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<null, {
                                        utterance: string;
                                        voice: string;
                                        ttsLexicon: string;
                                        locale: string;
                                        wsaUtt: {
                                            prototype: SpeechSynthesisUtterance;
                                            new (text?: string): SpeechSynthesisUtterance;
                                        };
                                        wsaTTS: SpeechSynthesis;
                                        visemes?: boolean;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_6 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_6["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_6["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                    checkCache: {
                                        src: "checkCache";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            cacheURL: string;
                                            utterance: string;
                                            voice: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    getAudioFromCache: {
                                        src: "getAudioFromCache";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            audioContext: AudioContext;
                                            cacheURL: string;
                                            utterance: string;
                                            voice: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    getAudio: {
                                        src: "getAudio";
                                        logic: import("xstate").PromiseActorLogic<any, {
                                            audioContext: AudioContext;
                                            audioURL: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    playAudio: {
                                        src: "playAudio";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                            audioContext: AudioContext;
                                            audioBuffer: AudioBuffer;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<null, {
                                            utterance: string;
                                            voice: string;
                                            ttsLexicon: string;
                                            locale: string;
                                            wsaUtt: {
                                                prototype: SpeechSynthesisUtterance;
                                                new (text?: string): SpeechSynthesisUtterance;
                                            };
                                            wsaTTS: SpeechSynthesis;
                                            visemes?: boolean;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, "src", TSrc>["logic"]>;
                                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                    id?: never;
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<TLogic>;
                                    syncSnapshot?: boolean;
                                }): import("xstate").ActorRefFromLogic<TLogic>;
                            };
                            input: import("./types").TTSInit;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                        }) => {
                            azureAuthorizationToken: string;
                            ttsDefaultVoice: string;
                            ttsDefaultFillerDelay: number;
                            ttsDefaultFiller: string;
                            ttsLexicon: string;
                            audioContext: AudioContext;
                            azureRegion: string;
                            locale: string;
                            buffer: string;
                        };
                        readonly on: {
                            readonly ERROR: {
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "ERROR";
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                            };
                        };
                        readonly type: "parallel";
                        readonly states: {
                            readonly Operation: {
                                readonly initial: "NotReady";
                                readonly states: {
                                    readonly NotReady: {
                                        readonly on: {
                                            readonly READY: {
                                                readonly target: "Ready";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "READY";
                                                    value: {
                                                        wsaTTS: SpeechSynthesis;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                    };
                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                            };
                                        };
                                    };
                                    readonly Ready: {
                                        readonly initial: "Idle";
                                        readonly states: {
                                            readonly Idle: {
                                                readonly id: "Idle";
                                                readonly on: {
                                                    readonly SPEAK: readonly [{
                                                        readonly target: "BufferedSpeaker";
                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }>) => boolean;
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>;
                                                    }, {
                                                        readonly target: "Playing";
                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }>) => boolean;
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>;
                                                    }, {
                                                        readonly target: "Speaking";
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                            type: "SPEAK";
                                                            value: Agenda;
                                                        }, import("./types").TTSEvent>) => void];
                                                    }];
                                                };
                                            };
                                            readonly BufferedSpeaker: {
                                                readonly type: "parallel";
                                                readonly invoke: {
                                                    readonly id: "createEventsFromStream";
                                                    readonly src: "createEventsFromStream";
                                                    readonly input: ({ context }: {
                                                        context: import("./types").TTSContext;
                                                        event: import("./types").TTSEvent;
                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                    }) => Agenda;
                                                };
                                                readonly on: {
                                                    readonly STOP: {
                                                        readonly target: "Idle";
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Buffer: {
                                                        readonly initial: "BufferIdle";
                                                        readonly on: {
                                                            readonly STREAMING_SET_VOICE: {
                                                                readonly actions: "assignCurrentVoice";
                                                            };
                                                            readonly STREAMING_SET_LOCALE: {
                                                                readonly actions: "assignCurrentLocale";
                                                            };
                                                            readonly STREAMING_SET_PERSONA: {
                                                                readonly actions: "sendParentCurrentPersona";
                                                            };
                                                        };
                                                        readonly states: {
                                                            readonly BufferIdle: {
                                                                readonly id: "BufferIdle";
                                                                readonly on: {
                                                                    readonly STREAMING_CHUNK: {
                                                                        readonly target: "Buffering";
                                                                    };
                                                                    readonly STREAMING_DONE: "BufferingDone";
                                                                };
                                                            };
                                                            readonly Buffering: {
                                                                readonly id: "Buffering";
                                                                readonly on: {
                                                                    readonly STREAMING_CHUNK: {
                                                                        readonly target: "Buffering";
                                                                        readonly reenter: true;
                                                                    };
                                                                    readonly STREAMING_DONE: "BufferingDone";
                                                                };
                                                                readonly after: {
                                                                    readonly STREAMING_TIMEOUT: {
                                                                        readonly target: "BufferingDone";
                                                                        readonly actions: () => void;
                                                                    };
                                                                };
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly BufferingDone: {
                                                                readonly id: "BufferingDone";
                                                                readonly type: "final";
                                                            };
                                                        };
                                                    };
                                                    readonly Speaker: {
                                                        readonly initial: "SpeakingIdle";
                                                        readonly states: {
                                                            readonly SpeakingIdle: {
                                                                readonly id: "SpeakingIdle";
                                                                readonly always: readonly [{
                                                                    readonly target: "Speak";
                                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                        checkCache: {
                                                                            src: "checkCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudioFromCache: {
                                                                            src: "getAudioFromCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudio: {
                                                                            src: "getAudio";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                audioURL: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        playAudio: {
                                                                            src: "playAudio";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                audioContext: AudioContext;
                                                                                audioBuffer: AudioBuffer;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        createEventsFromStream: {
                                                                            src: "createEventsFromStream";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        ponyfill: {
                                                                            src: "ponyfill";
                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        start: {
                                                                            src: "start";
                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                utterance: string;
                                                                                voice: string;
                                                                                ttsLexicon: string;
                                                                                locale: string;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                                wsaTTS: SpeechSynthesis;
                                                                                visemes?: boolean;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                    }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                        checkCache: {
                                                                            src: "checkCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudioFromCache: {
                                                                            src: "getAudioFromCache";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        getAudio: {
                                                                            src: "getAudio";
                                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                                audioContext: AudioContext;
                                                                                audioURL: string;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        playAudio: {
                                                                            src: "playAudio";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                audioContext: AudioContext;
                                                                                audioBuffer: AudioBuffer;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        createEventsFromStream: {
                                                                            src: "createEventsFromStream";
                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        ponyfill: {
                                                                            src: "ponyfill";
                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                        start: {
                                                                            src: "start";
                                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                                utterance: string;
                                                                                voice: string;
                                                                                ttsLexicon: string;
                                                                                locale: string;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                                wsaTTS: SpeechSynthesis;
                                                                                visemes?: boolean;
                                                                            }, import("xstate").EventObject>;
                                                                            id: string;
                                                                        };
                                                                    }>, never, never, never, never>];
                                                                }, {
                                                                    readonly target: "PrepareSpeech";
                                                                    readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                                }];
                                                                readonly after: {
                                                                    readonly FILLER_DELAY: {
                                                                        readonly target: "SpeakingIdle";
                                                                        readonly reenter: true;
                                                                        readonly actions: "addFiller";
                                                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                    };
                                                                };
                                                            };
                                                            readonly PrepareSpeech: {
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                                readonly always: readonly [{
                                                                    readonly target: "Speak";
                                                                }];
                                                            };
                                                            readonly Speak: {
                                                                readonly initial: "Init";
                                                                readonly states: {
                                                                    readonly Init: {
                                                                        readonly always: readonly [{
                                                                            readonly target: "CheckCache";
                                                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                        }, {
                                                                            readonly target: "Go";
                                                                        }];
                                                                    };
                                                                    readonly CheckCache: {
                                                                        readonly invoke: {
                                                                            readonly src: "checkCache";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => {
                                                                                cacheURL: string;
                                                                                utterance: string;
                                                                                voice: string;
                                                                                locale: string;
                                                                            };
                                                                            readonly onError: "Go";
                                                                            readonly onDone: readonly [{
                                                                                readonly target: "UseCache";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                                readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                            }, {
                                                                                readonly target: "Go";
                                                                                readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                            }];
                                                                        };
                                                                    };
                                                                    readonly UseCache: {
                                                                        readonly initial: "GetAudio";
                                                                        readonly states: {
                                                                            readonly GetAudio: {
                                                                                readonly invoke: {
                                                                                    readonly src: "getAudioFromCache";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        cacheURL: string;
                                                                                        utterance: string;
                                                                                        voice: string;
                                                                                        locale: string;
                                                                                    };
                                                                                    readonly onDone: {
                                                                                        readonly target: "PlayAudio";
                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>;
                                                                                    };
                                                                                    readonly onError: "#TtsStreamGo";
                                                                                };
                                                                            };
                                                                            readonly PlayAudio: {
                                                                                readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                                readonly invoke: {
                                                                                    readonly src: "playAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioBuffer: AudioBuffer;
                                                                                        audioContext: AudioContext;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "PausedAudio";
                                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                                        readonly target: "#SpeakingDone";
                                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                            type: "SPEAK_COMPLETE";
                                                                                        }, unknown, any>;
                                                                                    }, {
                                                                                        readonly target: "#SpeakingIdle";
                                                                                    }];
                                                                                    readonly TTS_STARTED: {
                                                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                            type: "TTS_STARTED";
                                                                                            value?: AudioBufferSourceNode;
                                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                            type: "TTS_STARTED";
                                                                                            value?: AudioBufferSourceNode;
                                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                    };
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly PausedAudio: {
                                                                                readonly on: {
                                                                                    readonly CONTROL: "PlayAudio";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Go: {
                                                                        readonly id: "TtsStreamGo";
                                                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                        readonly invoke: {
                                                                            readonly src: "start";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                };
                                                                                ttsLexicon: string;
                                                                                visemes: boolean;
                                                                                voice: string;
                                                                                locale: string;
                                                                                utterance: string;
                                                                            };
                                                                        };
                                                                        readonly on: {
                                                                            readonly CONTROL: "Paused";
                                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                                readonly target: "#SpeakingDone";
                                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                    type: "SPEAK_COMPLETE";
                                                                                }, unknown, any>;
                                                                            }, {
                                                                                readonly target: "#SpeakingIdle";
                                                                            }];
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                        };
                                                                        readonly exit: "ttsStop";
                                                                    };
                                                                    readonly Paused: {
                                                                        readonly on: {
                                                                            readonly CONTROL: "Go";
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                            readonly SpeakingDone: {
                                                                readonly id: "SpeakingDone";
                                                                readonly type: "final";
                                                            };
                                                        };
                                                    };
                                                };
                                                readonly onDone: {
                                                    readonly target: "Idle";
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                };
                                            };
                                            readonly Playing: {
                                                readonly on: {
                                                    readonly SPEAK_COMPLETE: {
                                                        readonly target: "Idle";
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "SPEAK_COMPLETE";
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                    };
                                                    readonly TTS_STARTED: {
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "TTS_STARTED";
                                                            value?: AudioBufferSourceNode;
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "TTS_STARTED";
                                                            value?: AudioBufferSourceNode;
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                    };
                                                    readonly STOP: {
                                                        readonly target: "Idle";
                                                    };
                                                };
                                                readonly initial: "FetchAudio";
                                                readonly states: {
                                                    readonly FetchAudio: {
                                                        readonly invoke: {
                                                            readonly src: "getAudio";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            };
                                                            readonly onDone: {
                                                                readonly target: "PlayAudio";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>;
                                                            };
                                                            readonly onError: {
                                                                readonly target: "#Speaking";
                                                            };
                                                        };
                                                    };
                                                    readonly PlayAudio: {
                                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly invoke: {
                                                            readonly src: "playAudio";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly CONTROL: "AudioPaused";
                                                        };
                                                        readonly exit: "ttsStop";
                                                    };
                                                    readonly AudioPaused: {
                                                        readonly on: {
                                                            readonly CONTROL: "PlayAudio";
                                                        };
                                                    };
                                                };
                                            };
                                            readonly Speaking: {
                                                readonly id: "Speaking";
                                                readonly initial: "Go";
                                                readonly on: {
                                                    readonly STOP: {
                                                        readonly target: "Idle";
                                                    };
                                                    readonly TTS_STARTED: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "TTS_STARTED";
                                                            value?: AudioBufferSourceNode;
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                    };
                                                    readonly VISEME: {
                                                        readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                            type: "VISEME";
                                                            value: any;
                                                        }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                                    };
                                                    readonly SPEAK_COMPLETE: {
                                                        readonly target: "Idle";
                                                    };
                                                };
                                                readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                readonly states: {
                                                    readonly Go: {
                                                        readonly invoke: {
                                                            readonly src: "start";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                wsaTTS: SpeechSynthesis;
                                                                wsaUtt: {
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                    prototype: SpeechSynthesisUtterance;
                                                                };
                                                                ttsLexicon: string;
                                                                voice: string;
                                                                visemes: boolean;
                                                                locale: string;
                                                                utterance: string;
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly CONTROL: "Paused";
                                                        };
                                                        readonly exit: "ttsStop";
                                                    };
                                                    readonly Paused: {
                                                        readonly on: {
                                                            readonly SPEAK_COMPLETE: {};
                                                            readonly CONTROL: "Go";
                                                        };
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                            readonly MaybeHandleNewTokens: {
                                readonly initial: "Choice";
                                readonly states: {
                                    readonly Choice: {
                                        readonly always: readonly [{
                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                            readonly target: "Ponyfill";
                                        }, {
                                            readonly target: "NoPonyfill";
                                        }];
                                    };
                                    readonly NoPonyfill: {
                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            checkCache: {
                                                src: "checkCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudioFromCache: {
                                                src: "getAudioFromCache";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            getAudio: {
                                                src: "getAudio";
                                                logic: import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            playAudio: {
                                                src: "playAudio";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    };
                                    readonly Ponyfill: {
                                        readonly invoke: {
                                            readonly id: "ponyTTS";
                                            readonly src: "ponyfill";
                                            readonly input: ({ context }: {
                                                context: import("./types").TTSContext;
                                                event: import("./types").TTSEvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                azureAuthorizationToken: string;
                                                azureRegion: string;
                                                audioContext: AudioContext;
                                            };
                                        };
                                        readonly on: {
                                            readonly READY: {
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "READY";
                                                    value: {
                                                        wsaTTS: SpeechSynthesis;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                    };
                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                            };
                                            readonly NEW_TOKEN: {
                                                readonly target: "Ponyfill";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "NEW_TOKEN";
                                                    value: string;
                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    checkCache: {
                                                        src: "checkCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudioFromCache: {
                                                        src: "getAudioFromCache";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            cacheURL: string;
                                                            utterance: string;
                                                            voice: string;
                                                            locale: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    getAudio: {
                                                        src: "getAudio";
                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                            audioContext: AudioContext;
                                                            audioURL: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    playAudio: {
                                                        src: "playAudio";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                            audioContext: AudioContext;
                                                            audioBuffer: AudioBuffer;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                            utterance: string;
                                                            voice: string;
                                                            ttsLexicon: string;
                                                            locale: string;
                                                            wsaUtt: {
                                                                prototype: SpeechSynthesisUtterance;
                                                                new (text?: string): SpeechSynthesisUtterance;
                                                            };
                                                            wsaTTS: SpeechSynthesis;
                                                            visemes?: boolean;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                                readonly reenter: true;
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    }>;
                    id: string;
                };
                asr: {
                    src: "asr";
                    logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                            locale: string;
                        }, import("xstate").EventObject>>;
                    }, import("xstate").Values<{
                        maybe_ponyfill: {
                            src: "maybe_ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                query: string;
                                locale: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, import("xstate").Values<{
                        raise_noinput_after_timeout: {
                            type: "raise_noinput_after_timeout";
                            params: {};
                        };
                        cancel_noinput_timeout: {
                            type: "cancel_noinput_timeout";
                            params: {};
                        };
                    }>, {
                        type: "nlu_is_activated";
                        params: unknown;
                    }, "noinputTimeout", "Ready" | "Fail" | {
                        Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                            Pausing: "Paused" | "WaitToPause" | "Continue";
                        };
                    }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly id: "asr";
                        readonly context: ({ input }: {
                            spawn: {
                                <TSrc extends "maybe_ponyfill" | "nluPromise">(logic: TSrc, ...[options]: ({
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T ? T extends {
                                    src: "maybe_ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } ? T extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_1 ? T_1 extends {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                        locale: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_1 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_1["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_1["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                    maybe_ponyfill: {
                                        src: "maybe_ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, "src", TSrc>["logic"]>;
                                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                    id?: never;
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<TLogic>;
                                    syncSnapshot?: boolean;
                                }): import("xstate").ActorRefFromLogic<TLogic>;
                            };
                            input: import("./types").ASRInit;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                        }) => {
                            azureAuthorizationToken: string;
                            asrDefaultCompleteTimeout: number;
                            asrDefaultNoInputTimeout: number;
                            locale: string;
                            audioContext: AudioContext;
                            azureRegion: string;
                            azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                            speechRecognitionEndpointId: string;
                        };
                        readonly initial: "Ready";
                        readonly on: {
                            readonly NEW_TOKEN: {
                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "NEW_TOKEN";
                                    value: string;
                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                    maybe_ponyfill: {
                                        src: "maybe_ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                            locale: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>;
                            };
                        };
                        readonly states: {
                            readonly Fail: {};
                            readonly Ready: {
                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                readonly on: {
                                    readonly START: {
                                        readonly target: "Recognising";
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "START";
                                            value?: RecogniseParameters;
                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            maybe_ponyfill: {
                                                src: "maybe_ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>;
                                    };
                                };
                            };
                            readonly Recognising: {
                                readonly onDone: "Ready";
                                readonly invoke: {
                                    readonly id: "asr";
                                    readonly src: "maybe_ponyfill";
                                    readonly input: ({ context }: {
                                        context: import("./types").ASRContext;
                                        event: import("./types").ASREvent;
                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                    }) => {
                                        azureRegion: string;
                                        audioContext: AudioContext;
                                        azureAuthorizationToken: string;
                                        locale: string;
                                        speechRecognitionEndpointId: string;
                                        completeTimeout: number;
                                        hints: string[];
                                    };
                                };
                                readonly on: {
                                    readonly FINAL_RESULT: readonly [{
                                        readonly target: ".NLURequest";
                                        readonly guard: {
                                            readonly type: "nlu_is_activated";
                                        };
                                    }, {
                                        readonly target: ".WaitToStop";
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "FINAL_RESULT";
                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                    }];
                                    readonly RESULT: {
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "RESULT";
                                            value: Hypothesis[];
                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            maybe_ponyfill: {
                                                src: "maybe_ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                            type: "RESULT";
                                            value: Hypothesis[];
                                        }, undefined, import("./types").ASREvent>];
                                        readonly target: ".InterimResult";
                                    };
                                    readonly STOP: {
                                        readonly target: ".WaitToStop";
                                    };
                                    readonly CONTROL: {
                                        readonly target: ".Pausing";
                                    };
                                    readonly NOINPUT: {
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "NOINPUT";
                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                        readonly target: ".WaitToStop";
                                    };
                                };
                                readonly initial: "WaitForRecogniser";
                                readonly states: {
                                    readonly WaitForRecogniser: {
                                        readonly on: {
                                            readonly STARTED: {
                                                readonly target: "NoInput";
                                                readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                    type: "STARTED";
                                                    value: {
                                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                                    };
                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                            };
                                        };
                                    };
                                    readonly NoInput: {
                                        readonly entry: {
                                            readonly type: "raise_noinput_after_timeout";
                                        };
                                        readonly on: {
                                            readonly STARTSPEECH: {
                                                readonly target: "InProgress";
                                                readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                    type: "STARTSPEECH";
                                                }, undefined, import("./types").ASREvent>;
                                            };
                                        };
                                        readonly exit: {
                                            readonly type: "cancel_noinput_timeout";
                                        };
                                    };
                                    readonly InProgress: {
                                        readonly entry: () => void;
                                    };
                                    readonly InterimResult: {
                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                    };
                                    readonly WaitToStop: {
                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                        readonly on: {
                                            readonly LISTEN_COMPLETE: {
                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                    type: "LISTEN_COMPLETE";
                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                readonly target: "Stopped";
                                            };
                                        };
                                    };
                                    readonly Pausing: {
                                        readonly onDone: "#asr.Recognising";
                                        readonly initial: "WaitToPause";
                                        readonly states: {
                                            readonly WaitToPause: {
                                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                readonly on: {
                                                    readonly LISTEN_COMPLETE: {
                                                        readonly target: "Paused";
                                                    };
                                                };
                                            };
                                            readonly Paused: {
                                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                readonly on: {
                                                    readonly CONTROL: {
                                                        readonly target: "Continue";
                                                    };
                                                };
                                            };
                                            readonly Continue: {
                                                readonly type: "final";
                                            };
                                        };
                                    };
                                    readonly NLURequest: {
                                        readonly invoke: {
                                            readonly src: "nluPromise";
                                            readonly input: ({ context }: {
                                                context: import("./types").ASRContext;
                                                event: import("./types").ASREvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                endpoint: string;
                                                key: string;
                                                projectName: string;
                                                deploymentName: string;
                                                query: string;
                                                locale: string;
                                            };
                                            readonly onDone: readonly [{
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                readonly target: "WaitToStop";
                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                            }, {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                readonly target: "WaitToStop";
                                            }];
                                            readonly onError: {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                readonly target: "WaitToStop";
                                            };
                                        };
                                    };
                                    readonly Stopped: {
                                        readonly type: "final";
                                    };
                                };
                            };
                        };
                    }>;
                    id: string;
                };
                getToken: {
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                };
                visemes: {
                    src: "visemes";
                    logic: import("xstate").StateMachine<{
                        queue: number[];
                    }, {
                        type: "VISEME";
                        value: any;
                    }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly context: {
                            readonly queue: [];
                        };
                        readonly initial: "Init";
                        readonly states: {
                            readonly Init: {
                                readonly on: {
                                    readonly VISEME: readonly [{
                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                            queue: number[];
                                        }, {
                                            type: "VISEME";
                                            value: any;
                                        }>) => boolean;
                                        readonly actions: readonly [import("xstate").ActionFunction<{
                                            queue: number[];
                                        }, {
                                            type: "VISEME";
                                            value: any;
                                        }, {
                                            type: "VISEME";
                                            value: any;
                                        }, undefined, never, never, never, never, never>];
                                    }];
                                };
                            };
                        };
                    }>;
                    id: string;
                };
            }>, never, never, never, never>, () => void];
        };
        readonly Active: {
            readonly type: "parallel";
            readonly states: {
                readonly AsrTtsSpawner: {
                    readonly initial: "Idle";
                    readonly states: {
                        readonly Idle: {
                            readonly on: {
                                readonly PREPARE: "CreateAudioContext";
                            };
                        };
                        readonly CreateAudioContext: {
                            readonly invoke: {
                                readonly id: "createAudioContext";
                                readonly src: "audioContext";
                                readonly onDone: readonly [{
                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<SSContext, import("xstate").DoneActorEvent<AudioContext, string>>) => boolean;
                                    readonly target: "Spawn";
                                    readonly actions: readonly [import("xstate").ActionFunction<SSContext, import("xstate").DoneActorEvent<AudioContext, string>, SpeechStateEvent, undefined, import("xstate").Values<{
                                        audioContext: {
                                            src: "audioContext";
                                            logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        tts: {
                                            src: "tts";
                                            logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                ttsStop: {
                                                    type: "ttsStop";
                                                    params: unknown;
                                                };
                                                addFiller: {
                                                    type: "addFiller";
                                                    params: {};
                                                };
                                                assignCurrentVoice: {
                                                    type: "assignCurrentVoice";
                                                    params: {};
                                                };
                                                assignCurrentLocale: {
                                                    type: "assignCurrentLocale";
                                                    params: {};
                                                };
                                                sendParentCurrentPersona: {
                                                    type: "sendParentCurrentPersona";
                                                    params: {};
                                                };
                                            }>, import("xstate").Values<{
                                                bufferContainsUtterancePartReadyToBeSpoken: {
                                                    type: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    params: unknown;
                                                };
                                                bufferIsNonEmpty: {
                                                    type: "bufferIsNonEmpty";
                                                    params: unknown;
                                                };
                                            }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
                                                Operation: "NotReady" | {
                                                    Ready: "Idle" | {
                                                        BufferedSpeaker: {
                                                            Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                                                            Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                                                                Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                                                    UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                                                                };
                                                            };
                                                        };
                                                    } | {
                                                        Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                                                    } | {
                                                        Speaking: "Go" | "Paused";
                                                    };
                                                };
                                                MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
                                            }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "tts";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T ? T extends {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_1 ? T_1 extends {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_1 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_1["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_1["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_2 ? T_2 extends {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_2 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_2["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_2["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_3 ? T_3 extends {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_3 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_3["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_3["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_4 ? T_4 extends {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_4 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_4["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_4["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_5 ? T_5 extends {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_5 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_5["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_5["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_6 ? T_6 extends {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_6 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_6["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_6["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").TTSInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    azureAuthorizationToken: string;
                                                    ttsDefaultVoice: string;
                                                    ttsDefaultFillerDelay: number;
                                                    ttsDefaultFiller: string;
                                                    ttsLexicon: string;
                                                    audioContext: AudioContext;
                                                    azureRegion: string;
                                                    locale: string;
                                                    buffer: string;
                                                };
                                                readonly on: {
                                                    readonly ERROR: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "ERROR";
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                    };
                                                };
                                                readonly type: "parallel";
                                                readonly states: {
                                                    readonly Operation: {
                                                        readonly initial: "NotReady";
                                                        readonly states: {
                                                            readonly NotReady: {
                                                                readonly on: {
                                                                    readonly READY: {
                                                                        readonly target: "Ready";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "READY";
                                                                            value: {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                            };
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                    };
                                                                };
                                                            };
                                                            readonly Ready: {
                                                                readonly initial: "Idle";
                                                                readonly states: {
                                                                    readonly Idle: {
                                                                        readonly id: "Idle";
                                                                        readonly on: {
                                                                            readonly SPEAK: readonly [{
                                                                                readonly target: "BufferedSpeaker";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }>) => boolean;
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>;
                                                                            }, {
                                                                                readonly target: "Playing";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }>) => boolean;
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>;
                                                                            }, {
                                                                                readonly target: "Speaking";
                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent>) => void];
                                                                            }];
                                                                        };
                                                                    };
                                                                    readonly BufferedSpeaker: {
                                                                        readonly type: "parallel";
                                                                        readonly invoke: {
                                                                            readonly id: "createEventsFromStream";
                                                                            readonly src: "createEventsFromStream";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => Agenda;
                                                                        };
                                                                        readonly on: {
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly states: {
                                                                            readonly Buffer: {
                                                                                readonly initial: "BufferIdle";
                                                                                readonly on: {
                                                                                    readonly STREAMING_SET_VOICE: {
                                                                                        readonly actions: "assignCurrentVoice";
                                                                                    };
                                                                                    readonly STREAMING_SET_LOCALE: {
                                                                                        readonly actions: "assignCurrentLocale";
                                                                                    };
                                                                                    readonly STREAMING_SET_PERSONA: {
                                                                                        readonly actions: "sendParentCurrentPersona";
                                                                                    };
                                                                                };
                                                                                readonly states: {
                                                                                    readonly BufferIdle: {
                                                                                        readonly id: "BufferIdle";
                                                                                        readonly on: {
                                                                                            readonly STREAMING_CHUNK: {
                                                                                                readonly target: "Buffering";
                                                                                            };
                                                                                            readonly STREAMING_DONE: "BufferingDone";
                                                                                        };
                                                                                    };
                                                                                    readonly Buffering: {
                                                                                        readonly id: "Buffering";
                                                                                        readonly on: {
                                                                                            readonly STREAMING_CHUNK: {
                                                                                                readonly target: "Buffering";
                                                                                                readonly reenter: true;
                                                                                            };
                                                                                            readonly STREAMING_DONE: "BufferingDone";
                                                                                        };
                                                                                        readonly after: {
                                                                                            readonly STREAMING_TIMEOUT: {
                                                                                                readonly target: "BufferingDone";
                                                                                                readonly actions: () => void;
                                                                                            };
                                                                                        };
                                                                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                    };
                                                                                    readonly BufferingDone: {
                                                                                        readonly id: "BufferingDone";
                                                                                        readonly type: "final";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly Speaker: {
                                                                                readonly initial: "SpeakingIdle";
                                                                                readonly states: {
                                                                                    readonly SpeakingIdle: {
                                                                                        readonly id: "SpeakingIdle";
                                                                                        readonly always: readonly [{
                                                                                            readonly target: "Speak";
                                                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                checkCache: {
                                                                                                    src: "checkCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudioFromCache: {
                                                                                                    src: "getAudioFromCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudio: {
                                                                                                    src: "getAudio";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioURL: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                playAudio: {
                                                                                                    src: "playAudio";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioBuffer: AudioBuffer;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                createEventsFromStream: {
                                                                                                    src: "createEventsFromStream";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                ponyfill: {
                                                                                                    src: "ponyfill";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                start: {
                                                                                                    src: "start";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        ttsLexicon: string;
                                                                                                        locale: string;
                                                                                                        wsaUtt: {
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        visemes?: boolean;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                checkCache: {
                                                                                                    src: "checkCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudioFromCache: {
                                                                                                    src: "getAudioFromCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudio: {
                                                                                                    src: "getAudio";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioURL: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                playAudio: {
                                                                                                    src: "playAudio";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioBuffer: AudioBuffer;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                createEventsFromStream: {
                                                                                                    src: "createEventsFromStream";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                ponyfill: {
                                                                                                    src: "ponyfill";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                start: {
                                                                                                    src: "start";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        ttsLexicon: string;
                                                                                                        locale: string;
                                                                                                        wsaUtt: {
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        visemes?: boolean;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                            }>, never, never, never, never>];
                                                                                        }, {
                                                                                            readonly target: "PrepareSpeech";
                                                                                            readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                                                        }];
                                                                                        readonly after: {
                                                                                            readonly FILLER_DELAY: {
                                                                                                readonly target: "SpeakingIdle";
                                                                                                readonly reenter: true;
                                                                                                readonly actions: "addFiller";
                                                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                    readonly PrepareSpeech: {
                                                                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                        readonly always: readonly [{
                                                                                            readonly target: "Speak";
                                                                                        }];
                                                                                    };
                                                                                    readonly Speak: {
                                                                                        readonly initial: "Init";
                                                                                        readonly states: {
                                                                                            readonly Init: {
                                                                                                readonly always: readonly [{
                                                                                                    readonly target: "CheckCache";
                                                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                                }, {
                                                                                                    readonly target: "Go";
                                                                                                }];
                                                                                            };
                                                                                            readonly CheckCache: {
                                                                                                readonly invoke: {
                                                                                                    readonly src: "checkCache";
                                                                                                    readonly input: ({ context }: {
                                                                                                        context: import("./types").TTSContext;
                                                                                                        event: import("./types").TTSEvent;
                                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                    }) => {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    };
                                                                                                    readonly onError: "Go";
                                                                                                    readonly onDone: readonly [{
                                                                                                        readonly target: "UseCache";
                                                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                                                    }, {
                                                                                                        readonly target: "Go";
                                                                                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                                                    }];
                                                                                                };
                                                                                            };
                                                                                            readonly UseCache: {
                                                                                                readonly initial: "GetAudio";
                                                                                                readonly states: {
                                                                                                    readonly GetAudio: {
                                                                                                        readonly invoke: {
                                                                                                            readonly src: "getAudioFromCache";
                                                                                                            readonly input: ({ context }: {
                                                                                                                context: import("./types").TTSContext;
                                                                                                                event: import("./types").TTSEvent;
                                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                            }) => {
                                                                                                                audioContext: AudioContext;
                                                                                                                cacheURL: string;
                                                                                                                utterance: string;
                                                                                                                voice: string;
                                                                                                                locale: string;
                                                                                                            };
                                                                                                            readonly onDone: {
                                                                                                                readonly target: "PlayAudio";
                                                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                                    checkCache: {
                                                                                                                        src: "checkCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudioFromCache: {
                                                                                                                        src: "getAudioFromCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudio: {
                                                                                                                        src: "getAudio";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioURL: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    playAudio: {
                                                                                                                        src: "playAudio";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioBuffer: AudioBuffer;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    createEventsFromStream: {
                                                                                                                        src: "createEventsFromStream";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    ponyfill: {
                                                                                                                        src: "ponyfill";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    start: {
                                                                                                                        src: "start";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            ttsLexicon: string;
                                                                                                                            locale: string;
                                                                                                                            wsaUtt: {
                                                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                                                            };
                                                                                                                            wsaTTS: SpeechSynthesis;
                                                                                                                            visemes?: boolean;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                }>, never, never, never, never>;
                                                                                                            };
                                                                                                            readonly onError: "#TtsStreamGo";
                                                                                                        };
                                                                                                    };
                                                                                                    readonly PlayAudio: {
                                                                                                        readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                                                        readonly invoke: {
                                                                                                            readonly src: "playAudio";
                                                                                                            readonly input: ({ context }: {
                                                                                                                context: import("./types").TTSContext;
                                                                                                                event: import("./types").TTSEvent;
                                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                            }) => {
                                                                                                                audioBuffer: AudioBuffer;
                                                                                                                audioContext: AudioContext;
                                                                                                            };
                                                                                                        };
                                                                                                        readonly on: {
                                                                                                            readonly CONTROL: "PausedAudio";
                                                                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                                                                readonly target: "#SpeakingDone";
                                                                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                                                    type: "SPEAK_COMPLETE";
                                                                                                                }, unknown, any>;
                                                                                                            }, {
                                                                                                                readonly target: "#SpeakingIdle";
                                                                                                            }];
                                                                                                            readonly TTS_STARTED: {
                                                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                                    type: "TTS_STARTED";
                                                                                                                    value?: AudioBufferSourceNode;
                                                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                                    type: "TTS_STARTED";
                                                                                                                    value?: AudioBufferSourceNode;
                                                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                                    checkCache: {
                                                                                                                        src: "checkCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudioFromCache: {
                                                                                                                        src: "getAudioFromCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudio: {
                                                                                                                        src: "getAudio";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioURL: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    playAudio: {
                                                                                                                        src: "playAudio";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioBuffer: AudioBuffer;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    createEventsFromStream: {
                                                                                                                        src: "createEventsFromStream";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    ponyfill: {
                                                                                                                        src: "ponyfill";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    start: {
                                                                                                                        src: "start";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            ttsLexicon: string;
                                                                                                                            locale: string;
                                                                                                                            wsaUtt: {
                                                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                                                            };
                                                                                                                            wsaTTS: SpeechSynthesis;
                                                                                                                            visemes?: boolean;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                }>, never, never, never, never>];
                                                                                                            };
                                                                                                        };
                                                                                                        readonly exit: "ttsStop";
                                                                                                    };
                                                                                                    readonly PausedAudio: {
                                                                                                        readonly on: {
                                                                                                            readonly CONTROL: "PlayAudio";
                                                                                                        };
                                                                                                    };
                                                                                                };
                                                                                            };
                                                                                            readonly Go: {
                                                                                                readonly id: "TtsStreamGo";
                                                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                                readonly invoke: {
                                                                                                    readonly src: "start";
                                                                                                    readonly input: ({ context }: {
                                                                                                        context: import("./types").TTSContext;
                                                                                                        event: import("./types").TTSEvent;
                                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                    }) => {
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        wsaUtt: {
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        ttsLexicon: string;
                                                                                                        visemes: boolean;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                        utterance: string;
                                                                                                    };
                                                                                                };
                                                                                                readonly on: {
                                                                                                    readonly CONTROL: "Paused";
                                                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                                                        readonly target: "#SpeakingDone";
                                                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                                            type: "SPEAK_COMPLETE";
                                                                                                        }, unknown, any>;
                                                                                                    }, {
                                                                                                        readonly target: "#SpeakingIdle";
                                                                                                    }];
                                                                                                    readonly TTS_STARTED: {
                                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                            type: "TTS_STARTED";
                                                                                                            value?: AudioBufferSourceNode;
                                                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                                                    };
                                                                                                };
                                                                                                readonly exit: "ttsStop";
                                                                                            };
                                                                                            readonly Paused: {
                                                                                                readonly on: {
                                                                                                    readonly CONTROL: "Go";
                                                                                                };
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                    readonly SpeakingDone: {
                                                                                        readonly id: "SpeakingDone";
                                                                                        readonly type: "final";
                                                                                    };
                                                                                };
                                                                            };
                                                                        };
                                                                        readonly onDone: {
                                                                            readonly target: "Idle";
                                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        };
                                                                    };
                                                                    readonly Playing: {
                                                                        readonly on: {
                                                                            readonly SPEAK_COMPLETE: {
                                                                                readonly target: "Idle";
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK_COMPLETE";
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>];
                                                                            };
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly initial: "FetchAudio";
                                                                        readonly states: {
                                                                            readonly FetchAudio: {
                                                                                readonly invoke: {
                                                                                    readonly src: "getAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        audioURL: string;
                                                                                    };
                                                                                    readonly onDone: {
                                                                                        readonly target: "PlayAudio";
                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>;
                                                                                    };
                                                                                    readonly onError: {
                                                                                        readonly target: "#Speaking";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly PlayAudio: {
                                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly invoke: {
                                                                                    readonly src: "playAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        audioBuffer: AudioBuffer;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "AudioPaused";
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly AudioPaused: {
                                                                                readonly on: {
                                                                                    readonly CONTROL: "PlayAudio";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Speaking: {
                                                                        readonly id: "Speaking";
                                                                        readonly initial: "Go";
                                                                        readonly on: {
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                            readonly VISEME: {
                                                                                readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                                                    type: "VISEME";
                                                                                    value: any;
                                                                                }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                                                            };
                                                                            readonly SPEAK_COMPLETE: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        readonly states: {
                                                                            readonly Go: {
                                                                                readonly invoke: {
                                                                                    readonly src: "start";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        wsaTTS: SpeechSynthesis;
                                                                                        wsaUtt: {
                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                        };
                                                                                        ttsLexicon: string;
                                                                                        voice: string;
                                                                                        visemes: boolean;
                                                                                        locale: string;
                                                                                        utterance: string;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "Paused";
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly Paused: {
                                                                                readonly on: {
                                                                                    readonly SPEAK_COMPLETE: {};
                                                                                    readonly CONTROL: "Go";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly MaybeHandleNewTokens: {
                                                        readonly initial: "Choice";
                                                        readonly states: {
                                                            readonly Choice: {
                                                                readonly always: readonly [{
                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                    readonly target: "Ponyfill";
                                                                }, {
                                                                    readonly target: "NoPonyfill";
                                                                }];
                                                            };
                                                            readonly NoPonyfill: {
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly Ponyfill: {
                                                                readonly invoke: {
                                                                    readonly id: "ponyTTS";
                                                                    readonly src: "ponyfill";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        azureAuthorizationToken: string;
                                                                        azureRegion: string;
                                                                        audioContext: AudioContext;
                                                                    };
                                                                };
                                                                readonly on: {
                                                                    readonly READY: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "READY";
                                                                            value: {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                            };
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    };
                                                                    readonly NEW_TOKEN: {
                                                                        readonly target: "Ponyfill";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "NEW_TOKEN";
                                                                            value: string;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                        readonly reenter: true;
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        asr: {
                                            src: "asr";
                                            logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                maybe_ponyfill: {
                                                    src: "maybe_ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                nluPromise: {
                                                    src: "nluPromise";
                                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                        query: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                raise_noinput_after_timeout: {
                                                    type: "raise_noinput_after_timeout";
                                                    params: {};
                                                };
                                                cancel_noinput_timeout: {
                                                    type: "cancel_noinput_timeout";
                                                    params: {};
                                                };
                                            }>, {
                                                type: "nlu_is_activated";
                                                params: unknown;
                                            }, "noinputTimeout", "Ready" | "Fail" | {
                                                Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                                                    Pausing: "Paused" | "WaitToPause" | "Continue";
                                                };
                                            }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "asr";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "maybe_ponyfill" | "nluPromise">(logic: TSrc, ...[options]: ({
                                                            src: "maybe_ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T ? T extends {
                                                            src: "maybe_ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_1 ? T_1 extends {
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_1 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_1["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_1["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            maybe_ponyfill: {
                                                                src: "maybe_ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").ASRInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    azureAuthorizationToken: string;
                                                    asrDefaultCompleteTimeout: number;
                                                    asrDefaultNoInputTimeout: number;
                                                    locale: string;
                                                    audioContext: AudioContext;
                                                    azureRegion: string;
                                                    azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                                                    speechRecognitionEndpointId: string;
                                                };
                                                readonly initial: "Ready";
                                                readonly on: {
                                                    readonly NEW_TOKEN: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                            type: "NEW_TOKEN";
                                                            value: string;
                                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                            maybe_ponyfill: {
                                                                src: "maybe_ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>;
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Fail: {};
                                                    readonly Ready: {
                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                        readonly on: {
                                                            readonly START: {
                                                                readonly target: "Recognising";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "START";
                                                                    value?: RecogniseParameters;
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    maybe_ponyfill: {
                                                                        src: "maybe_ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>;
                                                            };
                                                        };
                                                    };
                                                    readonly Recognising: {
                                                        readonly onDone: "Ready";
                                                        readonly invoke: {
                                                            readonly id: "asr";
                                                            readonly src: "maybe_ponyfill";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").ASRContext;
                                                                event: import("./types").ASREvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                azureRegion: string;
                                                                audioContext: AudioContext;
                                                                azureAuthorizationToken: string;
                                                                locale: string;
                                                                speechRecognitionEndpointId: string;
                                                                completeTimeout: number;
                                                                hints: string[];
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly FINAL_RESULT: readonly [{
                                                                readonly target: ".NLURequest";
                                                                readonly guard: {
                                                                    readonly type: "nlu_is_activated";
                                                                };
                                                            }, {
                                                                readonly target: ".WaitToStop";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "FINAL_RESULT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                            }];
                                                            readonly RESULT: {
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: Hypothesis[];
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    maybe_ponyfill: {
                                                                        src: "maybe_ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: Hypothesis[];
                                                                }, undefined, import("./types").ASREvent>];
                                                                readonly target: ".InterimResult";
                                                            };
                                                            readonly STOP: {
                                                                readonly target: ".WaitToStop";
                                                            };
                                                            readonly CONTROL: {
                                                                readonly target: ".Pausing";
                                                            };
                                                            readonly NOINPUT: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "NOINPUT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                readonly target: ".WaitToStop";
                                                            };
                                                        };
                                                        readonly initial: "WaitForRecogniser";
                                                        readonly states: {
                                                            readonly WaitForRecogniser: {
                                                                readonly on: {
                                                                    readonly STARTED: {
                                                                        readonly target: "NoInput";
                                                                        readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "STARTED";
                                                                            value: {
                                                                                wsaASRinstance: import("./types").MySpeechRecognition;
                                                                            };
                                                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                    };
                                                                };
                                                            };
                                                            readonly NoInput: {
                                                                readonly entry: {
                                                                    readonly type: "raise_noinput_after_timeout";
                                                                };
                                                                readonly on: {
                                                                    readonly STARTSPEECH: {
                                                                        readonly target: "InProgress";
                                                                        readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                                            type: "STARTSPEECH";
                                                                        }, undefined, import("./types").ASREvent>;
                                                                    };
                                                                };
                                                                readonly exit: {
                                                                    readonly type: "cancel_noinput_timeout";
                                                                };
                                                            };
                                                            readonly InProgress: {
                                                                readonly entry: () => void;
                                                            };
                                                            readonly InterimResult: {
                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                            };
                                                            readonly WaitToStop: {
                                                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                readonly on: {
                                                                    readonly LISTEN_COMPLETE: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "LISTEN_COMPLETE";
                                                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly target: "Stopped";
                                                                    };
                                                                };
                                                            };
                                                            readonly Pausing: {
                                                                readonly onDone: "#asr.Recognising";
                                                                readonly initial: "WaitToPause";
                                                                readonly states: {
                                                                    readonly WaitToPause: {
                                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly on: {
                                                                            readonly LISTEN_COMPLETE: {
                                                                                readonly target: "Paused";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Paused: {
                                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly on: {
                                                                            readonly CONTROL: {
                                                                                readonly target: "Continue";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Continue: {
                                                                        readonly type: "final";
                                                                    };
                                                                };
                                                            };
                                                            readonly NLURequest: {
                                                                readonly invoke: {
                                                                    readonly src: "nluPromise";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").ASRContext;
                                                                        event: import("./types").ASREvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        endpoint: string;
                                                                        key: string;
                                                                        projectName: string;
                                                                        deploymentName: string;
                                                                        query: string;
                                                                        locale: string;
                                                                    };
                                                                    readonly onDone: readonly [{
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                                                    }, {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                    }];
                                                                    readonly onError: {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                    };
                                                                };
                                                            };
                                                            readonly Stopped: {
                                                                readonly type: "final";
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        visemes: {
                                            src: "visemes";
                                            logic: import("xstate").StateMachine<{
                                                queue: number[];
                                            }, {
                                                type: "VISEME";
                                                value: any;
                                            }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly context: {
                                                    readonly queue: [];
                                                };
                                                readonly initial: "Init";
                                                readonly states: {
                                                    readonly Init: {
                                                        readonly on: {
                                                            readonly VISEME: readonly [{
                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                                                    queue: number[];
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }>) => boolean;
                                                                readonly actions: readonly [import("xstate").ActionFunction<{
                                                                    queue: number[];
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }, undefined, never, never, never, never, never>];
                                                            }];
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                }, {
                                    readonly target: "GenerateToken";
                                    readonly actions: readonly [import("xstate").ActionFunction<SSContext, import("xstate").DoneActorEvent<AudioContext, string>, SpeechStateEvent, undefined, import("xstate").Values<{
                                        audioContext: {
                                            src: "audioContext";
                                            logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        tts: {
                                            src: "tts";
                                            logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                ttsStop: {
                                                    type: "ttsStop";
                                                    params: unknown;
                                                };
                                                addFiller: {
                                                    type: "addFiller";
                                                    params: {};
                                                };
                                                assignCurrentVoice: {
                                                    type: "assignCurrentVoice";
                                                    params: {};
                                                };
                                                assignCurrentLocale: {
                                                    type: "assignCurrentLocale";
                                                    params: {};
                                                };
                                                sendParentCurrentPersona: {
                                                    type: "sendParentCurrentPersona";
                                                    params: {};
                                                };
                                            }>, import("xstate").Values<{
                                                bufferContainsUtterancePartReadyToBeSpoken: {
                                                    type: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    params: unknown;
                                                };
                                                bufferIsNonEmpty: {
                                                    type: "bufferIsNonEmpty";
                                                    params: unknown;
                                                };
                                            }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
                                                Operation: "NotReady" | {
                                                    Ready: "Idle" | {
                                                        BufferedSpeaker: {
                                                            Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                                                            Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                                                                Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                                                    UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                                                                };
                                                            };
                                                        };
                                                    } | {
                                                        Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                                                    } | {
                                                        Speaking: "Go" | "Paused";
                                                    };
                                                };
                                                MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
                                            }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "tts";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T ? T extends {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_1 ? T_1 extends {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_1 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_1["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_1["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_2 ? T_2 extends {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_2 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_2["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_2["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_3 ? T_3 extends {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_3 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_3["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_3["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_4 ? T_4 extends {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_4 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_4["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_4["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_5 ? T_5 extends {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_5 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_5["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_5["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_6 ? T_6 extends {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_6 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_6["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_6["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").TTSInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    azureAuthorizationToken: string;
                                                    ttsDefaultVoice: string;
                                                    ttsDefaultFillerDelay: number;
                                                    ttsDefaultFiller: string;
                                                    ttsLexicon: string;
                                                    audioContext: AudioContext;
                                                    azureRegion: string;
                                                    locale: string;
                                                    buffer: string;
                                                };
                                                readonly on: {
                                                    readonly ERROR: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "ERROR";
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                    };
                                                };
                                                readonly type: "parallel";
                                                readonly states: {
                                                    readonly Operation: {
                                                        readonly initial: "NotReady";
                                                        readonly states: {
                                                            readonly NotReady: {
                                                                readonly on: {
                                                                    readonly READY: {
                                                                        readonly target: "Ready";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "READY";
                                                                            value: {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                            };
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                    };
                                                                };
                                                            };
                                                            readonly Ready: {
                                                                readonly initial: "Idle";
                                                                readonly states: {
                                                                    readonly Idle: {
                                                                        readonly id: "Idle";
                                                                        readonly on: {
                                                                            readonly SPEAK: readonly [{
                                                                                readonly target: "BufferedSpeaker";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }>) => boolean;
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>;
                                                                            }, {
                                                                                readonly target: "Playing";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }>) => boolean;
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>;
                                                                            }, {
                                                                                readonly target: "Speaking";
                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent>) => void];
                                                                            }];
                                                                        };
                                                                    };
                                                                    readonly BufferedSpeaker: {
                                                                        readonly type: "parallel";
                                                                        readonly invoke: {
                                                                            readonly id: "createEventsFromStream";
                                                                            readonly src: "createEventsFromStream";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => Agenda;
                                                                        };
                                                                        readonly on: {
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly states: {
                                                                            readonly Buffer: {
                                                                                readonly initial: "BufferIdle";
                                                                                readonly on: {
                                                                                    readonly STREAMING_SET_VOICE: {
                                                                                        readonly actions: "assignCurrentVoice";
                                                                                    };
                                                                                    readonly STREAMING_SET_LOCALE: {
                                                                                        readonly actions: "assignCurrentLocale";
                                                                                    };
                                                                                    readonly STREAMING_SET_PERSONA: {
                                                                                        readonly actions: "sendParentCurrentPersona";
                                                                                    };
                                                                                };
                                                                                readonly states: {
                                                                                    readonly BufferIdle: {
                                                                                        readonly id: "BufferIdle";
                                                                                        readonly on: {
                                                                                            readonly STREAMING_CHUNK: {
                                                                                                readonly target: "Buffering";
                                                                                            };
                                                                                            readonly STREAMING_DONE: "BufferingDone";
                                                                                        };
                                                                                    };
                                                                                    readonly Buffering: {
                                                                                        readonly id: "Buffering";
                                                                                        readonly on: {
                                                                                            readonly STREAMING_CHUNK: {
                                                                                                readonly target: "Buffering";
                                                                                                readonly reenter: true;
                                                                                            };
                                                                                            readonly STREAMING_DONE: "BufferingDone";
                                                                                        };
                                                                                        readonly after: {
                                                                                            readonly STREAMING_TIMEOUT: {
                                                                                                readonly target: "BufferingDone";
                                                                                                readonly actions: () => void;
                                                                                            };
                                                                                        };
                                                                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                    };
                                                                                    readonly BufferingDone: {
                                                                                        readonly id: "BufferingDone";
                                                                                        readonly type: "final";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly Speaker: {
                                                                                readonly initial: "SpeakingIdle";
                                                                                readonly states: {
                                                                                    readonly SpeakingIdle: {
                                                                                        readonly id: "SpeakingIdle";
                                                                                        readonly always: readonly [{
                                                                                            readonly target: "Speak";
                                                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                checkCache: {
                                                                                                    src: "checkCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudioFromCache: {
                                                                                                    src: "getAudioFromCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudio: {
                                                                                                    src: "getAudio";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioURL: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                playAudio: {
                                                                                                    src: "playAudio";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioBuffer: AudioBuffer;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                createEventsFromStream: {
                                                                                                    src: "createEventsFromStream";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                ponyfill: {
                                                                                                    src: "ponyfill";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                start: {
                                                                                                    src: "start";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        ttsLexicon: string;
                                                                                                        locale: string;
                                                                                                        wsaUtt: {
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        visemes?: boolean;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                checkCache: {
                                                                                                    src: "checkCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudioFromCache: {
                                                                                                    src: "getAudioFromCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudio: {
                                                                                                    src: "getAudio";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioURL: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                playAudio: {
                                                                                                    src: "playAudio";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioBuffer: AudioBuffer;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                createEventsFromStream: {
                                                                                                    src: "createEventsFromStream";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                ponyfill: {
                                                                                                    src: "ponyfill";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                start: {
                                                                                                    src: "start";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        ttsLexicon: string;
                                                                                                        locale: string;
                                                                                                        wsaUtt: {
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        visemes?: boolean;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                            }>, never, never, never, never>];
                                                                                        }, {
                                                                                            readonly target: "PrepareSpeech";
                                                                                            readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                                                        }];
                                                                                        readonly after: {
                                                                                            readonly FILLER_DELAY: {
                                                                                                readonly target: "SpeakingIdle";
                                                                                                readonly reenter: true;
                                                                                                readonly actions: "addFiller";
                                                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                    readonly PrepareSpeech: {
                                                                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                        readonly always: readonly [{
                                                                                            readonly target: "Speak";
                                                                                        }];
                                                                                    };
                                                                                    readonly Speak: {
                                                                                        readonly initial: "Init";
                                                                                        readonly states: {
                                                                                            readonly Init: {
                                                                                                readonly always: readonly [{
                                                                                                    readonly target: "CheckCache";
                                                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                                }, {
                                                                                                    readonly target: "Go";
                                                                                                }];
                                                                                            };
                                                                                            readonly CheckCache: {
                                                                                                readonly invoke: {
                                                                                                    readonly src: "checkCache";
                                                                                                    readonly input: ({ context }: {
                                                                                                        context: import("./types").TTSContext;
                                                                                                        event: import("./types").TTSEvent;
                                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                    }) => {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    };
                                                                                                    readonly onError: "Go";
                                                                                                    readonly onDone: readonly [{
                                                                                                        readonly target: "UseCache";
                                                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                                                    }, {
                                                                                                        readonly target: "Go";
                                                                                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                                                    }];
                                                                                                };
                                                                                            };
                                                                                            readonly UseCache: {
                                                                                                readonly initial: "GetAudio";
                                                                                                readonly states: {
                                                                                                    readonly GetAudio: {
                                                                                                        readonly invoke: {
                                                                                                            readonly src: "getAudioFromCache";
                                                                                                            readonly input: ({ context }: {
                                                                                                                context: import("./types").TTSContext;
                                                                                                                event: import("./types").TTSEvent;
                                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                            }) => {
                                                                                                                audioContext: AudioContext;
                                                                                                                cacheURL: string;
                                                                                                                utterance: string;
                                                                                                                voice: string;
                                                                                                                locale: string;
                                                                                                            };
                                                                                                            readonly onDone: {
                                                                                                                readonly target: "PlayAudio";
                                                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                                    checkCache: {
                                                                                                                        src: "checkCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudioFromCache: {
                                                                                                                        src: "getAudioFromCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudio: {
                                                                                                                        src: "getAudio";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioURL: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    playAudio: {
                                                                                                                        src: "playAudio";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioBuffer: AudioBuffer;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    createEventsFromStream: {
                                                                                                                        src: "createEventsFromStream";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    ponyfill: {
                                                                                                                        src: "ponyfill";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    start: {
                                                                                                                        src: "start";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            ttsLexicon: string;
                                                                                                                            locale: string;
                                                                                                                            wsaUtt: {
                                                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                                                            };
                                                                                                                            wsaTTS: SpeechSynthesis;
                                                                                                                            visemes?: boolean;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                }>, never, never, never, never>;
                                                                                                            };
                                                                                                            readonly onError: "#TtsStreamGo";
                                                                                                        };
                                                                                                    };
                                                                                                    readonly PlayAudio: {
                                                                                                        readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                                                        readonly invoke: {
                                                                                                            readonly src: "playAudio";
                                                                                                            readonly input: ({ context }: {
                                                                                                                context: import("./types").TTSContext;
                                                                                                                event: import("./types").TTSEvent;
                                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                            }) => {
                                                                                                                audioBuffer: AudioBuffer;
                                                                                                                audioContext: AudioContext;
                                                                                                            };
                                                                                                        };
                                                                                                        readonly on: {
                                                                                                            readonly CONTROL: "PausedAudio";
                                                                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                                                                readonly target: "#SpeakingDone";
                                                                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                                                    type: "SPEAK_COMPLETE";
                                                                                                                }, unknown, any>;
                                                                                                            }, {
                                                                                                                readonly target: "#SpeakingIdle";
                                                                                                            }];
                                                                                                            readonly TTS_STARTED: {
                                                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                                    type: "TTS_STARTED";
                                                                                                                    value?: AudioBufferSourceNode;
                                                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                                    type: "TTS_STARTED";
                                                                                                                    value?: AudioBufferSourceNode;
                                                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                                    checkCache: {
                                                                                                                        src: "checkCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudioFromCache: {
                                                                                                                        src: "getAudioFromCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudio: {
                                                                                                                        src: "getAudio";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioURL: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    playAudio: {
                                                                                                                        src: "playAudio";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioBuffer: AudioBuffer;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    createEventsFromStream: {
                                                                                                                        src: "createEventsFromStream";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    ponyfill: {
                                                                                                                        src: "ponyfill";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    start: {
                                                                                                                        src: "start";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            ttsLexicon: string;
                                                                                                                            locale: string;
                                                                                                                            wsaUtt: {
                                                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                                                            };
                                                                                                                            wsaTTS: SpeechSynthesis;
                                                                                                                            visemes?: boolean;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                }>, never, never, never, never>];
                                                                                                            };
                                                                                                        };
                                                                                                        readonly exit: "ttsStop";
                                                                                                    };
                                                                                                    readonly PausedAudio: {
                                                                                                        readonly on: {
                                                                                                            readonly CONTROL: "PlayAudio";
                                                                                                        };
                                                                                                    };
                                                                                                };
                                                                                            };
                                                                                            readonly Go: {
                                                                                                readonly id: "TtsStreamGo";
                                                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                                readonly invoke: {
                                                                                                    readonly src: "start";
                                                                                                    readonly input: ({ context }: {
                                                                                                        context: import("./types").TTSContext;
                                                                                                        event: import("./types").TTSEvent;
                                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                    }) => {
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        wsaUtt: {
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        ttsLexicon: string;
                                                                                                        visemes: boolean;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                        utterance: string;
                                                                                                    };
                                                                                                };
                                                                                                readonly on: {
                                                                                                    readonly CONTROL: "Paused";
                                                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                                                        readonly target: "#SpeakingDone";
                                                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                                            type: "SPEAK_COMPLETE";
                                                                                                        }, unknown, any>;
                                                                                                    }, {
                                                                                                        readonly target: "#SpeakingIdle";
                                                                                                    }];
                                                                                                    readonly TTS_STARTED: {
                                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                            type: "TTS_STARTED";
                                                                                                            value?: AudioBufferSourceNode;
                                                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                                                    };
                                                                                                };
                                                                                                readonly exit: "ttsStop";
                                                                                            };
                                                                                            readonly Paused: {
                                                                                                readonly on: {
                                                                                                    readonly CONTROL: "Go";
                                                                                                };
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                    readonly SpeakingDone: {
                                                                                        readonly id: "SpeakingDone";
                                                                                        readonly type: "final";
                                                                                    };
                                                                                };
                                                                            };
                                                                        };
                                                                        readonly onDone: {
                                                                            readonly target: "Idle";
                                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        };
                                                                    };
                                                                    readonly Playing: {
                                                                        readonly on: {
                                                                            readonly SPEAK_COMPLETE: {
                                                                                readonly target: "Idle";
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK_COMPLETE";
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>];
                                                                            };
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly initial: "FetchAudio";
                                                                        readonly states: {
                                                                            readonly FetchAudio: {
                                                                                readonly invoke: {
                                                                                    readonly src: "getAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        audioURL: string;
                                                                                    };
                                                                                    readonly onDone: {
                                                                                        readonly target: "PlayAudio";
                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>;
                                                                                    };
                                                                                    readonly onError: {
                                                                                        readonly target: "#Speaking";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly PlayAudio: {
                                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly invoke: {
                                                                                    readonly src: "playAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        audioBuffer: AudioBuffer;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "AudioPaused";
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly AudioPaused: {
                                                                                readonly on: {
                                                                                    readonly CONTROL: "PlayAudio";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Speaking: {
                                                                        readonly id: "Speaking";
                                                                        readonly initial: "Go";
                                                                        readonly on: {
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                            readonly VISEME: {
                                                                                readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                                                    type: "VISEME";
                                                                                    value: any;
                                                                                }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                                                            };
                                                                            readonly SPEAK_COMPLETE: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        readonly states: {
                                                                            readonly Go: {
                                                                                readonly invoke: {
                                                                                    readonly src: "start";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        wsaTTS: SpeechSynthesis;
                                                                                        wsaUtt: {
                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                        };
                                                                                        ttsLexicon: string;
                                                                                        voice: string;
                                                                                        visemes: boolean;
                                                                                        locale: string;
                                                                                        utterance: string;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "Paused";
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly Paused: {
                                                                                readonly on: {
                                                                                    readonly SPEAK_COMPLETE: {};
                                                                                    readonly CONTROL: "Go";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly MaybeHandleNewTokens: {
                                                        readonly initial: "Choice";
                                                        readonly states: {
                                                            readonly Choice: {
                                                                readonly always: readonly [{
                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                    readonly target: "Ponyfill";
                                                                }, {
                                                                    readonly target: "NoPonyfill";
                                                                }];
                                                            };
                                                            readonly NoPonyfill: {
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly Ponyfill: {
                                                                readonly invoke: {
                                                                    readonly id: "ponyTTS";
                                                                    readonly src: "ponyfill";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        azureAuthorizationToken: string;
                                                                        azureRegion: string;
                                                                        audioContext: AudioContext;
                                                                    };
                                                                };
                                                                readonly on: {
                                                                    readonly READY: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "READY";
                                                                            value: {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                            };
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    };
                                                                    readonly NEW_TOKEN: {
                                                                        readonly target: "Ponyfill";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "NEW_TOKEN";
                                                                            value: string;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                        readonly reenter: true;
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        asr: {
                                            src: "asr";
                                            logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                maybe_ponyfill: {
                                                    src: "maybe_ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                nluPromise: {
                                                    src: "nluPromise";
                                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                        query: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                raise_noinput_after_timeout: {
                                                    type: "raise_noinput_after_timeout";
                                                    params: {};
                                                };
                                                cancel_noinput_timeout: {
                                                    type: "cancel_noinput_timeout";
                                                    params: {};
                                                };
                                            }>, {
                                                type: "nlu_is_activated";
                                                params: unknown;
                                            }, "noinputTimeout", "Ready" | "Fail" | {
                                                Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                                                    Pausing: "Paused" | "WaitToPause" | "Continue";
                                                };
                                            }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "asr";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "maybe_ponyfill" | "nluPromise">(logic: TSrc, ...[options]: ({
                                                            src: "maybe_ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T ? T extends {
                                                            src: "maybe_ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_1 ? T_1 extends {
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_1 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_1["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_1["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            maybe_ponyfill: {
                                                                src: "maybe_ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").ASRInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    azureAuthorizationToken: string;
                                                    asrDefaultCompleteTimeout: number;
                                                    asrDefaultNoInputTimeout: number;
                                                    locale: string;
                                                    audioContext: AudioContext;
                                                    azureRegion: string;
                                                    azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                                                    speechRecognitionEndpointId: string;
                                                };
                                                readonly initial: "Ready";
                                                readonly on: {
                                                    readonly NEW_TOKEN: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                            type: "NEW_TOKEN";
                                                            value: string;
                                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                            maybe_ponyfill: {
                                                                src: "maybe_ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>;
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Fail: {};
                                                    readonly Ready: {
                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                        readonly on: {
                                                            readonly START: {
                                                                readonly target: "Recognising";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "START";
                                                                    value?: RecogniseParameters;
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    maybe_ponyfill: {
                                                                        src: "maybe_ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>;
                                                            };
                                                        };
                                                    };
                                                    readonly Recognising: {
                                                        readonly onDone: "Ready";
                                                        readonly invoke: {
                                                            readonly id: "asr";
                                                            readonly src: "maybe_ponyfill";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").ASRContext;
                                                                event: import("./types").ASREvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                azureRegion: string;
                                                                audioContext: AudioContext;
                                                                azureAuthorizationToken: string;
                                                                locale: string;
                                                                speechRecognitionEndpointId: string;
                                                                completeTimeout: number;
                                                                hints: string[];
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly FINAL_RESULT: readonly [{
                                                                readonly target: ".NLURequest";
                                                                readonly guard: {
                                                                    readonly type: "nlu_is_activated";
                                                                };
                                                            }, {
                                                                readonly target: ".WaitToStop";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "FINAL_RESULT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                            }];
                                                            readonly RESULT: {
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: Hypothesis[];
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    maybe_ponyfill: {
                                                                        src: "maybe_ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: Hypothesis[];
                                                                }, undefined, import("./types").ASREvent>];
                                                                readonly target: ".InterimResult";
                                                            };
                                                            readonly STOP: {
                                                                readonly target: ".WaitToStop";
                                                            };
                                                            readonly CONTROL: {
                                                                readonly target: ".Pausing";
                                                            };
                                                            readonly NOINPUT: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "NOINPUT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                readonly target: ".WaitToStop";
                                                            };
                                                        };
                                                        readonly initial: "WaitForRecogniser";
                                                        readonly states: {
                                                            readonly WaitForRecogniser: {
                                                                readonly on: {
                                                                    readonly STARTED: {
                                                                        readonly target: "NoInput";
                                                                        readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "STARTED";
                                                                            value: {
                                                                                wsaASRinstance: import("./types").MySpeechRecognition;
                                                                            };
                                                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                    };
                                                                };
                                                            };
                                                            readonly NoInput: {
                                                                readonly entry: {
                                                                    readonly type: "raise_noinput_after_timeout";
                                                                };
                                                                readonly on: {
                                                                    readonly STARTSPEECH: {
                                                                        readonly target: "InProgress";
                                                                        readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                                            type: "STARTSPEECH";
                                                                        }, undefined, import("./types").ASREvent>;
                                                                    };
                                                                };
                                                                readonly exit: {
                                                                    readonly type: "cancel_noinput_timeout";
                                                                };
                                                            };
                                                            readonly InProgress: {
                                                                readonly entry: () => void;
                                                            };
                                                            readonly InterimResult: {
                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                            };
                                                            readonly WaitToStop: {
                                                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                readonly on: {
                                                                    readonly LISTEN_COMPLETE: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "LISTEN_COMPLETE";
                                                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly target: "Stopped";
                                                                    };
                                                                };
                                                            };
                                                            readonly Pausing: {
                                                                readonly onDone: "#asr.Recognising";
                                                                readonly initial: "WaitToPause";
                                                                readonly states: {
                                                                    readonly WaitToPause: {
                                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly on: {
                                                                            readonly LISTEN_COMPLETE: {
                                                                                readonly target: "Paused";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Paused: {
                                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly on: {
                                                                            readonly CONTROL: {
                                                                                readonly target: "Continue";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Continue: {
                                                                        readonly type: "final";
                                                                    };
                                                                };
                                                            };
                                                            readonly NLURequest: {
                                                                readonly invoke: {
                                                                    readonly src: "nluPromise";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").ASRContext;
                                                                        event: import("./types").ASREvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        endpoint: string;
                                                                        key: string;
                                                                        projectName: string;
                                                                        deploymentName: string;
                                                                        query: string;
                                                                        locale: string;
                                                                    };
                                                                    readonly onDone: readonly [{
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                                                    }, {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                    }];
                                                                    readonly onError: {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                    };
                                                                };
                                                            };
                                                            readonly Stopped: {
                                                                readonly type: "final";
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        visemes: {
                                            src: "visemes";
                                            logic: import("xstate").StateMachine<{
                                                queue: number[];
                                            }, {
                                                type: "VISEME";
                                                value: any;
                                            }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly context: {
                                                    readonly queue: [];
                                                };
                                                readonly initial: "Init";
                                                readonly states: {
                                                    readonly Init: {
                                                        readonly on: {
                                                            readonly VISEME: readonly [{
                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                                                    queue: number[];
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }>) => boolean;
                                                                readonly actions: readonly [import("xstate").ActionFunction<{
                                                                    queue: number[];
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }, undefined, never, never, never, never, never>];
                                                            }];
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                }];
                            };
                        };
                        readonly GenerateToken: {
                            readonly invoke: {
                                readonly id: "getAuthorizationToken";
                                readonly input: ({ context }: {
                                    context: any;
                                }) => {
                                    credentials: any;
                                };
                                readonly src: "getToken";
                                readonly onDone: {
                                    readonly target: "Spawn";
                                    readonly actions: import("xstate").ActionFunction<SSContext, import("xstate").DoneActorEvent<string, string>, SpeechStateEvent, undefined, import("xstate").Values<{
                                        audioContext: {
                                            src: "audioContext";
                                            logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        tts: {
                                            src: "tts";
                                            logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                ttsStop: {
                                                    type: "ttsStop";
                                                    params: unknown;
                                                };
                                                addFiller: {
                                                    type: "addFiller";
                                                    params: {};
                                                };
                                                assignCurrentVoice: {
                                                    type: "assignCurrentVoice";
                                                    params: {};
                                                };
                                                assignCurrentLocale: {
                                                    type: "assignCurrentLocale";
                                                    params: {};
                                                };
                                                sendParentCurrentPersona: {
                                                    type: "sendParentCurrentPersona";
                                                    params: {};
                                                };
                                            }>, import("xstate").Values<{
                                                bufferContainsUtterancePartReadyToBeSpoken: {
                                                    type: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    params: unknown;
                                                };
                                                bufferIsNonEmpty: {
                                                    type: "bufferIsNonEmpty";
                                                    params: unknown;
                                                };
                                            }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
                                                Operation: "NotReady" | {
                                                    Ready: "Idle" | {
                                                        BufferedSpeaker: {
                                                            Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                                                            Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                                                                Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                                                    UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                                                                };
                                                            };
                                                        };
                                                    } | {
                                                        Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                                                    } | {
                                                        Speaking: "Go" | "Paused";
                                                    };
                                                };
                                                MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
                                            }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "tts";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T ? T extends {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_1 ? T_1 extends {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_1 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_1["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_1["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_2 ? T_2 extends {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_2 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_2["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_2["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_3 ? T_3 extends {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_3 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_3["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_3["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_4 ? T_4 extends {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_4 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_4["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_4["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_5 ? T_5 extends {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_5 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_5["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_5["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_6 ? T_6 extends {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_6 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_6["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_6["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").TTSInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    azureAuthorizationToken: string;
                                                    ttsDefaultVoice: string;
                                                    ttsDefaultFillerDelay: number;
                                                    ttsDefaultFiller: string;
                                                    ttsLexicon: string;
                                                    audioContext: AudioContext;
                                                    azureRegion: string;
                                                    locale: string;
                                                    buffer: string;
                                                };
                                                readonly on: {
                                                    readonly ERROR: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "ERROR";
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                    };
                                                };
                                                readonly type: "parallel";
                                                readonly states: {
                                                    readonly Operation: {
                                                        readonly initial: "NotReady";
                                                        readonly states: {
                                                            readonly NotReady: {
                                                                readonly on: {
                                                                    readonly READY: {
                                                                        readonly target: "Ready";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "READY";
                                                                            value: {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                            };
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                    };
                                                                };
                                                            };
                                                            readonly Ready: {
                                                                readonly initial: "Idle";
                                                                readonly states: {
                                                                    readonly Idle: {
                                                                        readonly id: "Idle";
                                                                        readonly on: {
                                                                            readonly SPEAK: readonly [{
                                                                                readonly target: "BufferedSpeaker";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }>) => boolean;
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>;
                                                                            }, {
                                                                                readonly target: "Playing";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }>) => boolean;
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>;
                                                                            }, {
                                                                                readonly target: "Speaking";
                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent>) => void];
                                                                            }];
                                                                        };
                                                                    };
                                                                    readonly BufferedSpeaker: {
                                                                        readonly type: "parallel";
                                                                        readonly invoke: {
                                                                            readonly id: "createEventsFromStream";
                                                                            readonly src: "createEventsFromStream";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => Agenda;
                                                                        };
                                                                        readonly on: {
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly states: {
                                                                            readonly Buffer: {
                                                                                readonly initial: "BufferIdle";
                                                                                readonly on: {
                                                                                    readonly STREAMING_SET_VOICE: {
                                                                                        readonly actions: "assignCurrentVoice";
                                                                                    };
                                                                                    readonly STREAMING_SET_LOCALE: {
                                                                                        readonly actions: "assignCurrentLocale";
                                                                                    };
                                                                                    readonly STREAMING_SET_PERSONA: {
                                                                                        readonly actions: "sendParentCurrentPersona";
                                                                                    };
                                                                                };
                                                                                readonly states: {
                                                                                    readonly BufferIdle: {
                                                                                        readonly id: "BufferIdle";
                                                                                        readonly on: {
                                                                                            readonly STREAMING_CHUNK: {
                                                                                                readonly target: "Buffering";
                                                                                            };
                                                                                            readonly STREAMING_DONE: "BufferingDone";
                                                                                        };
                                                                                    };
                                                                                    readonly Buffering: {
                                                                                        readonly id: "Buffering";
                                                                                        readonly on: {
                                                                                            readonly STREAMING_CHUNK: {
                                                                                                readonly target: "Buffering";
                                                                                                readonly reenter: true;
                                                                                            };
                                                                                            readonly STREAMING_DONE: "BufferingDone";
                                                                                        };
                                                                                        readonly after: {
                                                                                            readonly STREAMING_TIMEOUT: {
                                                                                                readonly target: "BufferingDone";
                                                                                                readonly actions: () => void;
                                                                                            };
                                                                                        };
                                                                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                    };
                                                                                    readonly BufferingDone: {
                                                                                        readonly id: "BufferingDone";
                                                                                        readonly type: "final";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly Speaker: {
                                                                                readonly initial: "SpeakingIdle";
                                                                                readonly states: {
                                                                                    readonly SpeakingIdle: {
                                                                                        readonly id: "SpeakingIdle";
                                                                                        readonly always: readonly [{
                                                                                            readonly target: "Speak";
                                                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                checkCache: {
                                                                                                    src: "checkCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudioFromCache: {
                                                                                                    src: "getAudioFromCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudio: {
                                                                                                    src: "getAudio";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioURL: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                playAudio: {
                                                                                                    src: "playAudio";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioBuffer: AudioBuffer;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                createEventsFromStream: {
                                                                                                    src: "createEventsFromStream";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                ponyfill: {
                                                                                                    src: "ponyfill";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                start: {
                                                                                                    src: "start";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        ttsLexicon: string;
                                                                                                        locale: string;
                                                                                                        wsaUtt: {
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        visemes?: boolean;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                checkCache: {
                                                                                                    src: "checkCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudioFromCache: {
                                                                                                    src: "getAudioFromCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudio: {
                                                                                                    src: "getAudio";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioURL: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                playAudio: {
                                                                                                    src: "playAudio";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioBuffer: AudioBuffer;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                createEventsFromStream: {
                                                                                                    src: "createEventsFromStream";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                ponyfill: {
                                                                                                    src: "ponyfill";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                start: {
                                                                                                    src: "start";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        ttsLexicon: string;
                                                                                                        locale: string;
                                                                                                        wsaUtt: {
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        visemes?: boolean;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                            }>, never, never, never, never>];
                                                                                        }, {
                                                                                            readonly target: "PrepareSpeech";
                                                                                            readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                                                        }];
                                                                                        readonly after: {
                                                                                            readonly FILLER_DELAY: {
                                                                                                readonly target: "SpeakingIdle";
                                                                                                readonly reenter: true;
                                                                                                readonly actions: "addFiller";
                                                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                    readonly PrepareSpeech: {
                                                                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                        readonly always: readonly [{
                                                                                            readonly target: "Speak";
                                                                                        }];
                                                                                    };
                                                                                    readonly Speak: {
                                                                                        readonly initial: "Init";
                                                                                        readonly states: {
                                                                                            readonly Init: {
                                                                                                readonly always: readonly [{
                                                                                                    readonly target: "CheckCache";
                                                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                                }, {
                                                                                                    readonly target: "Go";
                                                                                                }];
                                                                                            };
                                                                                            readonly CheckCache: {
                                                                                                readonly invoke: {
                                                                                                    readonly src: "checkCache";
                                                                                                    readonly input: ({ context }: {
                                                                                                        context: import("./types").TTSContext;
                                                                                                        event: import("./types").TTSEvent;
                                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                    }) => {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    };
                                                                                                    readonly onError: "Go";
                                                                                                    readonly onDone: readonly [{
                                                                                                        readonly target: "UseCache";
                                                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                                                    }, {
                                                                                                        readonly target: "Go";
                                                                                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                                                    }];
                                                                                                };
                                                                                            };
                                                                                            readonly UseCache: {
                                                                                                readonly initial: "GetAudio";
                                                                                                readonly states: {
                                                                                                    readonly GetAudio: {
                                                                                                        readonly invoke: {
                                                                                                            readonly src: "getAudioFromCache";
                                                                                                            readonly input: ({ context }: {
                                                                                                                context: import("./types").TTSContext;
                                                                                                                event: import("./types").TTSEvent;
                                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                            }) => {
                                                                                                                audioContext: AudioContext;
                                                                                                                cacheURL: string;
                                                                                                                utterance: string;
                                                                                                                voice: string;
                                                                                                                locale: string;
                                                                                                            };
                                                                                                            readonly onDone: {
                                                                                                                readonly target: "PlayAudio";
                                                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                                    checkCache: {
                                                                                                                        src: "checkCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudioFromCache: {
                                                                                                                        src: "getAudioFromCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudio: {
                                                                                                                        src: "getAudio";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioURL: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    playAudio: {
                                                                                                                        src: "playAudio";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioBuffer: AudioBuffer;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    createEventsFromStream: {
                                                                                                                        src: "createEventsFromStream";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    ponyfill: {
                                                                                                                        src: "ponyfill";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    start: {
                                                                                                                        src: "start";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            ttsLexicon: string;
                                                                                                                            locale: string;
                                                                                                                            wsaUtt: {
                                                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                                                            };
                                                                                                                            wsaTTS: SpeechSynthesis;
                                                                                                                            visemes?: boolean;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                }>, never, never, never, never>;
                                                                                                            };
                                                                                                            readonly onError: "#TtsStreamGo";
                                                                                                        };
                                                                                                    };
                                                                                                    readonly PlayAudio: {
                                                                                                        readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                                                        readonly invoke: {
                                                                                                            readonly src: "playAudio";
                                                                                                            readonly input: ({ context }: {
                                                                                                                context: import("./types").TTSContext;
                                                                                                                event: import("./types").TTSEvent;
                                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                            }) => {
                                                                                                                audioBuffer: AudioBuffer;
                                                                                                                audioContext: AudioContext;
                                                                                                            };
                                                                                                        };
                                                                                                        readonly on: {
                                                                                                            readonly CONTROL: "PausedAudio";
                                                                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                                                                readonly target: "#SpeakingDone";
                                                                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                                                    type: "SPEAK_COMPLETE";
                                                                                                                }, unknown, any>;
                                                                                                            }, {
                                                                                                                readonly target: "#SpeakingIdle";
                                                                                                            }];
                                                                                                            readonly TTS_STARTED: {
                                                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                                    type: "TTS_STARTED";
                                                                                                                    value?: AudioBufferSourceNode;
                                                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                                    type: "TTS_STARTED";
                                                                                                                    value?: AudioBufferSourceNode;
                                                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                                    checkCache: {
                                                                                                                        src: "checkCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudioFromCache: {
                                                                                                                        src: "getAudioFromCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudio: {
                                                                                                                        src: "getAudio";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioURL: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    playAudio: {
                                                                                                                        src: "playAudio";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioBuffer: AudioBuffer;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    createEventsFromStream: {
                                                                                                                        src: "createEventsFromStream";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    ponyfill: {
                                                                                                                        src: "ponyfill";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    start: {
                                                                                                                        src: "start";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            ttsLexicon: string;
                                                                                                                            locale: string;
                                                                                                                            wsaUtt: {
                                                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                                                            };
                                                                                                                            wsaTTS: SpeechSynthesis;
                                                                                                                            visemes?: boolean;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                }>, never, never, never, never>];
                                                                                                            };
                                                                                                        };
                                                                                                        readonly exit: "ttsStop";
                                                                                                    };
                                                                                                    readonly PausedAudio: {
                                                                                                        readonly on: {
                                                                                                            readonly CONTROL: "PlayAudio";
                                                                                                        };
                                                                                                    };
                                                                                                };
                                                                                            };
                                                                                            readonly Go: {
                                                                                                readonly id: "TtsStreamGo";
                                                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                                readonly invoke: {
                                                                                                    readonly src: "start";
                                                                                                    readonly input: ({ context }: {
                                                                                                        context: import("./types").TTSContext;
                                                                                                        event: import("./types").TTSEvent;
                                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                    }) => {
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        wsaUtt: {
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        ttsLexicon: string;
                                                                                                        visemes: boolean;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                        utterance: string;
                                                                                                    };
                                                                                                };
                                                                                                readonly on: {
                                                                                                    readonly CONTROL: "Paused";
                                                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                                                        readonly target: "#SpeakingDone";
                                                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                                            type: "SPEAK_COMPLETE";
                                                                                                        }, unknown, any>;
                                                                                                    }, {
                                                                                                        readonly target: "#SpeakingIdle";
                                                                                                    }];
                                                                                                    readonly TTS_STARTED: {
                                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                            type: "TTS_STARTED";
                                                                                                            value?: AudioBufferSourceNode;
                                                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                                                    };
                                                                                                };
                                                                                                readonly exit: "ttsStop";
                                                                                            };
                                                                                            readonly Paused: {
                                                                                                readonly on: {
                                                                                                    readonly CONTROL: "Go";
                                                                                                };
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                    readonly SpeakingDone: {
                                                                                        readonly id: "SpeakingDone";
                                                                                        readonly type: "final";
                                                                                    };
                                                                                };
                                                                            };
                                                                        };
                                                                        readonly onDone: {
                                                                            readonly target: "Idle";
                                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        };
                                                                    };
                                                                    readonly Playing: {
                                                                        readonly on: {
                                                                            readonly SPEAK_COMPLETE: {
                                                                                readonly target: "Idle";
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK_COMPLETE";
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>];
                                                                            };
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly initial: "FetchAudio";
                                                                        readonly states: {
                                                                            readonly FetchAudio: {
                                                                                readonly invoke: {
                                                                                    readonly src: "getAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        audioURL: string;
                                                                                    };
                                                                                    readonly onDone: {
                                                                                        readonly target: "PlayAudio";
                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>;
                                                                                    };
                                                                                    readonly onError: {
                                                                                        readonly target: "#Speaking";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly PlayAudio: {
                                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly invoke: {
                                                                                    readonly src: "playAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        audioBuffer: AudioBuffer;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "AudioPaused";
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly AudioPaused: {
                                                                                readonly on: {
                                                                                    readonly CONTROL: "PlayAudio";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Speaking: {
                                                                        readonly id: "Speaking";
                                                                        readonly initial: "Go";
                                                                        readonly on: {
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                            readonly VISEME: {
                                                                                readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                                                    type: "VISEME";
                                                                                    value: any;
                                                                                }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                                                            };
                                                                            readonly SPEAK_COMPLETE: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        readonly states: {
                                                                            readonly Go: {
                                                                                readonly invoke: {
                                                                                    readonly src: "start";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        wsaTTS: SpeechSynthesis;
                                                                                        wsaUtt: {
                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                        };
                                                                                        ttsLexicon: string;
                                                                                        voice: string;
                                                                                        visemes: boolean;
                                                                                        locale: string;
                                                                                        utterance: string;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "Paused";
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly Paused: {
                                                                                readonly on: {
                                                                                    readonly SPEAK_COMPLETE: {};
                                                                                    readonly CONTROL: "Go";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly MaybeHandleNewTokens: {
                                                        readonly initial: "Choice";
                                                        readonly states: {
                                                            readonly Choice: {
                                                                readonly always: readonly [{
                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                    readonly target: "Ponyfill";
                                                                }, {
                                                                    readonly target: "NoPonyfill";
                                                                }];
                                                            };
                                                            readonly NoPonyfill: {
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly Ponyfill: {
                                                                readonly invoke: {
                                                                    readonly id: "ponyTTS";
                                                                    readonly src: "ponyfill";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        azureAuthorizationToken: string;
                                                                        azureRegion: string;
                                                                        audioContext: AudioContext;
                                                                    };
                                                                };
                                                                readonly on: {
                                                                    readonly READY: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "READY";
                                                                            value: {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                            };
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    };
                                                                    readonly NEW_TOKEN: {
                                                                        readonly target: "Ponyfill";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "NEW_TOKEN";
                                                                            value: string;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                        readonly reenter: true;
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        asr: {
                                            src: "asr";
                                            logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                maybe_ponyfill: {
                                                    src: "maybe_ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                nluPromise: {
                                                    src: "nluPromise";
                                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                        query: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                raise_noinput_after_timeout: {
                                                    type: "raise_noinput_after_timeout";
                                                    params: {};
                                                };
                                                cancel_noinput_timeout: {
                                                    type: "cancel_noinput_timeout";
                                                    params: {};
                                                };
                                            }>, {
                                                type: "nlu_is_activated";
                                                params: unknown;
                                            }, "noinputTimeout", "Ready" | "Fail" | {
                                                Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                                                    Pausing: "Paused" | "WaitToPause" | "Continue";
                                                };
                                            }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "asr";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "maybe_ponyfill" | "nluPromise">(logic: TSrc, ...[options]: ({
                                                            src: "maybe_ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T ? T extends {
                                                            src: "maybe_ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_1 ? T_1 extends {
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_1 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_1["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_1["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            maybe_ponyfill: {
                                                                src: "maybe_ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").ASRInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    azureAuthorizationToken: string;
                                                    asrDefaultCompleteTimeout: number;
                                                    asrDefaultNoInputTimeout: number;
                                                    locale: string;
                                                    audioContext: AudioContext;
                                                    azureRegion: string;
                                                    azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                                                    speechRecognitionEndpointId: string;
                                                };
                                                readonly initial: "Ready";
                                                readonly on: {
                                                    readonly NEW_TOKEN: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                            type: "NEW_TOKEN";
                                                            value: string;
                                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                            maybe_ponyfill: {
                                                                src: "maybe_ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>;
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Fail: {};
                                                    readonly Ready: {
                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                        readonly on: {
                                                            readonly START: {
                                                                readonly target: "Recognising";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "START";
                                                                    value?: RecogniseParameters;
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    maybe_ponyfill: {
                                                                        src: "maybe_ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>;
                                                            };
                                                        };
                                                    };
                                                    readonly Recognising: {
                                                        readonly onDone: "Ready";
                                                        readonly invoke: {
                                                            readonly id: "asr";
                                                            readonly src: "maybe_ponyfill";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").ASRContext;
                                                                event: import("./types").ASREvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                azureRegion: string;
                                                                audioContext: AudioContext;
                                                                azureAuthorizationToken: string;
                                                                locale: string;
                                                                speechRecognitionEndpointId: string;
                                                                completeTimeout: number;
                                                                hints: string[];
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly FINAL_RESULT: readonly [{
                                                                readonly target: ".NLURequest";
                                                                readonly guard: {
                                                                    readonly type: "nlu_is_activated";
                                                                };
                                                            }, {
                                                                readonly target: ".WaitToStop";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "FINAL_RESULT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                            }];
                                                            readonly RESULT: {
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: Hypothesis[];
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    maybe_ponyfill: {
                                                                        src: "maybe_ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: Hypothesis[];
                                                                }, undefined, import("./types").ASREvent>];
                                                                readonly target: ".InterimResult";
                                                            };
                                                            readonly STOP: {
                                                                readonly target: ".WaitToStop";
                                                            };
                                                            readonly CONTROL: {
                                                                readonly target: ".Pausing";
                                                            };
                                                            readonly NOINPUT: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "NOINPUT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                readonly target: ".WaitToStop";
                                                            };
                                                        };
                                                        readonly initial: "WaitForRecogniser";
                                                        readonly states: {
                                                            readonly WaitForRecogniser: {
                                                                readonly on: {
                                                                    readonly STARTED: {
                                                                        readonly target: "NoInput";
                                                                        readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "STARTED";
                                                                            value: {
                                                                                wsaASRinstance: import("./types").MySpeechRecognition;
                                                                            };
                                                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                    };
                                                                };
                                                            };
                                                            readonly NoInput: {
                                                                readonly entry: {
                                                                    readonly type: "raise_noinput_after_timeout";
                                                                };
                                                                readonly on: {
                                                                    readonly STARTSPEECH: {
                                                                        readonly target: "InProgress";
                                                                        readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                                            type: "STARTSPEECH";
                                                                        }, undefined, import("./types").ASREvent>;
                                                                    };
                                                                };
                                                                readonly exit: {
                                                                    readonly type: "cancel_noinput_timeout";
                                                                };
                                                            };
                                                            readonly InProgress: {
                                                                readonly entry: () => void;
                                                            };
                                                            readonly InterimResult: {
                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                            };
                                                            readonly WaitToStop: {
                                                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                readonly on: {
                                                                    readonly LISTEN_COMPLETE: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "LISTEN_COMPLETE";
                                                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly target: "Stopped";
                                                                    };
                                                                };
                                                            };
                                                            readonly Pausing: {
                                                                readonly onDone: "#asr.Recognising";
                                                                readonly initial: "WaitToPause";
                                                                readonly states: {
                                                                    readonly WaitToPause: {
                                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly on: {
                                                                            readonly LISTEN_COMPLETE: {
                                                                                readonly target: "Paused";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Paused: {
                                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly on: {
                                                                            readonly CONTROL: {
                                                                                readonly target: "Continue";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Continue: {
                                                                        readonly type: "final";
                                                                    };
                                                                };
                                                            };
                                                            readonly NLURequest: {
                                                                readonly invoke: {
                                                                    readonly src: "nluPromise";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").ASRContext;
                                                                        event: import("./types").ASREvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        endpoint: string;
                                                                        key: string;
                                                                        projectName: string;
                                                                        deploymentName: string;
                                                                        query: string;
                                                                        locale: string;
                                                                    };
                                                                    readonly onDone: readonly [{
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                                                    }, {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                    }];
                                                                    readonly onError: {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                    };
                                                                };
                                                            };
                                                            readonly Stopped: {
                                                                readonly type: "final";
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        visemes: {
                                            src: "visemes";
                                            logic: import("xstate").StateMachine<{
                                                queue: number[];
                                            }, {
                                                type: "VISEME";
                                                value: any;
                                            }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly context: {
                                                    readonly queue: [];
                                                };
                                                readonly initial: "Init";
                                                readonly states: {
                                                    readonly Init: {
                                                        readonly on: {
                                                            readonly VISEME: readonly [{
                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                                                    queue: number[];
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }>) => boolean;
                                                                readonly actions: readonly [import("xstate").ActionFunction<{
                                                                    queue: number[];
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }, undefined, never, never, never, never, never>];
                                                            }];
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                };
                                readonly onError: {
                                    readonly actions: ({ event }: import("xstate").ActionArgs<SSContext, import("xstate").ErrorActorEvent<unknown, string>, SpeechStateEvent>) => void;
                                    readonly target: "Fail";
                                };
                            };
                        };
                        readonly Spawn: {
                            readonly entry: readonly [{
                                readonly type: "spawnTTS";
                            }, {
                                readonly type: "spawnASR";
                            }];
                            readonly after: {
                                readonly NEW_TOKEN_INTERVAL: {
                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<SSContext, SpeechStateEvent>) => boolean;
                                    readonly target: "GenerateNewTokens";
                                    readonly actions: ({}: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => void;
                                };
                            };
                        };
                        readonly GenerateNewTokens: {
                            readonly invoke: {
                                readonly id: "getNewAuthorizationToken";
                                readonly input: ({ context }: {
                                    context: any;
                                }) => {
                                    credentials: any;
                                };
                                readonly src: "getToken";
                                readonly onDone: {
                                    readonly actions: readonly [import("xstate").ActionFunction<SSContext, import("xstate").DoneActorEvent<string, string>, SpeechStateEvent, undefined, import("xstate").Values<{
                                        audioContext: {
                                            src: "audioContext";
                                            logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        tts: {
                                            src: "tts";
                                            logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    cacheURL: string;
                                                    utterance: string;
                                                    voice: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, {
                                                    audioContext: AudioContext;
                                                    audioURL: string;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                    audioContext: AudioContext;
                                                    audioBuffer: AudioBuffer;
                                                }, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, {
                                                    utterance: string;
                                                    voice: string;
                                                    ttsLexicon: string;
                                                    locale: string;
                                                    wsaUtt: {
                                                        prototype: SpeechSynthesisUtterance;
                                                        new (text?: string): SpeechSynthesisUtterance;
                                                    };
                                                    wsaTTS: SpeechSynthesis;
                                                    visemes?: boolean;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                checkCache: {
                                                    src: "checkCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudioFromCache: {
                                                    src: "getAudioFromCache";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        cacheURL: string;
                                                        utterance: string;
                                                        voice: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                getAudio: {
                                                    src: "getAudio";
                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                        audioContext: AudioContext;
                                                        audioURL: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                playAudio: {
                                                    src: "playAudio";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                        audioContext: AudioContext;
                                                        audioBuffer: AudioBuffer;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                        utterance: string;
                                                        voice: string;
                                                        ttsLexicon: string;
                                                        locale: string;
                                                        wsaUtt: {
                                                            prototype: SpeechSynthesisUtterance;
                                                            new (text?: string): SpeechSynthesisUtterance;
                                                        };
                                                        wsaTTS: SpeechSynthesis;
                                                        visemes?: boolean;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                ttsStop: {
                                                    type: "ttsStop";
                                                    params: unknown;
                                                };
                                                addFiller: {
                                                    type: "addFiller";
                                                    params: {};
                                                };
                                                assignCurrentVoice: {
                                                    type: "assignCurrentVoice";
                                                    params: {};
                                                };
                                                assignCurrentLocale: {
                                                    type: "assignCurrentLocale";
                                                    params: {};
                                                };
                                                sendParentCurrentPersona: {
                                                    type: "sendParentCurrentPersona";
                                                    params: {};
                                                };
                                            }>, import("xstate").Values<{
                                                bufferContainsUtterancePartReadyToBeSpoken: {
                                                    type: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    params: unknown;
                                                };
                                                bufferIsNonEmpty: {
                                                    type: "bufferIsNonEmpty";
                                                    params: unknown;
                                                };
                                            }>, "FILLER_DELAY" | "STREAMING_TIMEOUT", {
                                                Operation: "NotReady" | {
                                                    Ready: "Idle" | {
                                                        BufferedSpeaker: {
                                                            Buffer: "BufferIdle" | "Buffering" | "BufferingDone";
                                                            Speaker: "SpeakingIdle" | "PrepareSpeech" | "SpeakingDone" | {
                                                                Speak: "Init" | "CheckCache" | "Go" | "Paused" | {
                                                                    UseCache: "GetAudio" | "PlayAudio" | "PausedAudio";
                                                                };
                                                            };
                                                        };
                                                    } | {
                                                        Playing: "PlayAudio" | "FetchAudio" | "AudioPaused";
                                                    } | {
                                                        Speaking: "Go" | "Paused";
                                                    };
                                                };
                                                MaybeHandleNewTokens: "Choice" | "Ponyfill" | "NoPonyfill";
                                            }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "tts";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "checkCache" | "getAudioFromCache" | "getAudio" | "playAudio" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T ? T extends {
                                                            src: "checkCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_1 ? T_1 extends {
                                                            src: "getAudioFromCache";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                cacheURL: string;
                                                                utterance: string;
                                                                voice: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_1 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_1["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_1["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_2 ? T_2 extends {
                                                            src: "getAudio";
                                                            logic: import("xstate").PromiseActorLogic<any, {
                                                                audioContext: AudioContext;
                                                                audioURL: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_2 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_2["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_2["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_3 ? T_3 extends {
                                                            src: "playAudio";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                audioContext: AudioContext;
                                                                audioBuffer: AudioBuffer;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_3 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_3["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_3["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never) | ({
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_4 ? T_4 extends {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_4 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_4["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_4["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_5 ? T_5 extends {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_5 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_5["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_5["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_6 ? T_6 extends {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<null, {
                                                                utterance: string;
                                                                voice: string;
                                                                ttsLexicon: string;
                                                                locale: string;
                                                                wsaUtt: {
                                                                    prototype: SpeechSynthesisUtterance;
                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                };
                                                                wsaTTS: SpeechSynthesis;
                                                                visemes?: boolean;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_6 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_6["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_6["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            checkCache: {
                                                                src: "checkCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudioFromCache: {
                                                                src: "getAudioFromCache";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    cacheURL: string;
                                                                    utterance: string;
                                                                    voice: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            getAudio: {
                                                                src: "getAudio";
                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                    audioContext: AudioContext;
                                                                    audioURL: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            playAudio: {
                                                                src: "playAudio";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                    audioContext: AudioContext;
                                                                    audioBuffer: AudioBuffer;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                    utterance: string;
                                                                    voice: string;
                                                                    ttsLexicon: string;
                                                                    locale: string;
                                                                    wsaUtt: {
                                                                        prototype: SpeechSynthesisUtterance;
                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                    };
                                                                    wsaTTS: SpeechSynthesis;
                                                                    visemes?: boolean;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").TTSInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    azureAuthorizationToken: string;
                                                    ttsDefaultVoice: string;
                                                    ttsDefaultFillerDelay: number;
                                                    ttsDefaultFiller: string;
                                                    ttsLexicon: string;
                                                    audioContext: AudioContext;
                                                    azureRegion: string;
                                                    locale: string;
                                                    buffer: string;
                                                };
                                                readonly on: {
                                                    readonly ERROR: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "ERROR";
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                    };
                                                };
                                                readonly type: "parallel";
                                                readonly states: {
                                                    readonly Operation: {
                                                        readonly initial: "NotReady";
                                                        readonly states: {
                                                            readonly NotReady: {
                                                                readonly on: {
                                                                    readonly READY: {
                                                                        readonly target: "Ready";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "READY";
                                                                            value: {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                            };
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                    };
                                                                };
                                                            };
                                                            readonly Ready: {
                                                                readonly initial: "Idle";
                                                                readonly states: {
                                                                    readonly Idle: {
                                                                        readonly id: "Idle";
                                                                        readonly on: {
                                                                            readonly SPEAK: readonly [{
                                                                                readonly target: "BufferedSpeaker";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }>) => boolean;
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>;
                                                                            }, {
                                                                                readonly target: "Playing";
                                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }>) => boolean;
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>;
                                                                            }, {
                                                                                readonly target: "Speaking";
                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent>) => void, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                    type: "SPEAK";
                                                                                    value: Agenda;
                                                                                }, import("./types").TTSEvent>) => void];
                                                                            }];
                                                                        };
                                                                    };
                                                                    readonly BufferedSpeaker: {
                                                                        readonly type: "parallel";
                                                                        readonly invoke: {
                                                                            readonly id: "createEventsFromStream";
                                                                            readonly src: "createEventsFromStream";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => Agenda;
                                                                        };
                                                                        readonly on: {
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly states: {
                                                                            readonly Buffer: {
                                                                                readonly initial: "BufferIdle";
                                                                                readonly on: {
                                                                                    readonly STREAMING_SET_VOICE: {
                                                                                        readonly actions: "assignCurrentVoice";
                                                                                    };
                                                                                    readonly STREAMING_SET_LOCALE: {
                                                                                        readonly actions: "assignCurrentLocale";
                                                                                    };
                                                                                    readonly STREAMING_SET_PERSONA: {
                                                                                        readonly actions: "sendParentCurrentPersona";
                                                                                    };
                                                                                };
                                                                                readonly states: {
                                                                                    readonly BufferIdle: {
                                                                                        readonly id: "BufferIdle";
                                                                                        readonly on: {
                                                                                            readonly STREAMING_CHUNK: {
                                                                                                readonly target: "Buffering";
                                                                                            };
                                                                                            readonly STREAMING_DONE: "BufferingDone";
                                                                                        };
                                                                                    };
                                                                                    readonly Buffering: {
                                                                                        readonly id: "Buffering";
                                                                                        readonly on: {
                                                                                            readonly STREAMING_CHUNK: {
                                                                                                readonly target: "Buffering";
                                                                                                readonly reenter: true;
                                                                                            };
                                                                                            readonly STREAMING_DONE: "BufferingDone";
                                                                                        };
                                                                                        readonly after: {
                                                                                            readonly STREAMING_TIMEOUT: {
                                                                                                readonly target: "BufferingDone";
                                                                                                readonly actions: () => void;
                                                                                            };
                                                                                        };
                                                                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                    };
                                                                                    readonly BufferingDone: {
                                                                                        readonly id: "BufferingDone";
                                                                                        readonly type: "final";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly Speaker: {
                                                                                readonly initial: "SpeakingIdle";
                                                                                readonly states: {
                                                                                    readonly SpeakingIdle: {
                                                                                        readonly id: "SpeakingIdle";
                                                                                        readonly always: readonly [{
                                                                                            readonly target: "Speak";
                                                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                checkCache: {
                                                                                                    src: "checkCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudioFromCache: {
                                                                                                    src: "getAudioFromCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudio: {
                                                                                                    src: "getAudio";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioURL: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                playAudio: {
                                                                                                    src: "playAudio";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioBuffer: AudioBuffer;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                createEventsFromStream: {
                                                                                                    src: "createEventsFromStream";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                ponyfill: {
                                                                                                    src: "ponyfill";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                start: {
                                                                                                    src: "start";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        ttsLexicon: string;
                                                                                                        locale: string;
                                                                                                        wsaUtt: {
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        visemes?: boolean;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                checkCache: {
                                                                                                    src: "checkCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudioFromCache: {
                                                                                                    src: "getAudioFromCache";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                getAudio: {
                                                                                                    src: "getAudio";
                                                                                                    logic: import("xstate").PromiseActorLogic<any, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioURL: string;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                playAudio: {
                                                                                                    src: "playAudio";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                        audioContext: AudioContext;
                                                                                                        audioBuffer: AudioBuffer;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                createEventsFromStream: {
                                                                                                    src: "createEventsFromStream";
                                                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                ponyfill: {
                                                                                                    src: "ponyfill";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                                start: {
                                                                                                    src: "start";
                                                                                                    logic: import("xstate").CallbackActorLogic<null, {
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        ttsLexicon: string;
                                                                                                        locale: string;
                                                                                                        wsaUtt: {
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        visemes?: boolean;
                                                                                                    }, import("xstate").EventObject>;
                                                                                                    id: string;
                                                                                                };
                                                                                            }>, never, never, never, never>];
                                                                                        }, {
                                                                                            readonly target: "PrepareSpeech";
                                                                                            readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                                                        }];
                                                                                        readonly after: {
                                                                                            readonly FILLER_DELAY: {
                                                                                                readonly target: "SpeakingIdle";
                                                                                                readonly reenter: true;
                                                                                                readonly actions: "addFiller";
                                                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                    readonly PrepareSpeech: {
                                                                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>];
                                                                                        readonly always: readonly [{
                                                                                            readonly target: "Speak";
                                                                                        }];
                                                                                    };
                                                                                    readonly Speak: {
                                                                                        readonly initial: "Init";
                                                                                        readonly states: {
                                                                                            readonly Init: {
                                                                                                readonly always: readonly [{
                                                                                                    readonly target: "CheckCache";
                                                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                                }, {
                                                                                                    readonly target: "Go";
                                                                                                }];
                                                                                            };
                                                                                            readonly CheckCache: {
                                                                                                readonly invoke: {
                                                                                                    readonly src: "checkCache";
                                                                                                    readonly input: ({ context }: {
                                                                                                        context: import("./types").TTSContext;
                                                                                                        event: import("./types").TTSEvent;
                                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                    }) => {
                                                                                                        cacheURL: string;
                                                                                                        utterance: string;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                    };
                                                                                                    readonly onError: "Go";
                                                                                                    readonly onDone: readonly [{
                                                                                                        readonly target: "UseCache";
                                                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>>) => any;
                                                                                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                                                    }, {
                                                                                                        readonly target: "Go";
                                                                                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent>) => void;
                                                                                                    }];
                                                                                                };
                                                                                            };
                                                                                            readonly UseCache: {
                                                                                                readonly initial: "GetAudio";
                                                                                                readonly states: {
                                                                                                    readonly GetAudio: {
                                                                                                        readonly invoke: {
                                                                                                            readonly src: "getAudioFromCache";
                                                                                                            readonly input: ({ context }: {
                                                                                                                context: import("./types").TTSContext;
                                                                                                                event: import("./types").TTSEvent;
                                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                            }) => {
                                                                                                                audioContext: AudioContext;
                                                                                                                cacheURL: string;
                                                                                                                utterance: string;
                                                                                                                voice: string;
                                                                                                                locale: string;
                                                                                                            };
                                                                                                            readonly onDone: {
                                                                                                                readonly target: "PlayAudio";
                                                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                                    checkCache: {
                                                                                                                        src: "checkCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudioFromCache: {
                                                                                                                        src: "getAudioFromCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudio: {
                                                                                                                        src: "getAudio";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioURL: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    playAudio: {
                                                                                                                        src: "playAudio";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioBuffer: AudioBuffer;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    createEventsFromStream: {
                                                                                                                        src: "createEventsFromStream";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    ponyfill: {
                                                                                                                        src: "ponyfill";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    start: {
                                                                                                                        src: "start";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            ttsLexicon: string;
                                                                                                                            locale: string;
                                                                                                                            wsaUtt: {
                                                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                                                            };
                                                                                                                            wsaTTS: SpeechSynthesis;
                                                                                                                            visemes?: boolean;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                }>, never, never, never, never>;
                                                                                                            };
                                                                                                            readonly onError: "#TtsStreamGo";
                                                                                                        };
                                                                                                    };
                                                                                                    readonly PlayAudio: {
                                                                                                        readonly entry: ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void;
                                                                                                        readonly invoke: {
                                                                                                            readonly src: "playAudio";
                                                                                                            readonly input: ({ context }: {
                                                                                                                context: import("./types").TTSContext;
                                                                                                                event: import("./types").TTSEvent;
                                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                            }) => {
                                                                                                                audioBuffer: AudioBuffer;
                                                                                                                audioContext: AudioContext;
                                                                                                            };
                                                                                                        };
                                                                                                        readonly on: {
                                                                                                            readonly CONTROL: "PausedAudio";
                                                                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                                                                readonly target: "#SpeakingDone";
                                                                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                                                    type: "SPEAK_COMPLETE";
                                                                                                                }, unknown, any>;
                                                                                                            }, {
                                                                                                                readonly target: "#SpeakingIdle";
                                                                                                            }];
                                                                                                            readonly TTS_STARTED: {
                                                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                                    type: "TTS_STARTED";
                                                                                                                    value?: AudioBufferSourceNode;
                                                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                                    type: "TTS_STARTED";
                                                                                                                    value?: AudioBufferSourceNode;
                                                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                                                    checkCache: {
                                                                                                                        src: "checkCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudioFromCache: {
                                                                                                                        src: "getAudioFromCache";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            cacheURL: string;
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            locale: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    getAudio: {
                                                                                                                        src: "getAudio";
                                                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioURL: string;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    playAudio: {
                                                                                                                        src: "playAudio";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                                            audioContext: AudioContext;
                                                                                                                            audioBuffer: AudioBuffer;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    createEventsFromStream: {
                                                                                                                        src: "createEventsFromStream";
                                                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    ponyfill: {
                                                                                                                        src: "ponyfill";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                    start: {
                                                                                                                        src: "start";
                                                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                                                            utterance: string;
                                                                                                                            voice: string;
                                                                                                                            ttsLexicon: string;
                                                                                                                            locale: string;
                                                                                                                            wsaUtt: {
                                                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                                                            };
                                                                                                                            wsaTTS: SpeechSynthesis;
                                                                                                                            visemes?: boolean;
                                                                                                                        }, import("xstate").EventObject>;
                                                                                                                        id: string;
                                                                                                                    };
                                                                                                                }>, never, never, never, never>];
                                                                                                            };
                                                                                                        };
                                                                                                        readonly exit: "ttsStop";
                                                                                                    };
                                                                                                    readonly PausedAudio: {
                                                                                                        readonly on: {
                                                                                                            readonly CONTROL: "PlayAudio";
                                                                                                        };
                                                                                                    };
                                                                                                };
                                                                                            };
                                                                                            readonly Go: {
                                                                                                readonly id: "TtsStreamGo";
                                                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                                readonly invoke: {
                                                                                                    readonly src: "start";
                                                                                                    readonly input: ({ context }: {
                                                                                                        context: import("./types").TTSContext;
                                                                                                        event: import("./types").TTSEvent;
                                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                                    }) => {
                                                                                                        wsaTTS: SpeechSynthesis;
                                                                                                        wsaUtt: {
                                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                                        };
                                                                                                        ttsLexicon: string;
                                                                                                        visemes: boolean;
                                                                                                        voice: string;
                                                                                                        locale: string;
                                                                                                        utterance: string;
                                                                                                    };
                                                                                                };
                                                                                                readonly on: {
                                                                                                    readonly CONTROL: "Paused";
                                                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                                                        readonly target: "#SpeakingDone";
                                                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                                            type: "SPEAK_COMPLETE";
                                                                                                        }, unknown, any>;
                                                                                                    }, {
                                                                                                        readonly target: "#SpeakingIdle";
                                                                                                    }];
                                                                                                    readonly TTS_STARTED: {
                                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                                            type: "TTS_STARTED";
                                                                                                            value?: AudioBufferSourceNode;
                                                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                                                    };
                                                                                                };
                                                                                                readonly exit: "ttsStop";
                                                                                            };
                                                                                            readonly Paused: {
                                                                                                readonly on: {
                                                                                                    readonly CONTROL: "Go";
                                                                                                };
                                                                                            };
                                                                                        };
                                                                                    };
                                                                                    readonly SpeakingDone: {
                                                                                        readonly id: "SpeakingDone";
                                                                                        readonly type: "final";
                                                                                    };
                                                                                };
                                                                            };
                                                                        };
                                                                        readonly onDone: {
                                                                            readonly target: "Idle";
                                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneStateEvent<unknown>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        };
                                                                    };
                                                                    readonly Playing: {
                                                                        readonly on: {
                                                                            readonly SPEAK_COMPLETE: {
                                                                                readonly target: "Idle";
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "SPEAK_COMPLETE";
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    checkCache: {
                                                                                        src: "checkCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudioFromCache: {
                                                                                        src: "getAudioFromCache";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            cacheURL: string;
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            locale: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    getAudio: {
                                                                                        src: "getAudio";
                                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                                            audioContext: AudioContext;
                                                                                            audioURL: string;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    playAudio: {
                                                                                        src: "playAudio";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                            audioContext: AudioContext;
                                                                                            audioBuffer: AudioBuffer;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                                            utterance: string;
                                                                                            voice: string;
                                                                                            ttsLexicon: string;
                                                                                            locale: string;
                                                                                            wsaUtt: {
                                                                                                prototype: SpeechSynthesisUtterance;
                                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                                            };
                                                                                            wsaTTS: SpeechSynthesis;
                                                                                            visemes?: boolean;
                                                                                        }, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>];
                                                                            };
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly initial: "FetchAudio";
                                                                        readonly states: {
                                                                            readonly FetchAudio: {
                                                                                readonly invoke: {
                                                                                    readonly src: "getAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        audioURL: string;
                                                                                    };
                                                                                    readonly onDone: {
                                                                                        readonly target: "PlayAudio";
                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<any, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                            checkCache: {
                                                                                                src: "checkCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudioFromCache: {
                                                                                                src: "getAudioFromCache";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    cacheURL: string;
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    locale: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            getAudio: {
                                                                                                src: "getAudio";
                                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioURL: string;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            playAudio: {
                                                                                                src: "playAudio";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                                    audioContext: AudioContext;
                                                                                                    audioBuffer: AudioBuffer;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            createEventsFromStream: {
                                                                                                src: "createEventsFromStream";
                                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            ponyfill: {
                                                                                                src: "ponyfill";
                                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                            start: {
                                                                                                src: "start";
                                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                                    utterance: string;
                                                                                                    voice: string;
                                                                                                    ttsLexicon: string;
                                                                                                    locale: string;
                                                                                                    wsaUtt: {
                                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                                    };
                                                                                                    wsaTTS: SpeechSynthesis;
                                                                                                    visemes?: boolean;
                                                                                                }, import("xstate").EventObject>;
                                                                                                id: string;
                                                                                            };
                                                                                        }>, never, never, never, never>;
                                                                                    };
                                                                                    readonly onError: {
                                                                                        readonly target: "#Speaking";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly PlayAudio: {
                                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, ({ context }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly invoke: {
                                                                                    readonly src: "playAudio";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        audioContext: AudioContext;
                                                                                        audioBuffer: AudioBuffer;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "AudioPaused";
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly AudioPaused: {
                                                                                readonly on: {
                                                                                    readonly CONTROL: "PlayAudio";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Speaking: {
                                                                        readonly id: "Speaking";
                                                                        readonly initial: "Go";
                                                                        readonly on: {
                                                                            readonly STOP: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                            readonly TTS_STARTED: {
                                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                    type: "TTS_STARTED";
                                                                                    value?: AudioBufferSourceNode;
                                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                            };
                                                                            readonly VISEME: {
                                                                                readonly actions: import("xstate").ActionFunction<import("xstate").MachineContext, {
                                                                                    type: "VISEME";
                                                                                    value: any;
                                                                                }, import("xstate").AnyEventObject, {}, never, never, never, never, never>;
                                                                            };
                                                                            readonly SPEAK_COMPLETE: {
                                                                                readonly target: "Idle";
                                                                            };
                                                                        };
                                                                        readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>;
                                                                        readonly states: {
                                                                            readonly Go: {
                                                                                readonly invoke: {
                                                                                    readonly src: "start";
                                                                                    readonly input: ({ context }: {
                                                                                        context: import("./types").TTSContext;
                                                                                        event: import("./types").TTSEvent;
                                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                    }) => {
                                                                                        wsaTTS: SpeechSynthesis;
                                                                                        wsaUtt: {
                                                                                            new (text?: string): SpeechSynthesisUtterance;
                                                                                            prototype: SpeechSynthesisUtterance;
                                                                                        };
                                                                                        ttsLexicon: string;
                                                                                        voice: string;
                                                                                        visemes: boolean;
                                                                                        locale: string;
                                                                                        utterance: string;
                                                                                    };
                                                                                };
                                                                                readonly on: {
                                                                                    readonly CONTROL: "Paused";
                                                                                };
                                                                                readonly exit: "ttsStop";
                                                                            };
                                                                            readonly Paused: {
                                                                                readonly on: {
                                                                                    readonly SPEAK_COMPLETE: {};
                                                                                    readonly CONTROL: "Go";
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly MaybeHandleNewTokens: {
                                                        readonly initial: "Choice";
                                                        readonly states: {
                                                            readonly Choice: {
                                                                readonly always: readonly [{
                                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                    readonly target: "Ponyfill";
                                                                }, {
                                                                    readonly target: "NoPonyfill";
                                                                }];
                                                            };
                                                            readonly NoPonyfill: {
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY" | "STREAMING_TIMEOUT", never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    checkCache: {
                                                                        src: "checkCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudioFromCache: {
                                                                        src: "getAudioFromCache";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            cacheURL: string;
                                                                            utterance: string;
                                                                            voice: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    getAudio: {
                                                                        src: "getAudio";
                                                                        logic: import("xstate").PromiseActorLogic<any, {
                                                                            audioContext: AudioContext;
                                                                            audioURL: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    playAudio: {
                                                                        src: "playAudio";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                            audioContext: AudioContext;
                                                                            audioBuffer: AudioBuffer;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<null, {
                                                                            utterance: string;
                                                                            voice: string;
                                                                            ttsLexicon: string;
                                                                            locale: string;
                                                                            wsaUtt: {
                                                                                prototype: SpeechSynthesisUtterance;
                                                                                new (text?: string): SpeechSynthesisUtterance;
                                                                            };
                                                                            wsaTTS: SpeechSynthesis;
                                                                            visemes?: boolean;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly Ponyfill: {
                                                                readonly invoke: {
                                                                    readonly id: "ponyTTS";
                                                                    readonly src: "ponyfill";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        azureAuthorizationToken: string;
                                                                        azureRegion: string;
                                                                        audioContext: AudioContext;
                                                                    };
                                                                };
                                                                readonly on: {
                                                                    readonly READY: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "READY";
                                                                            value: {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: {
                                                                                    prototype: SpeechSynthesisUtterance;
                                                                                    new (text?: string): SpeechSynthesisUtterance;
                                                                                };
                                                                            };
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    };
                                                                    readonly NEW_TOKEN: {
                                                                        readonly target: "Ponyfill";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "NEW_TOKEN";
                                                                            value: string;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            checkCache: {
                                                                                src: "checkCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudioFromCache: {
                                                                                src: "getAudioFromCache";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    cacheURL: string;
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    locale: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            getAudio: {
                                                                                src: "getAudio";
                                                                                logic: import("xstate").PromiseActorLogic<any, {
                                                                                    audioContext: AudioContext;
                                                                                    audioURL: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            playAudio: {
                                                                                src: "playAudio";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {
                                                                                    audioContext: AudioContext;
                                                                                    audioBuffer: AudioBuffer;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<null, {
                                                                                    utterance: string;
                                                                                    voice: string;
                                                                                    ttsLexicon: string;
                                                                                    locale: string;
                                                                                    wsaUtt: {
                                                                                        prototype: SpeechSynthesisUtterance;
                                                                                        new (text?: string): SpeechSynthesisUtterance;
                                                                                    };
                                                                                    wsaTTS: SpeechSynthesis;
                                                                                    visemes?: boolean;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                        readonly reenter: true;
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        asr: {
                                            src: "asr";
                                            logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                    locale: string;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                maybe_ponyfill: {
                                                    src: "maybe_ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                nluPromise: {
                                                    src: "nluPromise";
                                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                        query: string;
                                                        locale: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                raise_noinput_after_timeout: {
                                                    type: "raise_noinput_after_timeout";
                                                    params: {};
                                                };
                                                cancel_noinput_timeout: {
                                                    type: "cancel_noinput_timeout";
                                                    params: {};
                                                };
                                            }>, {
                                                type: "nlu_is_activated";
                                                params: unknown;
                                            }, "noinputTimeout", "Ready" | "Fail" | {
                                                Recognising: "WaitForRecogniser" | "NoInput" | "InProgress" | "InterimResult" | "WaitToStop" | "Stopped" | "NLURequest" | {
                                                    Pausing: "Paused" | "WaitToPause" | "Continue";
                                                };
                                            }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "asr";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "maybe_ponyfill" | "nluPromise">(logic: TSrc, ...[options]: ({
                                                            src: "maybe_ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T ? T extends {
                                                            src: "maybe_ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_1 ? T_1 extends {
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                                locale: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_1 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_1["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_1["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            maybe_ponyfill: {
                                                                src: "maybe_ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").ASRInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    azureAuthorizationToken: string;
                                                    asrDefaultCompleteTimeout: number;
                                                    asrDefaultNoInputTimeout: number;
                                                    locale: string;
                                                    audioContext: AudioContext;
                                                    azureRegion: string;
                                                    azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                                                    speechRecognitionEndpointId: string;
                                                };
                                                readonly initial: "Ready";
                                                readonly on: {
                                                    readonly NEW_TOKEN: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                            type: "NEW_TOKEN";
                                                            value: string;
                                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                            maybe_ponyfill: {
                                                                src: "maybe_ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                    locale: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>;
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Fail: {};
                                                    readonly Ready: {
                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                        readonly on: {
                                                            readonly START: {
                                                                readonly target: "Recognising";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "START";
                                                                    value?: RecogniseParameters;
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    maybe_ponyfill: {
                                                                        src: "maybe_ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>;
                                                            };
                                                        };
                                                    };
                                                    readonly Recognising: {
                                                        readonly onDone: "Ready";
                                                        readonly invoke: {
                                                            readonly id: "asr";
                                                            readonly src: "maybe_ponyfill";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").ASRContext;
                                                                event: import("./types").ASREvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                azureRegion: string;
                                                                audioContext: AudioContext;
                                                                azureAuthorizationToken: string;
                                                                locale: string;
                                                                speechRecognitionEndpointId: string;
                                                                completeTimeout: number;
                                                                hints: string[];
                                                            };
                                                        };
                                                        readonly on: {
                                                            readonly FINAL_RESULT: readonly [{
                                                                readonly target: ".NLURequest";
                                                                readonly guard: {
                                                                    readonly type: "nlu_is_activated";
                                                                };
                                                            }, {
                                                                readonly target: ".WaitToStop";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "FINAL_RESULT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                            }];
                                                            readonly RESULT: {
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: Hypothesis[];
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    maybe_ponyfill: {
                                                                        src: "maybe_ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                            locale: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: Hypothesis[];
                                                                }, undefined, import("./types").ASREvent>];
                                                                readonly target: ".InterimResult";
                                                            };
                                                            readonly STOP: {
                                                                readonly target: ".WaitToStop";
                                                            };
                                                            readonly CONTROL: {
                                                                readonly target: ".Pausing";
                                                            };
                                                            readonly NOINPUT: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "NOINPUT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                readonly target: ".WaitToStop";
                                                            };
                                                        };
                                                        readonly initial: "WaitForRecogniser";
                                                        readonly states: {
                                                            readonly WaitForRecogniser: {
                                                                readonly on: {
                                                                    readonly STARTED: {
                                                                        readonly target: "NoInput";
                                                                        readonly actions: readonly [() => void, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "STARTED";
                                                                            value: {
                                                                                wsaASRinstance: import("./types").MySpeechRecognition;
                                                                            };
                                                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                    };
                                                                };
                                                            };
                                                            readonly NoInput: {
                                                                readonly entry: {
                                                                    readonly type: "raise_noinput_after_timeout";
                                                                };
                                                                readonly on: {
                                                                    readonly STARTSPEECH: {
                                                                        readonly target: "InProgress";
                                                                        readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                                            type: "STARTSPEECH";
                                                                        }, undefined, import("./types").ASREvent>;
                                                                    };
                                                                };
                                                                readonly exit: {
                                                                    readonly type: "cancel_noinput_timeout";
                                                                };
                                                            };
                                                            readonly InProgress: {
                                                                readonly entry: () => void;
                                                            };
                                                            readonly InterimResult: {
                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                            };
                                                            readonly WaitToStop: {
                                                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                readonly on: {
                                                                    readonly LISTEN_COMPLETE: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "LISTEN_COMPLETE";
                                                                        }, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly target: "Stopped";
                                                                    };
                                                                };
                                                            };
                                                            readonly Pausing: {
                                                                readonly onDone: "#asr.Recognising";
                                                                readonly initial: "WaitToPause";
                                                                readonly states: {
                                                                    readonly WaitToPause: {
                                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly on: {
                                                                            readonly LISTEN_COMPLETE: {
                                                                                readonly target: "Paused";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Paused: {
                                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>;
                                                                        readonly on: {
                                                                            readonly CONTROL: {
                                                                                readonly target: "Continue";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Continue: {
                                                                        readonly type: "final";
                                                                    };
                                                                };
                                                            };
                                                            readonly NLURequest: {
                                                                readonly invoke: {
                                                                    readonly src: "nluPromise";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").ASRContext;
                                                                        event: import("./types").ASREvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        endpoint: string;
                                                                        key: string;
                                                                        projectName: string;
                                                                        deploymentName: string;
                                                                        query: string;
                                                                        locale: string;
                                                                    };
                                                                    readonly onDone: readonly [{
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                                                    }, {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                    }];
                                                                    readonly onError: {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, "noinputTimeout", never>];
                                                                        readonly target: "WaitToStop";
                                                                    };
                                                                };
                                                            };
                                                            readonly Stopped: {
                                                                readonly type: "final";
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        visemes: {
                                            src: "visemes";
                                            logic: import("xstate").StateMachine<{
                                                queue: number[];
                                            }, {
                                                type: "VISEME";
                                                value: any;
                                            }, {}, never, never, never, never, "Init", string, {}, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly context: {
                                                    readonly queue: [];
                                                };
                                                readonly initial: "Init";
                                                readonly states: {
                                                    readonly Init: {
                                                        readonly on: {
                                                            readonly VISEME: readonly [{
                                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<{
                                                                    queue: number[];
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }>) => boolean;
                                                                readonly actions: readonly [import("xstate").ActionFunction<{
                                                                    queue: number[];
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }, {
                                                                    type: "VISEME";
                                                                    value: any;
                                                                }, undefined, never, never, never, never, never>];
                                                            }];
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>, ({ context, event }: import("xstate").ActionArgs<SSContext, import("xstate").DoneActorEvent<string, string>, SpeechStateEvent>) => any, ({ context, event }: import("xstate").ActionArgs<SSContext, import("xstate").DoneActorEvent<string, string>, SpeechStateEvent>) => any, ({}: import("xstate").ActionArgs<SSContext, import("xstate").DoneActorEvent<string, string>, SpeechStateEvent>) => void, ({}: import("xstate").ActionArgs<SSContext, import("xstate").DoneActorEvent<string, string>, SpeechStateEvent>) => void];
                                };
                                readonly onError: {
                                    readonly actions: ({ event }: import("xstate").ActionArgs<SSContext, import("xstate").ErrorActorEvent<unknown, string>, SpeechStateEvent>) => void;
                                    readonly target: "Fail";
                                };
                            };
                            readonly after: {
                                readonly NEW_TOKEN_INTERVAL: {
                                    readonly target: "GenerateNewTokens";
                                    readonly reenter: true;
                                    readonly actions: ({}: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => void;
                                };
                            };
                        };
                        readonly Fail: {
                            readonly meta: {
                                readonly view: "error";
                            };
                        };
                    };
                };
                readonly AsrTtsManager: {
                    readonly initial: "Initialize";
                    readonly on: {
                        readonly TTS_ERROR: {
                            readonly actions: () => void;
                            readonly target: ".Fail";
                        };
                        readonly ASR_NOINPUT: {
                            readonly actions: readonly [() => void, () => void, import("xstate").ActionFunction<SSContext, {
                                type: "ASR_NOINPUT";
                            }, SpeechStateEvent, undefined, never, never, never, "NEW_TOKEN_INTERVAL", never>];
                        };
                        readonly LISTEN_COMPLETE: {
                            readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                type: "LISTEN_COMPLETE";
                            }, SpeechStateEvent, undefined, never, never, never, "NEW_TOKEN_INTERVAL", never>];
                            readonly target: ".Ready";
                        };
                        readonly STOP: "#speechstate.Stopped";
                    };
                    readonly states: {
                        readonly Initialize: {
                            readonly meta: {
                                readonly view: "not-ready";
                            };
                            readonly on: {
                                readonly TTS_READY: {
                                    readonly actions: () => void;
                                    readonly target: "PreReady";
                                };
                                readonly ASR_READY: {
                                    readonly actions: () => void;
                                    readonly target: "PreReady";
                                };
                            };
                        };
                        readonly PreReady: {
                            readonly meta: {
                                readonly view: "not-ready";
                            };
                            readonly on: {
                                readonly TTS_READY: {
                                    readonly actions: () => void;
                                    readonly target: "Ready";
                                };
                                readonly ASR_READY: {
                                    readonly actions: () => void;
                                    readonly target: "Ready";
                                };
                            };
                        };
                        readonly Ready: {
                            readonly initial: "Idle";
                            readonly entry: readonly [() => void, import("xstate").ActionFunction<SSContext, SpeechStateEvent, SpeechStateEvent, undefined, never, never, never, "NEW_TOKEN_INTERVAL", never>];
                            readonly states: {
                                readonly Idle: {
                                    readonly meta: {
                                        readonly view: "idle";
                                    };
                                    readonly on: {
                                        readonly LISTEN: {
                                            readonly target: "WaitForRecogniser";
                                        };
                                        readonly SPEAK: readonly [{
                                            readonly target: "Speaking";
                                        }];
                                    };
                                };
                                readonly Speaking: {
                                    readonly invoke: {
                                        readonly id: "visemes";
                                        readonly src: "visemes";
                                        readonly input: {};
                                    };
                                    readonly initial: "Start";
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "#speechstate.Stopped";
                                            readonly actions: readonly [({}: import("xstate").ActionArgs<SSContext, {
                                                type: "STOP";
                                            }, SpeechStateEvent>) => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                type: "STOP";
                                            }, SpeechStateEvent>) => any];
                                        };
                                        readonly VISEME: {
                                            readonly actions: readonly [import("xstate").ActionFunction<SSContext, {
                                                type: "VISEME";
                                                value: any;
                                            }, SpeechStateEvent, undefined, never, never, never, "NEW_TOKEN_INTERVAL", never>];
                                        };
                                        readonly FURHAT_BLENDSHAPES: {
                                            readonly actions: readonly [({ event }: {
                                                event: any;
                                            }) => void, import("xstate").ActionFunction<import("xstate").MachineContext, import("xstate").EventObject, import("xstate").AnyEventObject, {}, never, never, never, never, never>];
                                        };
                                        readonly SPEAK_COMPLETE: {
                                            readonly target: "Idle";
                                            readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                                type: "SPEAK_COMPLETE";
                                            }, SpeechStateEvent, undefined, never, never, never, "NEW_TOKEN_INTERVAL", never>];
                                        };
                                    };
                                    readonly states: {
                                        readonly Start: {
                                            readonly meta: {
                                                readonly view: "idle";
                                            };
                                            readonly entry: readonly [({ event }: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => void, ({ context, event }: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => any];
                                            readonly on: {
                                                readonly TTS_STARTED: {
                                                    readonly target: "Proceed";
                                                    readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                                        type: "TTS_STARTED";
                                                    }, SpeechStateEvent, undefined, never, never, never, "NEW_TOKEN_INTERVAL", never>];
                                                };
                                            };
                                        };
                                        readonly Proceed: {
                                            readonly meta: {
                                                readonly view: "speaking";
                                            };
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Paused";
                                                    readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                        type: "CONTROL";
                                                    }, SpeechStateEvent>) => any];
                                                };
                                            };
                                        };
                                        readonly Paused: {
                                            readonly meta: {
                                                readonly view: "speaking-paused";
                                            };
                                            readonly on: {
                                                readonly SPEAK_COMPLETE: {};
                                                readonly CONTROL: {
                                                    readonly target: "Proceed";
                                                    readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                        type: "CONTROL";
                                                    }, SpeechStateEvent>) => any];
                                                };
                                            };
                                        };
                                    };
                                };
                                readonly WaitForRecogniser: {
                                    readonly meta: {
                                        readonly view: "idle";
                                    };
                                    readonly entry: readonly [() => void, ({ context, event }: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => any];
                                    readonly on: {
                                        readonly ASR_STARTED: {
                                            readonly target: "Recognising";
                                            readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                                type: "ASR_STARTED";
                                            }, SpeechStateEvent, undefined, never, never, never, "NEW_TOKEN_INTERVAL", never>];
                                        };
                                    };
                                };
                                readonly Recognising: {
                                    readonly initial: "Proceed";
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "#speechstate.Stopped";
                                            readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                type: "STOP";
                                            }, SpeechStateEvent>) => any];
                                        };
                                        readonly RECOGNISED: {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<SSContext, {
                                                type: "RECOGNISED";
                                                value: Hypothesis[];
                                                nluValue?: any;
                                            }, SpeechStateEvent>) => void, ({ event }: import("xstate").ActionArgs<SSContext, {
                                                type: "RECOGNISED";
                                                value: Hypothesis[];
                                                nluValue?: any;
                                            }, SpeechStateEvent>) => void, import("xstate").ActionFunction<SSContext, {
                                                type: "RECOGNISED";
                                                value: Hypothesis[];
                                                nluValue?: any;
                                            }, SpeechStateEvent, undefined, never, never, never, "NEW_TOKEN_INTERVAL", never>];
                                        };
                                    };
                                    readonly states: {
                                        readonly Proceed: {
                                            readonly meta: {
                                                readonly view: "recognising";
                                            };
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Paused";
                                                    readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                        type: "CONTROL";
                                                    }, SpeechStateEvent>) => any];
                                                };
                                            };
                                        };
                                        readonly Paused: {
                                            readonly meta: {
                                                readonly view: "recognising-paused";
                                            };
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Proceed";
                                                    readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                        type: "CONTROL";
                                                    }, SpeechStateEvent>) => any];
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                        readonly Fail: {
                            readonly meta: {
                                readonly view: "error";
                            };
                        };
                        readonly Stopped: {
                            readonly meta: {
                                readonly view: "stopped";
                            };
                        };
                    };
                };
            };
        };
    };
}>;
export { speechstate };
//# sourceMappingURL=speechstate.d.ts.map